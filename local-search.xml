<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>iOS组件化</title>
    <link href="/2021/04/30/iOS-Component/"/>
    <url>/2021/04/30/iOS-Component/</url>
    
    <content type="html"><![CDATA[<h3 id="组件化需求"><a href="#组件化需求" class="headerlink" title="组件化需求"></a>组件化需求</h3><p>随着公司业务的不断发展，项目的功能越来越复杂，各个业务代码耦合越来越多，代码量急剧增加，传统的 MVC 或者 MVVM 架构已经无法高效的管理工程代码，因此需要用一种技术来更好地管理工程，而组件化是一种能够解决代码耦合的技术。项目经过组件化的拆分，不仅可以解决代码耦合的问题，还可以增强代码的复用性，工程的易管理性等。</p><p>组件化是项目架构层面的技术，不是所有项目都适合组件化，组件化一般针对的是大中型的项目，并且是多人开发。如果，项目比较小，开发人员比较少，确实不太适合组件化，因为这时的组件化可能带来的不是便捷，而是增加了开发的工作量。另外，组件化过程也要考虑团队的情况，总之，根据目前项目的情况作出最合适的技术选型</p><h3 id="组件库层级划分"><a href="#组件库层级划分" class="headerlink" title="组件库层级划分"></a>组件库层级划分</h3><p><img src="/img/ios/component/ceji.png"></p><h3 id="远端索引库制作"><a href="#远端索引库制作" class="headerlink" title="远端索引库制作"></a>远端索引库制作</h3><h4 id="远端索引库作用描述"><a href="#远端索引库作用描述" class="headerlink" title="远端索引库作用描述"></a>远端索引库作用描述</h4><ol><li>第三方代码管理 </li><li>平台创建框架描述spec，包含：框架名称、版本、真正代码存放地址=远程地址 </li><li>上传spec到pod的远程索引库</li></ol><h4 id="远端索引库制作-1"><a href="#远端索引库制作-1" class="headerlink" title="远端索引库制作"></a>远端索引库制作</h4><ol><li><p>创建git仓库作为.spec 远端私有库</p></li><li><p>终端 pod repo list 查看本地私有库</p></li><li><p>pod repo add xxx 添加本地私有库</p></li><li><p>本地索引库还有一个检索索引文件，当添加第三方库的时候先去检索索引文件查找，再去本地索引库查找，然后再去真正的代码存放地址去下载第三方库</p></li></ol><h4 id="远端私有库-本地库-pod库关系"><a href="#远端私有库-本地库-pod库关系" class="headerlink" title="远端私有库,本地库,pod库关系"></a>远端私有库,本地库,pod库关系</h4><p><img src="/img/ios/component/podlib.png"></p><ol><li>创建自己的私有远程索引库</li><li>拉取私有远程索引库到本地</li><li>将自己的私有框架代码上传私有库中</li><li>将私有框架代码中的spec文件上传私有远程索引库</li><li>使用时，在Podfile添加source，下载过程同cocoapods</li></ol><h3 id="pod库制作相关"><a href="#pod库制作相关" class="headerlink" title="pod库制作相关"></a>pod库制作相关</h3><ol><li> pod lib create xxx 编辑podspec文件</li></ol><p><img src="/img/ios/component/podcreate.png"></p><ol start="2"><li>编辑.podspec文件添加对应版本信息及homepage, source </li><li>git add .</li><li>git commit -m “xx”</li><li>git push </li><li>git tag xxx</li><li>git push –tags</li><li>pod lib lint  本地验证</li><li>pod spec lint 远程验证</li><li>推送到私有索引库 pod repo push TAComponentSpec xxx.podspec–allow-warnings</li></ol><h3 id="pod私有库引入工程"><a href="#pod私有库引入工程" class="headerlink" title="pod私有库引入工程"></a>pod私有库引入工程</h3><p>工程podfile文件头部指定 source路径 pod 引入私有库 pod install 引入工程<br><img src="/img/ios/component/source.png"></p><h3 id="组件库交互-CTMediator"><a href="#组件库交互-CTMediator" class="headerlink" title="组件库交互(CTMediator)"></a>组件库交互(CTMediator)</h3><p><img src="/img/ios/component/ctMediat.png"></p><p><strong>target</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>(UIViewController <span class="hljs-strong">*)Action_nativeFetchDetailViewController:(NSDictionary *</span>)params;<br></code></pre></td></tr></table></figure><p><strong>CTMediator分类</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// CTMediator+CTMediatorModuleAActions.h</span><br><br>- (<span class="hljs-built_in">UIViewController</span> *)<span class="hljs-built_in">CTMediator_viewControllerForDetail</span>;<br><br><span class="hljs-comment">// CTMediator+CTMediatorModuleAActions.m</span><br><br>- (<span class="hljs-built_in">UIViewController</span> *)<span class="hljs-built_in">CTMediator_viewControllerForDetail</span><br>&#123;<br><span class="hljs-keyword">return</span> [<span class="hljs-keyword">self</span> performTarget:kCTMediatorTargetA action:kCTMediatorActionNativFetchDetailViewController params:@&#123;<span class="hljs-string">@&quot;key&quot;</span>:<span class="hljs-string">@&quot;value&quot;</span>&#125; shouldCacheTarget:<span class="hljs-literal">NO</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>调用</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">/ ViewController.h<br><span class="hljs-meta">#import <span class="hljs-meta-string">&quot;CTMediator+CTMediatorModuleAActions.h&quot;</span></span><br><br>[<span class="hljs-keyword">self</span> presentViewController:[[<span class="hljs-built_in">CTMediator</span> sharedInstance] <span class="hljs-built_in">CTMediator_viewControllerForDetail</span>] animated:<span class="hljs-literal">YES</span> completion:<span class="hljs-literal">nil</span>];<br><br></code></pre></td></tr></table></figure><p>从以上代码可以看出，使用者只需要依赖中间件，而中间件又不依赖组件，这是真正意义上的解耦</p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>oc与swift混编</title>
    <link href="/2021/02/05/swift-ocMixed/"/>
    <url>/2021/02/05/swift-ocMixed/</url>
    
    <content type="html"><![CDATA[<h3 id="swift-调用-oc"><a href="#swift-调用-oc" class="headerlink" title="swift 调用 oc"></a>swift 调用 oc</h3><ul><li><p>创建oc 文件默认生成 xxxx-Bridging-Header.h头文件</p></li><li><p>将 xxxx-Bridging-Header.h中 #import 暴露给swift 内容</p></li></ul><h4 id="swift调用oc-TestPerson-h-m"><a href="#swift调用oc-TestPerson-h-m" class="headerlink" title="swift调用oc- TestPerson.h .m"></a>swift调用oc- TestPerson.h .m</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">int</span> sum (<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b);<br><span class="hljs-keyword">void</span> testSwift();<br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">TestPerson</span> : <span class="hljs-title">NSObject</span></span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">assign</span>) <span class="hljs-built_in">NSInteger</span> age;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *name;<br>- (<span class="hljs-keyword">instancetype</span>)initWithAge:(<span class="hljs-built_in">NSInteger</span>)age name:(<span class="hljs-built_in">NSString</span> *)name;<br>+ (<span class="hljs-keyword">instancetype</span>)personWithAge:(<span class="hljs-built_in">NSInteger</span>)age name:(<span class="hljs-built_in">NSString</span> *)name;<br>-(<span class="hljs-keyword">void</span>)run;<br>+(<span class="hljs-keyword">void</span>)run;<br>- (<span class="hljs-keyword">void</span>)eat:(<span class="hljs-built_in">NSString</span> *)food other:(<span class="hljs-built_in">NSString</span> *)other;<br>+(<span class="hljs-keyword">void</span>)eat:(<span class="hljs-built_in">NSString</span> *)food other:(<span class="hljs-built_in">NSString</span> *)other;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-meta-string">&quot;TestPerson.h&quot;</span></span><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">TestPerson</span></span><br>- (<span class="hljs-keyword">instancetype</span>)initWithAge:(<span class="hljs-built_in">NSInteger</span>)age name:(<span class="hljs-built_in">NSString</span> *)name&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> init]) &#123;<br>        <span class="hljs-keyword">self</span>.age = age;<br>        <span class="hljs-keyword">self</span>.name = name;<br>    &#125;<br>    <span class="hljs-keyword">return</span>  <span class="hljs-keyword">self</span>;<br>&#125;<br><br>+ (<span class="hljs-keyword">instancetype</span>)personWithAge:(<span class="hljs-built_in">NSInteger</span>)age name:(<span class="hljs-built_in">NSString</span> *)name&#123;<br>    <span class="hljs-keyword">return</span>  [[<span class="hljs-keyword">self</span> alloc] initWithAge:age name:name];<br>&#125;<br>- (<span class="hljs-keyword">void</span>)eat:(<span class="hljs-built_in">NSString</span> *)food other:(<span class="hljs-built_in">NSString</span> *)other&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;实例方法food&quot;</span>);<br>&#125;<br><br>+ (<span class="hljs-keyword">void</span>)eat:(<span class="hljs-built_in">NSString</span> *)food other:(<span class="hljs-built_in">NSString</span> *)other&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;类方法&quot;</span>);<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)run&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;实例 run&quot;</span>);<br>&#125;<br>+ (<span class="hljs-keyword">void</span>)run &#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;person run&quot;</span>);<br>&#125;<br><span class="hljs-keyword">@end</span><br><span class="hljs-keyword">int</span> sum (<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) &#123; <span class="hljs-keyword">return</span>  a + b; &#125;;<br></code></pre></td></tr></table></figure><p>调用</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">var person = <span class="hljs-constructor">TestPerson(<span class="hljs-params">age</span>: 20, <span class="hljs-params">name</span>: <span class="hljs-string">&quot;zhangsan&quot;</span>)</span><br>person.age = <span class="hljs-number">20</span><br>person.name = <span class="hljs-string">&quot;lisi&quot;</span><br>person.run<span class="hljs-literal">()</span><br>person.eat(<span class="hljs-string">&quot;mian&quot;</span>, other: <span class="hljs-string">&quot;shuiguo&quot;</span>)<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TestPerson</span>.</span></span>eat(<span class="hljs-string">&quot;min&quot;</span>, other: <span class="hljs-string">&quot;qi&quot;</span>)<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TestPerson</span>.</span></span>run<span class="hljs-literal">()</span><br><br><br>print(sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>))<br></code></pre></td></tr></table></figure><h4 id="silgen-name"><a href="#silgen-name" class="headerlink" title="@_silgen_name"></a>@_silgen_name</h4><p>如果c语言暴露给swift，与swift中其他函数名冲突<br>可以使用@——sigen_name</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-built_in">int</span> sum (<span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b) &#123; <span class="hljs-keyword">return</span>  a + b<span class="hljs-comment">; &#125;;</span><br><span class="hljs-symbol">@_silgen_name</span>(<span class="hljs-string">&quot;sum&quot;</span>) <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swift_num</span><span class="hljs-params">(v1: Int,v2: Int)</span> -&gt; <span class="hljs-title">Int</span></span><br></code></pre></td></tr></table></figure><h3 id="oc调用swift"><a href="#oc调用swift" class="headerlink" title="oc调用swift"></a>oc调用swift</h3><p>xcode 默认生成oc调用swift头文件”xxx-Swift.h”</p><ul><li><p>swift暴露给oc的类最终继承与NSObject</p></li><li><p>@objc修饰需要暴露给oc成员</p></li><li><p>@objcMembers默认全部暴露给oc<br>//@objc 单个暴露给oc 全员暴露给 oc</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-meta">@objcMembers</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span>: <span class="hljs-title">NSObject</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> price: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">var</span> bind: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">init</span>(price: <span class="hljs-type">String</span> ,bind: <span class="hljs-type">String</span>) &#123;<br>        <span class="hljs-keyword">self</span>.price = price<br>        <span class="hljs-keyword">self</span>.bind = bind<br><br>    &#125;<br>    <span class="hljs-comment">//希望走runtime 加关键字 dynamic</span><br>     <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> &#123;<br>       <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;car run&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Car run&quot;</span>)<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testSwift</span>(<span class="hljs-params"></span>)</span> &#123;<br>    Car *car = [[Car alloc] initWithPrice:<span class="hljs-string">@&quot;2200&quot;</span> bind:<span class="hljs-string">@&quot;123&quot;</span>];<br>    [<span class="hljs-meta">car run</span>];<br>    car.price = <span class="hljs-string">@&quot;19999&quot;</span>;    <br>    [<span class="hljs-meta">car test</span>];<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><p>swift中仍然可以使用选择器#selector定义一个选择器<br>但必须被@objcMembers修饰或者@objc修饰方法</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">@objcMembers <span class="hljs-keyword">class</span> Car: NSObject &#123;<br><br>    func test(v1: <span class="hljs-type">Int</span>)  &#123;<br>        print(v1)<br>    &#125;<br>    func test1(v1:<span class="hljs-type">Int</span>,v2: <span class="hljs-type">Int</span>)  &#123;<br>        <br>    &#125;<br>    <br>    func run() &#123;<br>        <span class="hljs-keyword">perform</span>(#selector(test(v1:)))<br>        <span class="hljs-keyword">perform</span>(#selector(test1(v1:v2:)))<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>swift中字符串类型String与oc的NSString,api上有比较大的差异</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> str: String = <span class="hljs-string">&quot;1&quot;</span><br>str.append(<span class="hljs-string">&quot;2&quot;</span>)<br>str = <span class="hljs-string">&quot;\(str)_5&quot;</span><br><br><span class="hljs-selector-tag">var</span> str1 = <span class="hljs-string">&quot;123456&quot;</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(str1.hasPrefix(<span class="hljs-string">&quot;123&quot;</span>)</span></span>)<span class="hljs-comment">//true</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(str1.hasSuffix(<span class="hljs-string">&quot;456&quot;</span>)</span></span>)<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h4 id="String-插入删除"><a href="#String-插入删除" class="headerlink" title="String 插入删除"></a>String 插入删除</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">var <span class="hljs-keyword">str</span> = <span class="hljs-string">&quot;1_2&quot;</span><br><span class="hljs-keyword">str</span><span class="hljs-number">.</span>insert(<span class="hljs-string">&quot;_&quot;</span>, <span class="hljs-meta">at</span>: <span class="hljs-keyword">str</span><span class="hljs-number">.</span>endIndex)//<span class="hljs-string">&quot;1_2_&quot;</span><br><br><span class="hljs-keyword">str</span><span class="hljs-number">.</span>insert(contentsOf: <span class="hljs-string">&quot;3_4&quot;</span>, <span class="hljs-meta">at</span>: <span class="hljs-keyword">str</span><span class="hljs-number">.</span>endIndex)//<span class="hljs-string">&quot;1_2_3_4&quot;</span><br><br><span class="hljs-keyword">str</span><span class="hljs-number">.</span>insert(contentsOf: <span class="hljs-string">&quot;666&quot;</span>, <span class="hljs-meta">at</span>: <span class="hljs-keyword">str</span><span class="hljs-number">.</span>startIndex)//<span class="hljs-string">&quot;1666_2_3_4&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">str</span>.remove(at: <span class="hljs-built_in">str</span>.firstIndex(of: <span class="hljs-string">&quot;1&quot;</span>)!)<span class="hljs-comment">//&quot;666_2_3_4&quot;</span><br><span class="hljs-built_in">str</span>.removeAll&#123;$<span class="hljs-number">0</span> == <span class="hljs-string">&quot;6&quot;</span>&#125;<span class="hljs-comment">//&quot;_2_3_4&quot;</span><br><span class="hljs-built_in">var</span> rang = <span class="hljs-built_in">str</span>.<span class="hljs-keyword">index</span>(<span class="hljs-built_in">str</span>.endIndex,offsetBy: <span class="hljs-number">-2</span>) ..&lt; <span class="hljs-built_in">str</span>.<span class="hljs-keyword">index</span>(before: <span class="hljs-built_in">str</span>.endIndex)<br><span class="hljs-built_in">str</span>.removeSubrange(rang)<span class="hljs-comment">//_2_34</span><br></code></pre></td></tr></table></figure><h3 id="Substring"><a href="#Substring" class="headerlink" title="Substring"></a>Substring</h3><p><img src="/img/ios/swift/class/substing.png"></p><h3 id="swift、oc桥接转换表"><a href="#swift、oc桥接转换表" class="headerlink" title="swift、oc桥接转换表"></a>swift、oc桥接转换表</h3><p><img src="/img/ios/swift/class/zhuanhuan.png"></p><h3 id="可选协议"><a href="#可选协议" class="headerlink" title="可选协议"></a>可选协议</h3><p>可以通过@objc定义可选协议，这种协议只能被class遵守</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs swift"><br><span class="hljs-meta">@objc</span> <span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">TestProtocol</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br>   <span class="hljs-meta">@objc</span> <span class="hljs-keyword">optional</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="dynamic"><a href="#dynamic" class="headerlink" title="dynamic"></a>dynamic</h3><p>被@objc dynamic修饰内容具有动态性，比如方法会走runtime那一套</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span>: <span class="hljs-title">NSObject</span> </span>&#123;<br>    <span class="hljs-meta">@objc</span> <span class="hljs-keyword">dynamic</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span> &#123;&#125;<br>&#125;<br><span class="hljs-keyword">var</span> d = <span class="hljs-type">Dog</span>()<br>d.test1()<br><br></code></pre></td></tr></table></figure><h3 id="KVC-KVO"><a href="#KVC-KVO" class="headerlink" title="KVC\KVO"></a>KVC\KVO</h3><p>swift支持添加kvc\kvo<br>属性所在的类、监听器最终继承与NSObjcet<br>被@objc dynamic修饰</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observer</span>: <span class="hljs-title">NSObject</span> </span>&#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">observeValue</span><span class="hljs-params">(forKeyPath keyPath: String?, of object: <span class="hljs-keyword">Any</span>?, change: [NSKeyValueChangeKey : <span class="hljs-keyword">Any</span>]?, context: UnsafeMutableRawPointer?)</span></span> &#123;<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;observeValue&quot;</span>,change?[.newKey] <span class="hljs-keyword">as</span> <span class="hljs-type">Any</span>)<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>: <span class="hljs-title">NSObject</span> </span>&#123;<br>    <span class="hljs-meta">@objc</span> <span class="hljs-keyword">dynamic</span> <span class="hljs-keyword">var</span> age: <span class="hljs-type">Int</span> = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">var</span> observer:<span class="hljs-type">Observer</span> = <span class="hljs-type">Observer</span>()<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">init</span>() &#123;<br>        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>()<br>        <span class="hljs-keyword">self</span>.addObserver(observer, forKeyPath: <span class="hljs-string">&quot;age&quot;</span>, options: .new, context: <span class="hljs-literal">nil</span>)<br>    &#125;<br>    <span class="hljs-keyword">deinit</span> &#123;<br>        <span class="hljs-keyword">self</span>.removeObserver(observer, forKeyPath: <span class="hljs-string">&quot;age&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> p = <span class="hljs-type">Person</span>()<br>p.age  = <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><h3 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h3><p>swift中，class仍然可以使用关联对象</p><ul><li><p>默认情况 extension不可以增加存储属性</p></li><li><p>借助关联对象可以实现extension增加存储属性</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> <span class="hljs-type">AGE_KEY</span>: <span class="hljs-type">Bool</span> = <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">var</span> age: <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">get</span> &#123;<br>            objc_getAssociatedObject(<span class="hljs-keyword">self</span>, &amp;<span class="hljs-type">Person</span>.<span class="hljs-type">AGE_KEY</span>) <span class="hljs-keyword">as</span>! <span class="hljs-type">Int</span><br>        &#125;<br>        <span class="hljs-keyword">set</span> &#123;<br>            objc_setAssociatedObject(<span class="hljs-keyword">self</span>, &amp;<span class="hljs-type">Person</span>.<span class="hljs-type">AGE_KEY</span>, newValue, .<span class="hljs-type">OBJC_ASSOCIATION_ASSIGN</span>)<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> p = <span class="hljs-type">Person</span>()<br>p.age = <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">typealias</span> <span class="hljs-type">Task</span> = () -&gt; <span class="hljs-type">Void</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Async</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">async</span><span class="hljs-params">(<span class="hljs-keyword">_</span> task: @escaping Task)</span></span>&#123;<br>        _async(task)<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">async</span><span class="hljs-params">(<span class="hljs-keyword">_</span> task: @escaping Task,  <span class="hljs-keyword">_</span> mainTask: @escaping Task)</span></span> &#123;<br>        _async(task, mainTask)<br>    &#125;<br>    <br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span>  <span class="hljs-title">_async</span><span class="hljs-params">(<span class="hljs-keyword">_</span> task:  @escaping Task, <span class="hljs-keyword">_</span> mainTask: Task? = <span class="hljs-literal">nil</span>)</span></span> &#123;<br>        <span class="hljs-keyword">let</span> item = <span class="hljs-type">DispatchWorkItem</span>(block: task)<br>        <span class="hljs-type">DispatchQueue</span>.global().async(execute: item)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> main = mainTask &#123;<br>            item.notify(queue: <span class="hljs-type">DispatchQueue</span>.main, execute: main)<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">asyncDelay</span><span class="hljs-params">(<span class="hljs-keyword">_</span> second: Double, <span class="hljs-keyword">_</span> task: @escaping  Task, <span class="hljs-keyword">_</span> mainTask: @escaping Task)</span></span> -&gt; <span class="hljs-type">DispatchWorkItem</span> &#123;<br>        _asyncDelay(second, task, mainTask)<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span>  <span class="hljs-title">_asyncDelay</span><span class="hljs-params">(<span class="hljs-keyword">_</span> second: Double, <span class="hljs-keyword">_</span> task: @escaping Task,  <span class="hljs-keyword">_</span> mainTask: Task? = <span class="hljs-literal">nil</span>)</span></span> -&gt; <span class="hljs-type">DispatchWorkItem</span> &#123;<br>        <span class="hljs-keyword">let</span> itme = <span class="hljs-type">DispatchWorkItem</span>(block: task)<br>        <br>        <span class="hljs-type">DispatchQueue</span>.global().asyncAfter(deadline: <span class="hljs-type">DispatchTime</span>.now() + second, execute: itme)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> main = mainTask &#123;<br>            itme.notify(queue: <span class="hljs-type">DispatchQueue</span>.main, execute: main)<br>        &#125;<br>        <span class="hljs-keyword">return</span> itme<br>    &#125;<br>    <br>    <br>    <br>&#125;<br><br></code></pre></td></tr></table></figure><p>//加锁</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs swift">   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> data = [<span class="hljs-type">String</span>: <span class="hljs-type">Any</span>]()<br>    <br>    <span class="hljs-comment">//信号量加锁</span><br><span class="hljs-comment">//    private static var lock = DispatchSemaphore(value: 1)</span><br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> lock = <span class="hljs-type">NSRecursiveLock</span>()<br>    <br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">set</span> <span class="hljs-params">(<span class="hljs-keyword">_</span> key: String, value: <span class="hljs-keyword">Any</span>)</span></span> &#123;<br><span class="hljs-comment">//        lock.wait()</span><br><span class="hljs-comment">//        defer &#123;</span><br><span class="hljs-comment">//            lock.signal()</span><br><span class="hljs-comment">//        &#125;</span><br><span class="hljs-comment">//        data[key] = value</span><br>        <br>        lock.lock()<br>        <span class="hljs-keyword">defer</span> &#123;<br>            lock.unlock()<br>        &#125;<br>        data[key] = value<br>       <br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Swift</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存管理</title>
    <link href="/2021/02/05/swift-Memory/"/>
    <url>/2021/02/05/swift-Memory/</url>
    
    <content type="html"><![CDATA[<h3 id="swift内存管理"><a href="#swift内存管理" class="headerlink" title="swift内存管理"></a>swift内存管理</h3><p>跟oc一样，swift也是采取基于引用计数的ARC内存管理方案</p><p>swift的ARC有3中引用</p><ul><li><p>强引用，默认情况下,引用都是强引用</p></li><li><p>弱引用（weak）,通过weak定义弱引用（必须是可选类型var,实例销毁后，ARC会自动将弱引用置为nil ,ARC给弱引用置为nil时，不会触发属性观察器）</p></li><li><p>无主引用（unowned）,通过无主引用unowned定义无主引用<br>（不会产生强引用，实例销毁后仍然存储着实例对象内存地址，在试图访问实例销毁后的无主引用，会产生运行时错误）</p></li></ul><p>weak、unowned只能作用在类实例上</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">deinit</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;deinit&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> p: <span class="hljs-type">Person?</span> = <span class="hljs-type">Person</span>()<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><p><img src="/img/ios/swift/class/xunhuan.png"></p><h3 id="访问冲突"><a href="#访问冲突" class="headerlink" title="访问冲突"></a>访问冲突</h3><ul><li><p>至少有一个写入操作</p></li><li><p>它们访问的是同一块内存</p></li><li><p>它们访问的时间重叠</p></li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">var  a = <span class="hljs-number">1</span><br>func test(_ num: <span class="hljs-keyword">inout</span> Int) &#123;<br>    num += a<br>&#125;<br><br>test(&amp;a)<br><span class="hljs-comment">//解决访问冲突</span><br><br>var  a = <span class="hljs-number">1</span><br><br>func test(_ num: <span class="hljs-keyword">inout</span> Int) &#123;<br>    num += a<br>&#125;<br><br>var b = a<br>test(&amp;b)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Swift</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>扩展</title>
    <link href="/2021/02/04/swift-extension/"/>
    <url>/2021/02/04/swift-extension/</url>
    
    <content type="html"><![CDATA[<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>swift中扩展类似于oc 中分类<br><strong>扩展可以为枚举、类、结构体、协议增添新功能</strong><br>可以添加，方法，计算属性、下标、便捷初始化器、协议等</p><p><strong>扩展不能做的事</strong></p><ul><li><p>不能覆盖原有功能</p></li><li><p>不能添加存储属性，不能向已有的属性添加属性观察器</p></li><li><p>不能添加父类</p></li><li><p>不能添加指定初始化器与反初始化器</p></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Array</span> </span>&#123;<br>    <span class="hljs-keyword">subscript</span>(nullable idx: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Element?</span> &#123;<br>        <span class="hljs-keyword">if</span> (startIndex..&lt;endIndex).<span class="hljs-built_in">contains</span>(idx) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>[idx]<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]<br><br><span class="hljs-keyword">var</span> a = arr[nullable: <span class="hljs-number">2</span>]! <br><span class="hljs-built_in">print</span>(a)<br></code></pre></td></tr></table></figure><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>扩展可以给协议提供默认实现，也可以间接提供可选协议</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">TestProtocol</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">TestProtocol</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;test&quot;</span>)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;test1&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果一个类已经实现了协议所有要求，但还没有声明遵守它，可以通过扩展来实现</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">TestProtocol</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">testClass</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;test&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">testClass</span>: <span class="hljs-title">TestProtocol</span></span>&#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">var</span> elements = [<span class="hljs-type">E</span>]()<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">_</span> element: E)</span></span> &#123;<br>        elements.append(element)<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Stack</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span>  <span class="hljs-title">top</span><span class="hljs-params">()</span></span> -&gt;  <span class="hljs-type">E</span>&#123;<br>        elements.last!<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Swift</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高级运算符</title>
    <link href="/2021/02/04/swift-operator/"/>
    <url>/2021/02/04/swift-operator/</url>
    
    <content type="html"><![CDATA[<h3 id="溢出运算符"><a href="#溢出运算符" class="headerlink" title="溢出运算符"></a>溢出运算符</h3><ul><li><p>swift的运算符出现溢出时会抛出运行时错误</p></li><li><p>swift有溢出运算符(&amp;+,&amp;-,&amp;*)</p></li></ul><p><img src="/img/ios/swift/class/yunsuanfu.png"></p><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>枚举、类、结构体、可以为已有的运算符提供自定义实现，这个操作叫运算符重载</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs gml">struct Point &#123;<br>    <span class="hljs-keyword">var</span> <span class="hljs-symbol">x</span>:Int<br>    <span class="hljs-keyword">var</span> <span class="hljs-symbol">y</span>:Int<br>    init(<span class="hljs-symbol">x</span>: Int , <span class="hljs-symbol">y</span>: Int) &#123;<br>        <span class="hljs-literal">self</span>.<span class="hljs-symbol">x</span> = <span class="hljs-symbol">x</span><br>        <span class="hljs-literal">self</span>.<span class="hljs-symbol">y</span> = <span class="hljs-symbol">y</span><br>    &#125;<br>    <br>    <span class="hljs-comment">//类方法</span><br>   static func + (p1: Point, p2: Point) -&gt; Point &#123;<br>        <br>        <span class="hljs-keyword">return</span> Point(<span class="hljs-symbol">x</span>: p1.<span class="hljs-symbol">x</span> + p2.<span class="hljs-symbol">x</span>, <span class="hljs-symbol">y</span>: p1.<span class="hljs-symbol">y</span> + p2.<span class="hljs-symbol">y</span>)<br>    &#125;<br>    <br>   <span class="hljs-comment">// 中缀运算符</span><br>    static func - (p1: Point, p2: Point) -&gt; Point &#123;<br>    <br>      <span class="hljs-keyword">return</span> Point(<span class="hljs-symbol">x</span>: p1.<span class="hljs-symbol">x</span> -  p2.<span class="hljs-symbol">x</span>, <span class="hljs-symbol">y</span>: p1.<span class="hljs-symbol">y</span> - p2.<span class="hljs-symbol">y</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> p1 = Point(<span class="hljs-symbol">x</span>: <span class="hljs-number">10</span>, <span class="hljs-symbol">y</span>: <span class="hljs-number">10</span>)<br><span class="hljs-keyword">var</span> p2 = Point(<span class="hljs-symbol">x</span>: <span class="hljs-number">5</span>, <span class="hljs-symbol">y</span>: <span class="hljs-number">5</span>)<br><br>let p3  = p1 + p2<br></code></pre></td></tr></table></figure><h3 id="Equatable"><a href="#Equatable" class="headerlink" title="Equatable"></a>Equatable</h3><p>判断两个实例是否相等，一般遵守Equatable协议，重载 == 运算符</p><p>引用类型比较存储地址是否相同</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> : <span class="hljs-title">Equatable</span> </span>&#123;<br>   <br>    <br>    <span class="hljs-keyword">var</span> age = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">init</span>(age: <span class="hljs-type">Int</span>) &#123;<br>        <span class="hljs-keyword">self</span>.age = age<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> == <span class="hljs-params">(lhs: Person, rhs: Person)</span></span> -&gt; <span class="hljs-type">Bool</span> &#123;<br>        lhs.age == rhs.age<br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-keyword">var</span> per1 = <span class="hljs-type">Person</span>(age: <span class="hljs-number">20</span>)<br><br><span class="hljs-keyword">var</span> per2 = <span class="hljs-type">Person</span>(age: <span class="hljs-number">20</span>)<br><br>per1 == per2<br></code></pre></td></tr></table></figure><h3 id="自定义运算符"><a href="#自定义运算符" class="headerlink" title="自定义运算符"></a>自定义运算符</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">prefix</span> <span class="hljs-keyword">operator</span> +++  <span class="hljs-comment">//前缀运算符</span><br><span class="hljs-keyword">postfix</span> <span class="hljs-keyword">operator</span> -- <span class="hljs-comment">//后缀运算符</span><br><span class="hljs-keyword">infix</span> <span class="hljs-keyword">operator</span> == <span class="hljs-comment">//中缀运算符</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">prefix</span> <span class="hljs-function"><span class="hljs-keyword">func</span> +++ <span class="hljs-params">(p: <span class="hljs-keyword">inout</span> Point)</span></span> -&gt; <span class="hljs-type">Point</span> &#123;<br>        p = <span class="hljs-type">Point</span>(x: p.x + p.x , y: p.y + p.y)<br>        <span class="hljs-keyword">return</span> p<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> p = <span class="hljs-type">Point</span>(x: <span class="hljs-number">10</span>, y: <span class="hljs-number">20</span>)<br>+++p<br><span class="hljs-built_in">print</span>(p)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Swift</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>泛型</title>
    <link href="/2021/02/04/swift-Generics/"/>
    <url>/2021/02/04/swift-Generics/</url>
    
    <content type="html"><![CDATA[<p>泛型可以将类型参数化，提高代码复用率，减少代码量</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">func swapValus&lt;T&gt;(_ v1: <span class="hljs-keyword">inout</span> T , _ v2: <span class="hljs-keyword">inout</span> T)  &#123;<br>    (v1,v2) = (v2,v1)<br>&#125;<br>var a = <span class="hljs-number">10</span><br>var b = <span class="hljs-number">10</span><br>swapValus(&amp;a, &amp;b)<br>var c = <span class="hljs-number">10.0</span><br>var d = <span class="hljs-number">20.0</span><br>swapValus(&amp;c, &amp;d)<br></code></pre></td></tr></table></figure><h3 id="关联类型"><a href="#关联类型" class="headerlink" title="关联类型"></a>关联类型</h3><p>给协议用的类型定义一个占位符，协议中可以定义多个关联类型</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Stackable</span> </span>&#123;<br>    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Element</span><br>    <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">_</span> element: Element)</span></span><br>    <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Element</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">top</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Element</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Int</span> <br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">Stack</span> &lt;<span class="hljs-title">E</span>&gt;: <span class="hljs-title">Stackable</span></span>&#123;<br>    <span class="hljs-keyword">var</span> elements = [<span class="hljs-type">E</span>]()<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">_</span> element: E)</span></span> &#123;<br>        elements.append(element)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pop</span> <span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">E</span>&#123;<br>        elements.removeLast()<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">top</span><span class="hljs-params">()</span></span>  -&gt; <span class="hljs-type">E</span>&#123;<br>        elements.last!<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> elements.<span class="hljs-built_in">count</span><br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Swift</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>错误处理</title>
    <link href="/2021/02/04/swift-error/"/>
    <url>/2021/02/04/swift-error/</url>
    
    <content type="html"><![CDATA[<h3 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h3><p>常见错误类型语法错误、逻辑错误、运行时错误</p><p>swift中可以通过Error协议自定义错误信息</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SomeError</span>: <span class="hljs-title">Error</span> &#123;</span><br>    <span class="hljs-keyword">case</span> illeag(String)<br>    <span class="hljs-keyword">case</span> outOfBund(Int,Int)<br>    <span class="hljs-keyword">case</span> outMermey<br>&#125;<br></code></pre></td></tr></table></figure><p>内部通 throw抛出错误</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span>  <span class="hljs-title">divdi</span><span class="hljs-params">(<span class="hljs-keyword">_</span> num1: Int ,<span class="hljs-keyword">_</span> num2: Int)</span></span> <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">Int</span>&#123;<br>    <span class="hljs-comment">//处理不合理函数</span><br>    <span class="hljs-keyword">if</span> num2 == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-comment">//抛出错误</span><br>        <span class="hljs-keyword">throw</span>  <span class="hljs-type">SomeError</span>.illeag(<span class="hljs-string">&quot;o不能作为整数&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="do-catch-捕捉错误"><a href="#do-catch-捕捉错误" class="headerlink" title="do-catch 捕捉错误"></a>do-catch 捕捉错误</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>       <span class="hljs-built_in">print</span>( <span class="hljs-keyword">try</span> divdi(<span class="hljs-number">20</span>, <span class="hljs-number">0</span>))<br>    &#125; <span class="hljs-keyword">catch</span> <span class="hljs-keyword">let</span> <span class="hljs-type">SomeError</span>.illeag(msg) &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;参数错误&quot;</span>,msg)<br>    &#125;<span class="hljs-keyword">catch</span> <span class="hljs-keyword">let</span> <span class="hljs-type">SomeError</span>.outOfBund(size, index) &#123;<br>        <span class="hljs-built_in">print</span>(size,index)<br>    &#125;<span class="hljs-keyword">catch</span> <span class="hljs-keyword">let</span> <span class="hljs-type">SomeError</span>.outMermey&#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;内存泄漏&quot;</span>)<br>    &#125;<span class="hljs-keyword">catch</span>&#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;其他错误&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-built_in">print</span>( <span class="hljs-keyword">try</span> divdi(<span class="hljs-number">20</span>, <span class="hljs-number">0</span>))<br>    &#125; <span class="hljs-keyword">catch</span> <span class="hljs-keyword">let</span> error <span class="hljs-keyword">as</span> <span class="hljs-type">SomeError</span> &#123;<br>        <span class="hljs-built_in">print</span>(error)<br>    &#125;<span class="hljs-keyword">catch</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;其他错误&quot;</span>)<br>    &#125;<br>&#125;<br>test()<br></code></pre></td></tr></table></figure><h3 id="try-try"><a href="#try-try" class="headerlink" title="try? try!"></a>try? try!</h3><p>使用try? try! 处理可能抛出Error错误的函数，这样就不处理error</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span>  <span class="hljs-title">divdi</span><span class="hljs-params">(<span class="hljs-keyword">_</span> num1: Int ,<span class="hljs-keyword">_</span> num2: Int)</span></span> <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">Int</span>&#123;<br>    <span class="hljs-comment">//处理不合理函数</span><br>    <span class="hljs-keyword">if</span> num2 == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-comment">//抛出错误</span><br>        <span class="hljs-keyword">throw</span>  <span class="hljs-type">SomeError</span>.illeag(<span class="hljs-string">&quot;o不能作为整数&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> num1 / num2<br>&#125;<br><br><span class="hljs-keyword">var</span> result = <span class="hljs-keyword">try</span>? divdi(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h3 id="rethrows"><a href="#rethrows" class="headerlink" title="rethrows"></a>rethrows</h3><p>闭包参数引起的错误</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">exec</span><span class="hljs-params">(<span class="hljs-keyword">_</span> fn:<span class="hljs-params">(Int,Int)</span></span></span> <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">Int</span>, <span class="hljs-keyword">_</span> num1: <span class="hljs-type">Int</span>, <span class="hljs-keyword">_</span> num2: <span class="hljs-type">Int</span>) <span class="hljs-keyword">rethrows</span> &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-keyword">try</span> fn(num1,num2))<br>&#125;<br><span class="hljs-keyword">try</span> exec(divdi, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p>代码块结束之前必须执行,将延迟当前作用域结束之前执行</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>  &#123;<br>    <span class="hljs-keyword">defer</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;ee&quot;</span>)<br>    &#125;<br>   <span class="hljs-built_in">print</span>(<span class="hljs-keyword">try</span> divdi(<span class="hljs-number">20</span>, <span class="hljs-number">0</span>))<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="fatalError"><a href="#fatalError" class="headerlink" title="fatalError"></a>fatalError</h3><p>如果遇到严重问题，希望结束程序运行，可以直接使用fatalError抛出错误</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">_</span> num: Int)</span></span> -&gt; <span class="hljs-type">Int</span> &#123;<br>    <span class="hljs-keyword">if</span> num &gt;= <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;num不小于9&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Swift</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>协议</title>
    <link href="/2021/02/04/swift-protocol/"/>
    <url>/2021/02/04/swift-protocol/</url>
    
    <content type="html"><![CDATA[<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>协议可以用来定义方法、属性、下标的声明,协议可以被枚举、类、结构体所遵守</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Drwawnbale</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">var</span> x: <span class="hljs-type">Int</span> &#123;<span class="hljs-keyword">get</span>&#125;<br>    <span class="hljs-keyword">subscript</span>(index: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span>&#123;<span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span>&#125;<br> &#125;<br><br></code></pre></td></tr></table></figure><p>协议中定义方法不能有默认参数值</p><p>默认情况下，定义的内容必须全部实现</p><h3 id="协议中的属性"><a href="#协议中的属性" class="headerlink" title="协议中的属性"></a>协议中的属性</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Drwawnbale</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">var</span> x: <span class="hljs-type">Int</span> &#123;<span class="hljs-keyword">get</span>&#125;<br>    <span class="hljs-keyword">var</span> y: <span class="hljs-type">Int</span> &#123;<span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span>&#125;<br>    <span class="hljs-keyword">subscript</span>(index: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span>&#123;<span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span>&#125;<br> &#125;<br></code></pre></td></tr></table></figure><ul><li><p>协议中定义属性必须是 var </p></li><li><p>实现协议属性权限不能小于协议中定义属性权限</p></li><li><p>协议定义 get set 用var 实现存储属性或计算属性</p></li><li><p>协议定义 get 任何属性都能实现</p></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Drwawnbale</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">var</span> x: <span class="hljs-type">Int</span> &#123;<span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span>&#125;<br>    <span class="hljs-keyword">var</span> y: <span class="hljs-type">Int</span> &#123;<span class="hljs-keyword">get</span> &#125;<br>    <span class="hljs-keyword">subscript</span>(index: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span>&#123;<span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span>&#125;<br> &#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> : <span class="hljs-title">Drwawnbale</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span> &#123;&#125;<br>    <span class="hljs-keyword">var</span> x:<span class="hljs-type">Int</span> = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">var</span> y: <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">set</span>&#123;&#125;<br>        <span class="hljs-keyword">get</span> &#123;<span class="hljs-number">0</span>&#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">subscript</span>(index: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">get</span>&#123; index &#125;<br>        <span class="hljs-keyword">set</span>&#123;&#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="static、class"><a href="#static、class" class="headerlink" title="static、class"></a>static、class</h3><p>为保证通用，定义类方法、类属性、类型下标必须用static </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Drwawnbale</span> </span>&#123;<br>   <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br> &#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> : <span class="hljs-title">Drwawnbale</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">func</span> <span class="hljs-title">test</span>() </span>&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="mutating"><a href="#mutating" class="headerlink" title="mutating"></a>mutating</h3><p>只有将协议的实例方法标记为 mutating</p><ul><li><p>才能允许结构体、枚举具体实现自身修改</p></li><li><p>类实现实例方法不同加mutating、 结构体、枚举需要</p></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Drwawnbale</span> </span>&#123;<br>   <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br> &#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> : <span class="hljs-title">Drwawnbale</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> x: <span class="hljs-type">Int</span> = <span class="hljs-number">10</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> &#123;<br>        x += <span class="hljs-number">10</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span>: <span class="hljs-title">Drwawnbale</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> x: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> &#123;<br>        x += <span class="hljs-number">10</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><p>协议中还可以定义init,非final 必须加required</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">protocol Drwawnbale &#123;<br>    <span class="hljs-keyword">init</span>(x: <span class="hljs-built_in">Int</span>, y: <span class="hljs-built_in">Int</span>)<br> &#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>: <span class="hljs-type">Drwawnbale &#123;</span></span><br>    required <span class="hljs-keyword">init</span>(x: <span class="hljs-built_in">Int</span>, y: <span class="hljs-built_in">Int</span>) &#123;<br>        <br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> : <span class="hljs-type">Drwawnbale&#123;</span></span><br>    <span class="hljs-keyword">init</span>(x: <span class="hljs-built_in">Int</span>, y: <span class="hljs-built_in">Int</span>) &#123;<br>        <br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>协议初始化定义，与父类初始化相同 实现必须加required override</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">protocol Drwawnbale &#123;<br>    <span class="hljs-keyword">init</span>(x: <span class="hljs-built_in">Int</span>, y: <span class="hljs-built_in">Int</span>)<br> &#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">init</span>(x: <span class="hljs-built_in">Int</span>, y: <span class="hljs-built_in">Int</span>) &#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>: <span class="hljs-type">Person</span>,<span class="hljs-type">Drwawnbale&#123;</span></span><br>    required <span class="hljs-keyword">override</span> <span class="hljs-keyword">init</span>(x: <span class="hljs-built_in">Int</span>, y: <span class="hljs-built_in">Int</span>) &#123;<br>        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(x: x, y: y)<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="is-as-as-as"><a href="#is-as-as-as" class="headerlink" title="is as as? as!"></a>is as as? as!</h3><p>is来判断是否是某种类型， as来做强制转换</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Runable</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>: <span class="hljs-title">Person</span>, <span class="hljs-title">Runable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> &#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span> &#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> stu: <span class="hljs-type">Any</span> = <span class="hljs-number">10</span><br><span class="hljs-built_in">print</span>(stu <span class="hljs-keyword">is</span> <span class="hljs-type">Int</span>)<br>stu = <span class="hljs-type">Student</span>()<br><span class="hljs-built_in">print</span>(stu <span class="hljs-keyword">is</span> <span class="hljs-type">Student</span>)<br></code></pre></td></tr></table></figure><p>as? as!</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">Runable</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>: <span class="hljs-title">Person</span>, <span class="hljs-title">Runable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> &#123;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">study</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;study&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> stu: <span class="hljs-type">Any</span> = <span class="hljs-number">10</span><br><br>(stu <span class="hljs-keyword">as</span>? <span class="hljs-type">Student</span>)?.study()<br>stu = <span class="hljs-type">Student</span>()<br><br>(stu <span class="hljs-keyword">as</span>! <span class="hljs-type">Student</span>).study()<span class="hljs-comment">//study</span><br><br>(stu <span class="hljs-keyword">as</span>? <span class="hljs-type">Student</span>)?.study()<span class="hljs-comment">//study</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Swift</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初始化器</title>
    <link href="/2020/12/04/swift-init/"/>
    <url>/2020/12/04/swift-init/</url>
    
    <content type="html"><![CDATA[<h3 id="初始化器介绍"><a href="#初始化器介绍" class="headerlink" title="初始化器介绍"></a>初始化器介绍</h3><p>类、结构体、枚举都可以定义初始化器</p><p>类的初始化器有两种: 指定初始化器、便捷初始化器</p><ul><li><p>每个类至少有一个指定初始化器，指定初始化器是类主要的初始器</p></li><li><p>默认初始化器是类的指定初始化器</p></li><li><p>类偏向于少量初始化器，一个类通常只要一个指定初始器</p></li></ul><p><strong>初始化器互相调用规则</strong></p><ul><li><p>指定初始化器必须从它的直系父类调用指定初始化器</p></li><li><p>便捷初始化器必须从它相同类里调用另一个初始化器</p></li><li><p>便捷初始化器最终必须调用一个指定初始化器</p></li></ul><h3 id="初始化器调用规则"><a href="#初始化器调用规则" class="headerlink" title="初始化器调用规则"></a>初始化器调用规则</h3><p><img src="/img/ios/swift/class/classchushihua.png"></p><h3 id="两段式初始化"><a href="#两段式初始化" class="headerlink" title="两段式初始化"></a>两段式初始化</h3><p><img src="/img/ios/swift/class/lianduanchushi.png"></p><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><ul><li><p>当重写父类的指定初始化器，必须加上override</p></li><li><p>如果子类写了一个匹配父类便捷初始化，不用加override</p></li></ul><h3 id="自动继承"><a href="#自动继承" class="headerlink" title="自动继承"></a>自动继承</h3><ul><li><p>如果子类没有自定义任何初始化器，它会自动继承父类所有的指定初始化器</p></li><li><p>子类自动继承所有的父类初始化器</p></li></ul><h3 id="required"><a href="#required" class="headerlink" title="required"></a>required</h3><p>用required修饰指定初始化器,表明所有子类都必须实现改初始器，如果子类重写required初始化器，必须加上required，不同加override</p><h3 id="可失败初始器"><a href="#可失败初始器" class="headerlink" title="可失败初始器"></a>可失败初始器</h3><p><img src="/img/ios/swift/class/faileinit.png"></p><h3 id="反初始化器"><a href="#反初始化器" class="headerlink" title="反初始化器"></a>反初始化器</h3><ul><li><p>deinit叫做反初始化器，类似于oc dealloc方法</p></li><li><p>deinit不接收任何参数，不能包括小括号</p></li><li><p>父类的deinit能被子类继承</p></li><li><p>子类deinit执行完后调用父类deinit</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Swift</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>继承</title>
    <link href="/2020/12/03/swift-inheritance/"/>
    <url>/2020/12/03/swift-inheritance/</url>
    
    <content type="html"><![CDATA[<h3 id="继承介绍"><a href="#继承介绍" class="headerlink" title="继承介绍"></a>继承介绍</h3><ol><li>值类型（枚举、结构体）不支持继承，只有类支持继承 </li><li>没有父类的类称为基类</li><li>子类可以重写父类的属性、方法、下标,但必须加override**</li></ol><h4 id="重写类型方法、下标"><a href="#重写类型方法、下标" class="headerlink" title="重写类型方法、下标"></a>重写类型方法、下标</h4><ul><li><p>被class修饰的类型方法、下标可以被重写</p></li><li><p>被static修饰的类型方法、下标不可以被重写</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">func</span> <span class="hljs-title">speak</span></span>() &#123;<br>        print(<span class="hljs-string">&quot;animal speak&quot;</span>)<br>    &#125;<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">subscript</span> </span>(index: <span class="hljs-built_in">Int</span>)  -&gt; <span class="hljs-built_in">Int</span>&#123;<br>        <span class="hljs-keyword">return</span> index<br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">func</span> <span class="hljs-title">run</span></span>() &#123;<br>        <br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span>: <span class="hljs-type">Animal &#123;</span></span><br>    <span class="hljs-keyword">override</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">func</span> <span class="hljs-title">speak</span></span>() &#123;<br>        <span class="hljs-keyword">super</span>.speak()<br>        print(<span class="hljs-string">&quot;dog speak&quot;</span>)<br>    &#125;<br>    <br>    <span class="hljs-keyword">override</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">subscript</span></span>(index: <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>[index] + <span class="hljs-number">1</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="重写属性"><a href="#重写属性" class="headerlink" title="重写属性"></a>重写属性</h4><ul><li><p>子类可以将父类的属性（存储、计算）重写为计算属性</p></li><li><p>子类不可以将父类的属性，重写为存储属性</p></li><li><p>只能重写var属性</p></li><li><p>重写时，属性名、类型要相同</p></li><li><p>子类重写后的属性权限不能小于父类</p></li></ul><h4 id="属性观察器"><a href="#属性观察器" class="headerlink" title="属性观察器"></a>属性观察器</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span></span>&#123;<br>    <span class="hljs-keyword">var</span> radus: <span class="hljs-type">Int</span> = <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">willSet</span>&#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Circle willSet&quot;</span>,newValue)<br>        &#125;<br>        <span class="hljs-keyword">didSet</span> &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Circle didSet&quot;</span>,oldValue,radus)<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">subCircle</span> : <span class="hljs-title">Circle</span> </span>&#123;<br>   <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> radus: <span class="hljs-type">Int</span>  &#123;<br>        <span class="hljs-keyword">willSet</span>&#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;subCircle willSet&quot;</span>,newValue)<br>        &#125;<br>        <span class="hljs-keyword">didSet</span> &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;subCircle didSet&quot;</span>,oldValue,radus)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> circle = subCircle()<br>circle.radus = <span class="hljs-number">10</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">打印</span><br><span class="hljs-comment">subCircle willSet 10</span><br><span class="hljs-comment">Circle willSet 10</span><br><span class="hljs-comment">Circle didSet 1 10</span><br><span class="hljs-comment">subCircle didSet 1 10</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><ul><li><p>被final修饰的禁止重写 属性、下标、方法</p></li><li><p>被final修饰的类禁止继承</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Swift</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>方法、下标</title>
    <link href="/2020/12/03/swift-method/"/>
    <url>/2020/12/03/swift-method/</url>
    
    <content type="html"><![CDATA[<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>类、枚举、结构体都可以定义实例方法、类方法</p><ul><li><p>实例方法，通过实例对象调用</p></li><li><p>类方法 通过类型调用，通过static\class定义</p></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>&#123;<br>    <span class="hljs-comment">//使用了 gcd once 保证线程安全</span><br>    <br>    <span class="hljs-comment">//本质就是一个全局变量</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> <span class="hljs-built_in">count</span>: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span><br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getCounter</span> <span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Int</span>&#123;<br>         <span class="hljs-keyword">self</span>.<span class="hljs-built_in">count</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="mutating"><a href="#mutating" class="headerlink" title="mutating"></a>mutating</h4><p>结构体和枚举值类型，默认情况下，自身属性不允许被自身实例方法修改<br>在func前头加  mutating可以修改</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">var</span> y = <span class="hljs-number">0</span><br>   <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">move</span><span class="hljs-params">(deX: Int, deY: Int)</span></span>&#123;<br>        x  += deX<br>        y  += deY<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="discardableResult"><a href="#discardableResult" class="headerlink" title="@discardableResult"></a>@discardableResult</h4><p>@discardableResult 可以消除返回值未使用的警告</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-symbol">@discardableResult</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getfn</span><span class="hljs-params">()</span> -&gt;<span class="hljs-title">Int</span> &#123;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span><br>&#125;<br>getfn()<br></code></pre></td></tr></table></figure><h3 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h3><p>使用subscript可以给任意类型，增加下标功能</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> x = <span class="hljs-number">0.0</span>, y = <span class="hljs-number">0.0</span><br>    subscript (index: <span class="hljs-type">Int</span>) -&gt; Double &#123;<br>        <span class="hljs-keyword">set</span> &#123;<br>            <span class="hljs-keyword">if</span> index == <span class="hljs-number">0</span> &#123;<br>                x = <span class="hljs-keyword">new</span><span class="hljs-type">Value</span><br><span class="hljs-type"></span>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                y = <span class="hljs-keyword">new</span><span class="hljs-type">Value</span><br><span class="hljs-type"></span>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">get</span> &#123;<br>            <span class="hljs-keyword">if</span> index == <span class="hljs-number">0</span> &#123;<br>               <span class="hljs-keyword">return</span> x<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>               <span class="hljs-keyword">return</span> y<br>            &#125;<br>        &#125;<br>        <br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> p = Point()<br><br>p[<span class="hljs-number">0</span>] = <span class="hljs-number">11.0</span><br>p[<span class="hljs-number">1</span>] = <span class="hljs-number">12.0</span><br><br>print(p.x)<br></code></pre></td></tr></table></figure><p>下标可以没有set方法，但必须有get方法，如果只有get 可以省略</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> x = <span class="hljs-number">0.0</span>, y = <span class="hljs-number">0.0</span><br>    subscript (index: <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Double</span> &#123;<br>            <span class="hljs-keyword">if</span> index == <span class="hljs-number">0</span> &#123;<br>               <span class="hljs-keyword">return</span> x<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>               <span class="hljs-keyword">return</span> y<br>            &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>下标有多个返回值</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Grid &#123;<br>    var data = [[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]]<br>    subscript(<span class="hljs-keyword">row</span>: <span class="hljs-type">Int</span> ,<span class="hljs-keyword">column</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span>&#123;<br>        <span class="hljs-keyword">set</span>&#123;<br>            guard <span class="hljs-keyword">row</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">row</span> &lt; <span class="hljs-number">3</span> &amp;&amp; <span class="hljs-keyword">column</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">column</span> &lt; <span class="hljs-number">3</span>  <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>            data[<span class="hljs-keyword">row</span>][<span class="hljs-keyword">column</span>] = newValue<br>        &#125;<br>        <span class="hljs-keyword">get</span> &#123;<br>            guard <span class="hljs-keyword">row</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">row</span> &lt; <span class="hljs-number">3</span> &amp;&amp; <span class="hljs-keyword">column</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">column</span> &lt; <span class="hljs-number">3</span>  <span class="hljs-keyword">else</span> &#123;<br>             <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>            &#125;<br><br>          <span class="hljs-keyword">return</span> data[<span class="hljs-keyword">row</span>][<span class="hljs-keyword">column</span>]<br>        &#125;<br>    &#125;<br>&#125;<br>var grid = Grid()<br>grid[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>] = <span class="hljs-number">77</span><br>grid[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] = <span class="hljs-number">88</span><br>grid[<span class="hljs-number">2</span>,<span class="hljs-number">0</span>] = <span class="hljs-number">99</span><br>print(grid.data)//[[<span class="hljs-number">0</span>, <span class="hljs-number">77</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">88</span>], [<span class="hljs-number">99</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]]<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Swift</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>闭包</title>
    <link href="/2020/12/03/swift-closure/"/>
    <url>/2020/12/03/swift-closure/</url>
    
    <content type="html"><![CDATA[<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p><strong>-个函数和它捕获的变量或常量组合起来，成为闭包</strong></p><ul><li><p>一般是定义在函数内部的函数</p></li><li><p>一般它捕获的是外层函数的局部变量或常量</p></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">typealias</span> <span class="hljs-type">Fn</span> = (<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getFn</span> <span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Fn</span> &#123;<br>    <span class="hljs-comment">//申请一块堆空间内存 保存num</span><br>    <span class="hljs-keyword">var</span> num = <span class="hljs-number">0</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">plus</span> <span class="hljs-params">(<span class="hljs-keyword">_</span> i: Int)</span></span> -&gt; <span class="hljs-type">Int</span> &#123;<br>        num += i<br>        <span class="hljs-keyword">return</span> num<br>    &#125;<br><br>    num = <span class="hljs-number">14</span><br>    <span class="hljs-keyword">return</span> plus <span class="hljs-comment">// 捕获发生在返回</span><br>&#125;<br></code></pre></td></tr></table></figure><p>plus和num形成了闭包</p><p><strong>可以把闭包想成一个类的实例对象，类似于oc里block</strong></p><ul><li>内存在堆空间</li><li>捕获的变量或常量是实例的成员变量</li><li>组成闭包的函数是类内部定义方法</li></ul><p>上述示例代码等价于</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">clouser</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> num = <span class="hljs-number">0</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">plus</span><span class="hljs-params">(<span class="hljs-keyword">_</span> i : Int)</span></span> -&gt; <span class="hljs-type">Int</span> &#123;<br>        num += i<br>        <span class="hljs-keyword">return</span> num<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="闭包的循环引用"><a href="#闭包的循环引用" class="headerlink" title="闭包的循环引用"></a>闭包的循环引用</h4><p>与 OC 中的 block 类似，Swift 闭包也会强引用被它捕获的对象，从而引发可能的循环引用问题。<br>本身调用了对象的属性或方法，从而捕获了本身，造成循环引用问题</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><br>    <span class="hljs-keyword">var</span> fn: <span class="hljs-function"><span class="hljs-params">(() -&gt; ())</span>?</span><br><span class="hljs-function">    <span class="hljs-title">func</span> <span class="hljs-title">run</span><span class="hljs-params">()</span>&#123;</span><br><span class="hljs-function">        <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">&quot;run&quot;</span>)</span></span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">    <span class="hljs-title">deinit</span> &#123;</span><br><span class="hljs-function">        <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">&quot;deinit&quot;</span>)</span></span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"><span class="hljs-title">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span>&#123;</span><br><span class="hljs-function">    <span class="hljs-title">let</span> <span class="hljs-title">p</span> = <span class="hljs-title">Person</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    <span class="hljs-title">p</span>.<span class="hljs-title">fn</span> = &#123;</span><br><span class="hljs-function">        <span class="hljs-title">p</span>.<span class="hljs-title">run</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>解决循环一样的两种办法</p><ul><li><p>weak 实例销毁后，ARC会将弱引用自动置为nil，不会触发属性观察器</p></li><li><p>unowned 实例销毁后，任然存储这实例对象的内存地址，试图访问会引起崩溃</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros"> p.fn = &#123;<br>        [weak p] <span class="hljs-keyword">in</span><br>        p?.<span class="hljs-builtin-name">run</span>()<br>&#125;<br><br>  p.fn = &#123;<br>        [unowned p] <span class="hljs-keyword">in</span><br>        p.<span class="hljs-builtin-name">run</span>()<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="escaping"><a href="#escaping" class="headerlink" title="@escaping"></a>@escaping</h4><ul><li><p>非逃逸闭包，一般都当做函数参数使用,闭包调用发生在函数结束之前，在函数作用域内</p></li><li><p>逃逸闭包，有可能在函数调用之后执行，逃出函数作用域，需要用 @escaping进行修饰</p></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">typealias</span> <span class="hljs-type">Fn</span> = () -&gt; ()<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test1</span><span class="hljs-params">(<span class="hljs-keyword">_</span> fn: Fn)</span></span> &#123;<br>    fn()<br>&#125;<br><br><span class="hljs-comment">//逃逸闭包</span><br><span class="hljs-keyword">var</span> getFn:<span class="hljs-type">Fn?</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test2</span><span class="hljs-params">(<span class="hljs-keyword">_</span> fn: @escaping Fn)</span></span> &#123;<br>    getFn = fn<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>逃逸闭包无法捕获inout参数</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">typealias</span> <span class="hljs-type">Fn</span> = () -&gt;()<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">other</span><span class="hljs-params">(<span class="hljs-keyword">_</span> fn: Fn)</span></span>&#123;fn()&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">other1</span><span class="hljs-params">(<span class="hljs-keyword">_</span> fn: @escaping Fn)</span></span> &#123; fn()&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">(value: <span class="hljs-keyword">inout</span>  Int)</span></span> &#123;<br>    other &#123;<br>        value += <span class="hljs-number">1</span><br>    &#125;<br>    other1 &#123;<br>        value += <span class="hljs-number">1</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>value什么时候用到在逃逸闭包中无法确定</p><h3 id="闭包表达式"><a href="#闭包表达式" class="headerlink" title="闭包表达式"></a>闭包表达式</h3><p>在swift中可以同func 定义一个函数，也可以通过闭包表达式定义一个函数</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">_</span> v1: Int ,<span class="hljs-keyword">_</span> v2: Int)</span></span> -&gt; <span class="hljs-type">Int</span> &#123;<br>    v1 + v2<br>&#125;<br><br><span class="hljs-keyword">var</span> fn = &#123;<br>    (<span class="hljs-keyword">_</span> v1: <span class="hljs-type">Int</span> ,<span class="hljs-keyword">_</span> v2: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span>  <span class="hljs-keyword">in</span><br>    v1 + v2<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="尾随闭包"><a href="#尾随闭包" class="headerlink" title="尾随闭包"></a>尾随闭包</h4><p>如果将一个很长的闭包表达式作为函数的最后一个实参，使用尾随闭包可以增强函数的可读性<br>尾随闭包是一个被书写在函数调用括号外面(后面)的闭包表达式</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php">func test(_  v1: <span class="hljs-keyword">Int</span> ,_ v2: <span class="hljs-keyword">Int</span>, <span class="hljs-function"><span class="hljs-keyword">fn</span>: (<span class="hljs-params"><span class="hljs-keyword">Int</span>,<span class="hljs-keyword">Int</span></span>) -&gt; <span class="hljs-title">Int</span>) </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fn</span>(<span class="hljs-params">v1,v2</span>)</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"><span class="hljs-title">test</span>(<span class="hljs-params"><span class="hljs-number">10</span>, <span class="hljs-number">20</span></span>)</span>&#123;<br>    $<span class="hljs-number">0</span> + $<span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="自动闭包"><a href="#自动闭包" class="headerlink" title="自动闭包"></a>自动闭包</h4><p>使用autoclosure，值会被延迟执行</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getfirstpostin</span><span class="hljs-params">(<span class="hljs-keyword">_</span> v1: Int , <span class="hljs-keyword">_</span> v2: Int)</span></span> -&gt; <span class="hljs-type">Int</span>&#123;<br>    <span class="hljs-keyword">return</span> v1 &gt; <span class="hljs-number">0</span> ? v1 : v2<br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getfirstpostin</span><span class="hljs-params">(<span class="hljs-keyword">_</span> v1: Int, <span class="hljs-keyword">_</span> v2: @autoclosure <span class="hljs-params">()</span></span></span> -&gt; <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int?</span> &#123;<br>    <span class="hljs-keyword">return</span> v1 &gt; <span class="hljs-number">0</span> ? v1 : v2()<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Swift</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>属性</title>
    <link href="/2020/12/03/swift-property/"/>
    <url>/2020/12/03/swift-property/</url>
    
    <content type="html"><![CDATA[<h3 id="属性介绍"><a href="#属性介绍" class="headerlink" title="属性介绍"></a>属性介绍</h3><p>swift跟实例相关的属性大致可以分为两种</p><p><strong>存储属性</strong></p><ul><li><p>类似于成员变量的概念</p></li><li><p>可以存储在实例对象内存中</p></li><li><p>结构体、类可以定义存储属性 枚举不可以</p></li></ul><p><strong>计算属性</strong></p><ul><li><p>本质就是方法</p></li><li><p>不占用实例内存</p></li><li><p>结构体、类、枚举都可以定义计算属性</p></li></ul><h4 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h4><ul><li><p>可以在初始化器里为存储属性设置一个初始化值</p></li><li><p>可以分配一个默认的属性值作为属性定义的一部分</p></li></ul><h4 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h4><p>set 传入的新值默认交newValue,也可以自定义</p><p>定义计算属性只能用var,因为计算属性随时都有可能发生变化</p><p>只读计算属性只有 get,没有set</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs haxe">struct Circle &#123;<br>    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">Double</span><br><span class="hljs-type">    var dirameter</span>: Double &#123;<br>        <span class="hljs-keyword">set</span> (<span class="hljs-keyword">new</span><span class="hljs-type">Dirameter</span>)&#123;<br>            radius = <span class="hljs-keyword">new</span><span class="hljs-type">Dirameter</span> / <span class="hljs-number">2</span><br>        &#125;<br>        <br>        <span class="hljs-keyword">get</span> &#123;<br>            <span class="hljs-keyword">return</span> radius * <span class="hljs-number">2</span><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>枚举rawValue本质: 只读计算属性</strong></p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">TestEunm</span> : <span class="hljs-title">Int</span> &#123;</span><br>    <span class="hljs-keyword">case</span> test1 = <span class="hljs-number">1</span>, test2 = <span class="hljs-number">2</span>, test3 = <span class="hljs-number">3</span><br>    <br>    var <span class="hljs-symbol">rawValue:</span> Int &#123;<br>        switch <span class="hljs-keyword">self</span> &#123;<br>        <span class="hljs-keyword">case</span> .<span class="hljs-symbol">test1:</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">case</span> .<span class="hljs-symbol">test2:</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>        <span class="hljs-keyword">case</span> .<span class="hljs-symbol">test3:</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">12</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><br>print(TestEunm.test3.rawValue)/<span class="hljs-regexp">/12</span><br></code></pre></td></tr></table></figure><h3 id="延迟存储属性"><a href="#延迟存储属性" class="headerlink" title="延迟存储属性"></a>延迟存储属性</h3><p>可以使lazy定义一个存储属性，当第一次使用到时才会进行初始化</p><ul><li><p>lazy属性必须是var,不能是le(let 必须在实例初始化化完成之前就拥有值)</p></li><li><p>如果多条线程同时第一次访问lazy属性 (无法保证初始化一次)</p></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>&#123;<br>    <span class="hljs-keyword">init</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;car init&quot;</span>)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;car runing&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-comment">//延迟属性</span><br>    <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> car = <span class="hljs-type">Car</span>()<br>    <span class="hljs-keyword">init</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;person init&quot;</span>)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goout</span><span class="hljs-params">()</span></span> &#123;<br>        car.run()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;car go out&quot;</span>)<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="属性观察器"><a href="#属性观察器" class="headerlink" title="属性观察器"></a>属性观察器</h3><p>可以给为非lazy 存储属性设置属性观察器</p><ul><li><p>willSet会传递新值，默认叫newvalue</p></li><li><p>oldValue 传递旧值，默认交oldvalue</p></li><li><p>在初始化器中设置初始值不会触发属性观察器</p></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Circle</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">Double</span> &#123;<br>        <span class="hljs-keyword">willSet</span> &#123;<br>            <span class="hljs-built_in">print</span>(newValue)<br>        &#125;<br>        <span class="hljs-keyword">didSet</span> &#123;<br>            <span class="hljs-built_in">print</span>(oldValue)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">init</span>() &#123;<br>        <span class="hljs-keyword">self</span>.radius = <span class="hljs-number">10</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Circle init&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h3><p>只能通过类访问,可以通过static定义类型属性,如果是类可以通过class关键字定义,大致可以分为两种</p><ul><li><p>存储型类型属性: 整个程序运行过程中只有一份内存</p></li><li><p>计算型类型属性</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">struct Preson &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> name: <span class="hljs-built_in">String</span> = <span class="hljs-string">&quot;zhangs&quot;</span><br>    <span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params"></span>)</span> &#123;<br>        Preson.name = <span class="hljs-string">&quot;lisi&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>存储类型属性注意细节</p><ul><li><p>不同与存储属性，类型属性必须设定初始值</p></li><li><p>存储类型属性默认是lazy,会在第一次调用时初始化</p></li><li><p>就算被多个线程同时访问，保证也是初始化一次</p></li></ul><p>swift中单利写法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileMager</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> share = FileMager()<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Swift</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结构体和类</title>
    <link href="/2020/12/02/swift-structclass/"/>
    <url>/2020/12/02/swift-structclass/</url>
    
    <content type="html"><![CDATA[<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>在swift 标准库中，绝大多数的公开类型都是结构体，枚举和类只占一小部分</p><ul><li><p>比如 Bool,Int,String,Arrray,Dictionary等常见类型都是结构体</p></li><li><p>所有结构体都有编译器自动生成的初始器(initialer,初始化器，构造器，构造方法)</p></li></ul><p><strong>初始化器宗旨是：保证每个成员都有值</strong></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">struct Point &#123;<br>    var x: Int<br>    var y: Int<br>    <br>&#125;<br><br>var p1 = Point(x: 10, y: <span class="hljs-number">10</span>)<br>var p2 = Point(x:<span class="hljs-number">10</span>)//<span class="hljs-literal">Missing</span> argument <span class="hljs-keyword">for</span> parameter <span class="hljs-string">&#x27;y&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">call</span><br>var p3 = Point(y:<span class="hljs-number">20</span>)//<span class="hljs-literal">Missing</span> argument <span class="hljs-keyword">for</span> parameter <span class="hljs-string">&#x27;x&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">call</span><br></code></pre></td></tr></table></figure><h4 id="自定义初始化器"><a href="#自定义初始化器" class="headerlink" title="自定义初始化器"></a>自定义初始化器</h4><p>一旦定义了自定义初始化器，编译器就不会帮它自动生成</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs gml">struct Point &#123;<br>    <span class="hljs-keyword">var</span> <span class="hljs-symbol">x</span>: Int = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">var</span> <span class="hljs-symbol">y</span>: Int = <span class="hljs-number">0</span><br>    <br>    init(<span class="hljs-symbol">x</span>: Int, <span class="hljs-symbol">y</span>: Int) &#123;<br>        <span class="hljs-literal">self</span>.<span class="hljs-symbol">x</span> = <span class="hljs-symbol">x</span><br>        <span class="hljs-literal">self</span>.<span class="hljs-symbol">y</span> = <span class="hljs-symbol">y</span><br>    &#125;<br>    <br>    <br>&#125;<br><br><span class="hljs-keyword">var</span> p1 = Point(<span class="hljs-symbol">x</span>: <span class="hljs-number">10</span>, <span class="hljs-symbol">y</span>: <span class="hljs-number">10</span>)<br><span class="hljs-keyword">var</span> p2 = Point(<span class="hljs-symbol">x</span>:<span class="hljs-number">10</span>)<span class="hljs-comment">//Missing argument for parameter &#x27;y&#x27; in call</span><br><span class="hljs-keyword">var</span> p3 = Point(<span class="hljs-symbol">y</span>:<span class="hljs-number">20</span>)<span class="hljs-comment">//Missing argument for parameter &#x27;x&#x27; in call</span><br></code></pre></td></tr></table></figure><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类和结构体类似，但编译其没有帮它自动生成可以传值的初始化器<br><img src="/img/ios/swift/class/classinit.png"></p><h4 id="类的初始化器"><a href="#类的初始化器" class="headerlink" title="类的初始化器"></a>类的初始化器</h4><p>如果类的所有成员都在定义的时候有初始化值，编译器会自动生成无参的初始化器</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<span class="hljs-comment">//Class &#x27;Point&#x27; has no initializers</span><br>    <span class="hljs-keyword">var</span> x: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">var</span> y: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-keyword">var</span> p1 = Point()<br></code></pre></td></tr></table></figure><h3 id="类和结构体的本质"><a href="#类和结构体的本质" class="headerlink" title="类和结构体的本质"></a>类和结构体的本质</h3><p>结构体内存在哪，取决于你在哪创建它</p><p>函数里在栈 外部在全局 在类里在堆空间</p><p>类无论在哪定义 都是在堆空间<br><img src="/img/ios/swift/class/benzi.png"></p><h4 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h4><p>值类型赋给var let 或者函数传参是将所有的内容拷贝一份<br>，类似于产生一个新的副本，属于深拷贝</p><h4 id="值类型赋值操作"><a href="#值类型赋值操作" class="headerlink" title="值类型赋值操作"></a>值类型赋值操作</h4><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gml">struct Point &#123;<br>    <span class="hljs-keyword">var</span> <span class="hljs-symbol">x</span>: Int<br>    <span class="hljs-keyword">var</span> <span class="hljs-symbol">y</span>: Int<br>&#125;<br><br><span class="hljs-keyword">var</span> p1 = Point(<span class="hljs-symbol">x</span>: <span class="hljs-number">10</span>, <span class="hljs-symbol">y</span>: <span class="hljs-number">20</span>)<br>p1 = Point(<span class="hljs-symbol">x</span>: <span class="hljs-number">11</span>, <span class="hljs-symbol">y</span>: <span class="hljs-number">22</span>)<br></code></pre></td></tr></table></figure><p>内存地址没有发生变化，内存数据发生改变</p><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>引用类型赋值给let,var 或者函数传参只是将内存地址拷贝一份<br>属于浅拷贝</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs maxima">class Size &#123;<br>    <span class="hljs-built_in">var</span> <span class="hljs-built_in">height</span>: Int<br>    <span class="hljs-built_in">var</span> <span class="hljs-built_in">width</span>: Int<br>    init(<span class="hljs-built_in">height</span>: Int, <span class="hljs-built_in">width</span>: Int) &#123;<br>        self.<span class="hljs-built_in">height</span> = <span class="hljs-built_in">height</span><br>        self.<span class="hljs-built_in">width</span> = <span class="hljs-built_in">width</span><br>    &#125;<br>&#125;<br><br>func test() &#123;<br>    <span class="hljs-built_in">var</span> s1 = Size(<span class="hljs-built_in">height</span>: <span class="hljs-number">10</span>, <span class="hljs-built_in">width</span>: <span class="hljs-number">20</span>)<br>    <span class="hljs-built_in">var</span> s2  = s1<br>&#125;<br><br></code></pre></td></tr></table></figure><p>s1 和 s2 指向同一块内存空间</p><h4 id="引用类型赋值操作"><a href="#引用类型赋值操作" class="headerlink" title="引用类型赋值操作"></a>引用类型赋值操作</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Size</span> &#123;</span><br>    var <span class="hljs-built_in">height</span>: Int<br>    var <span class="hljs-built_in">width</span>: Int<br>    init(<span class="hljs-built_in">height</span>: Int, <span class="hljs-built_in">width</span>: Int) &#123;<br>        self.<span class="hljs-built_in">height</span> = <span class="hljs-built_in">height</span><br>        self.<span class="hljs-built_in">width</span> = <span class="hljs-built_in">width</span><br>    &#125;<br>&#125;<br><br>func test() &#123;<br>    var s1 = Size(<span class="hljs-built_in">height</span>: <span class="hljs-number">10</span>, <span class="hljs-built_in">width</span>: <span class="hljs-number">20</span>)<br>    s1 = Size(<span class="hljs-built_in">height</span>: <span class="hljs-number">11</span>, <span class="hljs-built_in">width</span>: <span class="hljs-number">22</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>内存地址相同，内存数据指向一块新的内存</p><h4 id="类，枚举，结构体都可以定义方法"><a href="#类，枚举，结构体都可以定义方法" class="headerlink" title="类，枚举，结构体都可以定义方法"></a>类，枚举，结构体都可以定义方法</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Size</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> height = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">var</span> width = <span class="hljs-number">20</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;show&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> s1 = <span class="hljs-type">Size</span>()<br>s1.show()<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span>&#123;<br>    <span class="hljs-keyword">var</span> x = <span class="hljs-number">2</span><br>    <span class="hljs-keyword">var</span> y = <span class="hljs-number">2</span><br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;point show&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> p1 = <span class="hljs-type">Point</span>()<br>p1.show()<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Dirtion</span> </span>&#123;<br>    <span class="hljs-keyword">case</span> north, west<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;dirtion show&quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> dr = <span class="hljs-type">Dirtion</span>.north<br><br>dr.show()<br><br></code></pre></td></tr></table></figure><ul><li><p>方法不占用对象内存</p></li><li><p>方法本质就是函数</p></li><li><p>函数，方法都存放在代码端</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Swift</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可选项</title>
    <link href="/2020/12/02/swift-options/"/>
    <url>/2020/12/02/swift-options/</url>
    
    <content type="html"><![CDATA[<h3 id="可选项"><a href="#可选项" class="headerlink" title="可选项"></a>可选项</h3><ul><li><p>可选项，一般也叫可选类型，它允许将值设为nil</p></li><li><p>在类型后面加？来定义可选项</p></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> name: <span class="hljs-type">String?</span> = <span class="hljs-string">&quot;zhangsan&quot;</span><br>name = <span class="hljs-literal">nil</span><br><br><span class="hljs-keyword">var</span> age: <span class="hljs-type">Int?</span> <span class="hljs-comment">// 默认为nil</span><br>age = <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><h3 id="强制解包"><a href="#强制解包" class="headerlink" title="强制解包"></a>强制解包</h3><p>可选项是对其他类型一层包装，可以看做一个盒子</p><ul><li><p>如果是nil,就是空盒子</p></li><li><p>非nil ,那么盒子里是被包装的类型数据</p></li></ul><p>如果取出数据采用强制解包，值如果是nil的情况下，会产生运行是错误程序崩溃</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span>? <span class="hljs-comment">// 默认为nil</span><br>age!<br></code></pre></td></tr></table></figure><h3 id="可选项绑定"><a href="#可选项绑定" class="headerlink" title="可选项绑定"></a>可选项绑定</h3><p><strong>可以使用可选项绑定来判断可选项有没有值</strong></p><p>把值赋给一个临时变量或者常量，并返回true或false </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> age: <span class="hljs-type">Int?</span> <span class="hljs-comment">// 默认为nil</span><br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> age1 = age &#123;<br>    <span class="hljs-built_in">print</span>(age1)<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;值为nil 解包失败&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="where-循环中使用可选项绑定"><a href="#where-循环中使用可选项绑定" class="headerlink" title="where 循环中使用可选项绑定"></a>where 循环中使用可选项绑定</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">//遇到非数字停止</span><br><span class="hljs-built_in">var</span> strs = [<span class="hljs-string">&quot;20&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>,<span class="hljs-string">&quot;test2&quot;</span>,<span class="hljs-string">&quot;30&quot;</span>,<span class="hljs-string">&quot;10&quot;</span>]<br><br><span class="hljs-built_in">var</span> <span class="hljs-keyword">index</span> = <span class="hljs-number">0</span><br><span class="hljs-built_in">var</span> <span class="hljs-keyword">sum</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> let num = Int(strs[<span class="hljs-keyword">index</span>]), num &gt; <span class="hljs-number">0</span>&#123;<br>    <span class="hljs-keyword">sum</span> += num<br>    <span class="hljs-keyword">index</span> += <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-keyword">print</span>(<span class="hljs-keyword">sum</span>)<span class="hljs-comment">// 29</span><br><br></code></pre></td></tr></table></figure><h3 id="空合并运算符"><a href="#空合并运算符" class="headerlink" title="空合并运算符"></a>空合并运算符</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> ?? &lt;T&gt;<span class="hljs-params">(<span class="hljs-keyword">optional</span>: T?, defaultValue: @autoclosure <span class="hljs-params">()</span></span></span> <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">T</span>) <span class="hljs-keyword">rethrows</span> -&gt; <span class="hljs-type">T</span><br></code></pre></td></tr></table></figure><ul><li><p>a 是可选项</p></li><li><p>b 是可选项或者不是</p></li><li><p>a,b存储类型必须相同</p></li></ul><ol><li>如果 a不为nil,返回a</li><li>如果 a为nil ,返回b</li><li>如果b不是选项，a自动解包</li></ol><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">var</span> <span class="hljs-symbol">a:</span> <span class="hljs-built_in">Int</span>? = <span class="hljs-number">10</span><br><span class="hljs-built_in">var</span> <span class="hljs-symbol">b:</span> <span class="hljs-built_in">Int</span> = <span class="hljs-number">20</span><br><br>a ?? b<br></code></pre></td></tr></table></figure><h3 id="gurad语句"><a href="#gurad语句" class="headerlink" title="gurad语句"></a>gurad语句</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">guard</span> 条件 <span class="hljs-keyword">else</span> &#123;<br>   退出<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>gurad 条件 为false 执行大括号内</p></li><li><p>gurad 条件 为true 跳过gurad语句</p></li><li><p>gurad 特别适合提前退出</p></li></ul><p><strong>guard和if else对比</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">login</span> <span class="hljs-params">(<span class="hljs-keyword">_</span> info:[String: String])</span></span> &#123;<br>    <span class="hljs-keyword">let</span> userName: <span class="hljs-type">String</span><br><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> tmp = info[<span class="hljs-string">&quot;userName&quot;</span>] &#123;<br>        userName = tmp<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;请输入用户名&quot;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-keyword">let</span> phone: <span class="hljs-type">String</span><br><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> tmp1 = info[<span class="hljs-string">&quot;phone&quot;</span>] &#123;<br>        phone = tmp1<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;请输入手机号&quot;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;用户名\(userName)&quot;</span>,<span class="hljs-string">&quot;手机号\(phone )&quot;</span>)<br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">login</span> <span class="hljs-params">(<span class="hljs-keyword">_</span> info:[String: String])</span></span> &#123;<br>    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> userName = info[<span class="hljs-string">&quot;userName&quot;</span>] <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;请输入用户名&quot;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> phone = info[<span class="hljs-string">&quot;phone&quot;</span>] <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;请输入手机号&quot;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;用户名\(userName)&quot;</span>,<span class="hljs-string">&quot;手机号\(phone )&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>gurad可选项绑定变量或常量也能在外层作用域使用</strong></p>]]></content>
    
    
    <categories>
      
      <category>Swift</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>枚举</title>
    <link href="/2020/12/02/swift-enum/"/>
    <url>/2020/12/02/swift-enum/</url>
    
    <content type="html"><![CDATA[<h3 id="枚举基本用法"><a href="#枚举基本用法" class="headerlink" title="枚举基本用法"></a>枚举基本用法</h3><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sqf">enum <span class="hljs-built_in">Direction</span> &#123;<br>    <span class="hljs-keyword">case</span> north,south,<span class="hljs-literal">east</span>,<span class="hljs-literal">west</span><br>&#125;<br><br>var dir = <span class="hljs-built_in">Direction</span>.<span class="hljs-literal">west</span><br>dir = .north<br><br><span class="hljs-keyword">switch</span> dir &#123;<br><span class="hljs-keyword">case</span> .north:<br>    print(<span class="hljs-string">&quot;north&quot;</span>)<br><span class="hljs-keyword">case</span> .<span class="hljs-literal">east</span>:<br>    print(<span class="hljs-string">&quot;east&quot;</span>)<br><span class="hljs-keyword">case</span> .south:<br>    print(<span class="hljs-string">&quot;south&quot;</span>)<br><span class="hljs-keyword">case</span> .<span class="hljs-literal">west</span>:<br>    print(<span class="hljs-string">&quot;west&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="关联值"><a href="#关联值" class="headerlink" title="关联值"></a>关联值</h3><p>将枚举成员值跟其他类型值关联储存在一起</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">enum</span> Password &#123;<br>   <span class="hljs-keyword">case</span> <span class="hljs-built_in">number</span>(<span class="hljs-built_in">Int</span> ,<span class="hljs-built_in">Int</span>,<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">Int</span>)<br>   <span class="hljs-keyword">case</span> getsture(<span class="hljs-built_in">String</span>)<br>&#125;<br>var pwd = Password.<span class="hljs-built_in">number</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br>pwd = .getsture(<span class="hljs-string">&quot;1345&quot;</span>)<br><br><span class="hljs-keyword">switch</span> pwd &#123;<br><span class="hljs-keyword">case</span> let .<span class="hljs-built_in">number</span>(a1 , a2, a3, a4):<br>    print(a1,a2,a3,a4)<br><span class="hljs-keyword">case</span> let .getsture(str):<br>    print(str)<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="原始值，隐式原始值"><a href="#原始值，隐式原始值" class="headerlink" title="原始值，隐式原始值"></a>原始值，隐式原始值</h3><ul><li><p>枚举成员可以使用相同类型的默认值预先对应这个默认值，叫做原始值</p></li><li><p>原始值不占用枚举变量内存</p></li><li><p>如果枚举的原始值类型是 Int,String会自动分配原始值</p></li></ul><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sqf">enum <span class="hljs-built_in">Direction</span>: String &#123;<br>    <span class="hljs-keyword">case</span> north,south,<span class="hljs-literal">east</span>,<span class="hljs-literal">west</span><br>&#125;<br><br>print(<span class="hljs-built_in">Direction</span>.north.rawValue)<span class="hljs-comment">//&quot;north&quot;</span><br>print(<span class="hljs-built_in">Direction</span>.<span class="hljs-literal">west</span>.rawValue)<span class="hljs-comment">//&quot;west&quot;</span><br><br><br><br>enum <span class="hljs-built_in">Direction</span>: Int &#123;<br>    <span class="hljs-keyword">case</span> north,south,<span class="hljs-literal">east</span>,<span class="hljs-literal">west</span><br>&#125;<br>print(<span class="hljs-built_in">Direction</span>.north.rawValue)<span class="hljs-comment">// 0</span><br>print(<span class="hljs-built_in">Direction</span>.<span class="hljs-literal">west</span>.rawValue)<span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><h3 id="递归枚举"><a href="#递归枚举" class="headerlink" title="递归枚举"></a>递归枚举</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs crystal">indirect <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Airpext</span> &#123;</span><br>    <span class="hljs-keyword">case</span> number(Int)<br>    <span class="hljs-keyword">case</span> sum(Airpext,Airpext)<br>    <span class="hljs-keyword">case</span> diference(Airpext,Airpext)<br>&#125;<br><br><br>let five = Airpext.number(<span class="hljs-number">5</span>)<br>let four = Airpext.number(<span class="hljs-number">4</span>)<br>let sum = Airpext.sum(five, four)<br></code></pre></td></tr></table></figure><h3 id="关联值内存"><a href="#关联值内存" class="headerlink" title="关联值内存"></a>关联值内存</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Password</span> &#123;</span><br>   <span class="hljs-keyword">case</span> number(Int ,Int,Int, Int)<br>   <span class="hljs-keyword">case</span> other<br>&#125;<br><br>MemoryLayout&lt;Password&gt;.stride /<span class="hljs-regexp">/ 40 分配占用空间大小</span><br><span class="hljs-regexp">MemoryLayout&lt;Password&gt;.size/</span><span class="hljs-regexp">/ 33/</span>实际占用<br>MemoryLayout&lt;Password&gt;.alignment/<span class="hljs-regexp">/ 8/</span><span class="hljs-regexp">/对齐</span><br><span class="hljs-regexp"></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Swift</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数</title>
    <link href="/2020/12/02/swift-func/"/>
    <url>/2020/12/02/swift-func/</url>
    
    <content type="html"><![CDATA[<h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h3><p>形参是let类型， 也只是是let</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pi</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Double</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3.14</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(v1: Int ,v2: Int)</span></span> -&gt; <span class="hljs-type">Int</span> &#123;<br>     v1 + v2<br>&#125;<br>sum(v1: <span class="hljs-number">10</span>, v2: <span class="hljs-number">20</span>) <span class="hljs-comment">// 30</span><br><br><span class="hljs-comment">//无返回值 无参</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="返回元祖，实现多返回值"><a href="#返回元祖，实现多返回值" class="headerlink" title="返回元祖，实现多返回值"></a>返回元祖，实现多返回值</h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lasso">func calculate(v1: Int, v2: Int) -&gt; (<span class="hljs-keyword">sum</span>: Int,differnce: Int,<span class="hljs-keyword">average</span>: Int) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">sum</span> = v1 + v2<br>    <span class="hljs-keyword">return</span>(<span class="hljs-keyword">sum</span>,v1 - v2, <span class="hljs-keyword">sum</span> &gt;&gt; <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-keyword">let</span> result = calculate(v1: <span class="hljs-number">10</span>, v2: <span class="hljs-number">20</span>)<br>result.<span class="hljs-keyword">sum</span> <span class="hljs-comment">//30</span><br>result.differnce<span class="hljs-comment">// -10</span><br>result.<span class="hljs-keyword">average</span><span class="hljs-comment">// 15</span><br></code></pre></td></tr></table></figure><h3 id="参数标签"><a href="#参数标签" class="headerlink" title="参数标签"></a>参数标签</h3><p>下划线省略参数标签</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">_</span> v1: Int, <span class="hljs-keyword">_</span> v2: Int)</span></span> &#123;<br>    v1 + v2<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h3><p>调用函数可不传默认值标签</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">func</span> <span class="hljs-selector-tag">test</span>(<span class="hljs-attribute">name</span>: String = <span class="hljs-string">&quot;zhangsan&quot;</span> ,<span class="hljs-attribute">age</span>: Int) &#123;<br>    <span class="hljs-selector-tag">print</span>(name,age)<br>&#125;<br><span class="hljs-selector-tag">test</span>(<span class="hljs-attribute">age</span>: <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><ul><li><p>一个函数最多只能有一个可变参数</p></li><li><p>紧跟在可变参数后面的参数不能使用省略标签</p></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">_</span> numbers: Int... ,name: String ,<span class="hljs-keyword">_</span> age: Int)</span></span> &#123;<br>    <span class="hljs-built_in">print</span>(name,age)<br>&#125;<br>test(<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">20</span>, name:<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-number">40</span>)<br></code></pre></td></tr></table></figure><h3 id="输入输出参数（IN-OUT）"><a href="#输入输出参数（IN-OUT）" class="headerlink" title="输入输出参数（IN-OUT）"></a>输入输出参数（IN-OUT）</h3><ul><li>可以使用inout 定义输入输出参数，可以在函数内部修改外部实参值</li><li>可变参数不能使用 inout</li><li>inout 参数不能有默认值</li><li>inout 参数只能传入可以被多次赋值的</li><li>inout 本质是引用传递</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">func swapvalue(_ v1: <span class="hljs-keyword">inout</span> Int ,_ v2: <span class="hljs-keyword">inout</span> Int) &#123;<br>    let temp = v1<br>    v1 = v2<br>    v2 = temp<br>&#125;<br>var a1 = <span class="hljs-number">10</span><br>var a2 = <span class="hljs-number">20</span><br>swapvalue(&amp;a1, &amp;a2)<br></code></pre></td></tr></table></figure><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><ul><li><p>函数名相同</p></li><li><p>参数标签不用，个数不同，类型不同</p></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">(v1:Int,v2: Int)</span></span> -&gt; <span class="hljs-type">Int</span> &#123;<br>    v1 + v2<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">(a1: Int, a2: Int, a3: Int)</span></span> -&gt; <span class="hljs-type">Int</span> &#123;<br>    a1 + a2 + a3<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">(v1: Int , v2: Double)</span></span> -&gt; <span class="hljs-type">Double</span> &#123;<br>    <span class="hljs-type">Double</span>(v1) + v2<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>如果开启编译器优化，编译器会将某些函数变成内联函数<br>那些函数不会被内联？</p><ul><li><p>函数体比较长</p></li><li><p>包含递归调用</p></li><li><p>包含动态派发</p></li></ul><p>永远不会内联</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-symbol">@inline</span>(never ) <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> &#123;</span><br>    print(<span class="hljs-string">&quot;test&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>函数体很长也会内联</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-symbol">@inline</span>(__always ) <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> &#123;</span><br>    print(<span class="hljs-string">&quot;test&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="typealias"><a href="#typealias" class="headerlink" title="typealias"></a>typealias</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">typealias</span> <span class="hljs-type">IntFN</span> = (<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span> <span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">IntFN</span> &#123;<br>    sum<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span> <span class="hljs-params">(<span class="hljs-keyword">_</span> a: Int, <span class="hljs-keyword">_</span> b: Int)</span></span> -&gt; <span class="hljs-type">Int</span> &#123;<br>    a + b<br>&#125;<br><span class="hljs-keyword">let</span> fn =  test()<br>fn(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>)<span class="hljs-comment">//30</span><br></code></pre></td></tr></table></figure><h3 id="函数嵌套"><a href="#函数嵌套" class="headerlink" title="函数嵌套"></a>函数嵌套</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fowrard</span><span class="hljs-params">(<span class="hljs-keyword">_</span> forward: Bool)</span></span>  -&gt; (<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">next</span> <span class="hljs-params">(<span class="hljs-keyword">_</span> input: Int)</span></span> -&gt; <span class="hljs-type">Int</span> &#123;<br>      input + <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">previous</span> <span class="hljs-params">(<span class="hljs-keyword">_</span> input: Int)</span></span> -&gt; <span class="hljs-type">Int</span> &#123;<br>        input - <span class="hljs-number">1</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> forward ? next : previous<br>&#125;<br>fowrard(<span class="hljs-literal">true</span>)(<span class="hljs-number">3</span>) <span class="hljs-comment">//4</span><br>fowrard(<span class="hljs-literal">false</span>)(<span class="hljs-number">3</span>)<span class="hljs-comment">//2</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Swift</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>流程控制</title>
    <link href="/2020/12/02/swift-ProcessControl/"/>
    <url>/2020/12/02/swift-ProcessControl/</url>
    
    <content type="html"><![CDATA[<h3 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h3><p>swift 中去掉了非0即真的概念 if 条件后面只能是bool类型<br>下面代码编译报错</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">let age = <span class="hljs-number">1</span><br><br><span class="hljs-keyword">if</span> age &#123; <br>    print(&quot;123&quot;)<br>&#125;<br>//<span class="hljs-keyword">Type</span> <span class="hljs-string">&#x27;Int&#x27;</span> cannot be used <span class="hljs-keyword">as</span> a <span class="hljs-type">boolean</span>; test <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;!= 0&#x27;</span> <span class="hljs-keyword">instead</span><br><br></code></pre></td></tr></table></figure><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> <span class="hljs-built_in">num</span> = <span class="hljs-number">5</span><br><span class="hljs-keyword">while</span> <span class="hljs-built_in">num</span> &gt; <span class="hljs-number">0</span> &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">num</span>) <span class="hljs-comment">//打印五次</span><br>    <span class="hljs-built_in">num</span> -= <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-keyword">var</span> <span class="hljs-built_in">num</span> = <span class="hljs-number">-1</span><br><br>repeat&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">num</span>) <span class="hljs-comment">//打印一次</span><br>&#125; <span class="hljs-keyword">while</span> <span class="hljs-built_in">num</span> &gt; <span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><ul><li><p>repeat-while 相当于do-while</p></li><li><p>swift去掉了 自减– 和 自增++</p></li></ul><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><h4 id="区间运算符"><a href="#区间运算符" class="headerlink" title="区间运算符"></a>区间运算符</h4><p>闭区间运算符 a…b   a&lt;= 取值 &lt;= b</p><figure class="highlight golo"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs golo"><span class="hljs-keyword">let</span> names = [<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-string">&quot;lisi&quot;</span>,<span class="hljs-string">&quot;wangwu&quot;</span>,<span class="hljs-string">&quot;zhaoliu&quot;</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.<span class="hljs-number">.3</span> &#123;<br>  <span class="hljs-keyword">print</span>(names[i])<br>&#125;<br><br>// <span class="hljs-keyword">for</span> 默认是<span class="hljs-keyword">let</span> 如果要使用加<span class="hljs-keyword">var</span> <br><br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-keyword">for</span> <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>...<span class="hljs-number">3</span> &#123;<br>    <span class="hljs-selector-tag">i</span> += <span class="hljs-number">1</span><br>    print(i)<span class="hljs-comment">// 1234</span><br>&#125;<br></code></pre></td></tr></table></figure><p>半开区间运算符   a..&lt;b   a&lt;= 取值 &lt; b</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span> names = [<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-string">&quot;lisi&quot;</span>,<span class="hljs-string">&quot;wangwu&quot;</span>,<span class="hljs-string">&quot;zhaoliu&quot;</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> 0..&lt;3 &#123;<br>  <span class="hljs-built_in">print</span>(names[i])<br>&#125;<br><br></code></pre></td></tr></table></figure><p>单侧区间： 让区间方向尽可能的远</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sqf">let names = [<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-string">&quot;lisi&quot;</span>,<span class="hljs-string">&quot;wangwu&quot;</span>,<span class="hljs-string">&quot;zhaoliu&quot;</span>]<br><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">name</span> <span class="hljs-built_in">in</span> names[<span class="hljs-number">2</span>...] &#123;<br>    print(<span class="hljs-string">&quot;11&quot;</span>,<span class="hljs-built_in">name</span>)<span class="hljs-comment">//11 wangwu  11 zhaoliu</span><br>&#125;<br><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">name</span> <span class="hljs-built_in">in</span> names[...<span class="hljs-number">2</span>] &#123;<br>    print(<span class="hljs-string">&quot;22&quot;</span>,<span class="hljs-built_in">name</span>)<span class="hljs-comment">//22 zhangsan 22 lisi 22 wangwu</span><br>&#125;<br><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">name</span> <span class="hljs-built_in">in</span> names[..&lt;<span class="hljs-number">2</span>] &#123;<br>    print(<span class="hljs-string">&quot;33&quot;</span>,<span class="hljs-built_in">name</span>) <span class="hljs-comment">//33 zhangsan 33 lisi</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>去掉了 case default{},不写break 不会贯穿</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">var</span> number = <span class="hljs-number">1</span><br><br><span class="hljs-keyword">switch</span> number &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;1&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>    <span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;2&quot;</span>)<br><span class="hljs-literal">default</span>:<br>    <span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;other&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用fallthrough可以实现贯穿</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> number = <span class="hljs-number">1</span><br><br><span class="hljs-keyword">switch</span> number &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;1&quot;</span>)<br>    <span class="hljs-keyword">fallthrough</span><br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;2&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;other&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>switch可以比配元祖</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart">let <span class="hljs-built_in">num</span> = (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br><span class="hljs-keyword">switch</span> <span class="hljs-built_in">num</span> &#123;<br><span class="hljs-keyword">case</span> (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;no&quot;</span>)<br><span class="hljs-keyword">case</span>(<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;no&quot;</span>)<br><span class="hljs-keyword">case</span>(<span class="hljs-number">-2</span>,<span class="hljs-number">2</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;yes&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>    <span class="hljs-keyword">break</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>可以值绑定，可以使用where条件过滤</strong></p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gml">let point = (<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>)<br><span class="hljs-keyword">switch</span> point &#123;<br><span class="hljs-keyword">case</span> let (<span class="hljs-symbol">x</span>,<span class="hljs-symbol">y</span>)where <span class="hljs-symbol">x</span> == <span class="hljs-symbol">y</span> :<br>    print(<span class="hljs-string">&quot;no&quot;</span>)<br><span class="hljs-keyword">case</span> let (<span class="hljs-symbol">x</span>,<span class="hljs-symbol">y</span>)where <span class="hljs-symbol">x</span> == -<span class="hljs-symbol">y</span> :<br>    print(<span class="hljs-string">&quot;yes&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>    <span class="hljs-keyword">break</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Swift</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础语法</title>
    <link href="/2020/12/02/swift-Basicgrammar/"/>
    <url>/2020/12/02/swift-Basicgrammar/</url>
    
    <content type="html"><![CDATA[<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ul><li><p>只能赋值一次</p></li><li><p>它的值不要求在编译时期决定，但在使用之前只能赋值一次</p></li><li><p>常量、变量在未初始化之前都不能使用</p></li></ul><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">let</span> age = <span class="hljs-number">10</span><br><br><span class="hljs-keyword">let</span> age2: Int = <span class="hljs-number">20</span><br>age2 = <span class="hljs-number">2</span> //Cannot assign <span class="hljs-keyword">to</span> value: <span class="hljs-string">&#x27;age2&#x27;</span> <span class="hljs-keyword">is</span> a <span class="hljs-string">&#x27;let&#x27;</span> constant<br><br></code></pre></td></tr></table></figure><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><ul><li><p>标识符（常量名、变量名、函数名）几乎可以使用任何字符</p></li><li><p>标识符不能已数字开头，不能已空白字符、制表符、箭头字符等特殊字符</p></li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">let</span> 🐂 = <span class="hljs-number">10</span><br><span class="hljs-attribute">let</span> 👽 = <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-keyword">let</span> <span class="hljs-attr">bool</span> = <span class="hljs-literal">true</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">str</span> = <span class="hljs-string">&quot;test&quot;</span><br><br><span class="hljs-keyword">let</span> char: <span class="hljs-attr">Character</span> = <span class="hljs-string">&quot;s&quot;</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">int</span> = <span class="hljs-number">10</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">double</span> = <span class="hljs-number">10.0</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">arr</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">dic</span> = [<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">19</span>, <span class="hljs-string">&quot;height&quot;</span>:<span class="hljs-number">20</span>]<br></code></pre></td></tr></table></figure><h3 id="元祖"><a href="#元祖" class="headerlink" title="元祖"></a>元祖</h3><p>元组中的值可以是任何类型，并且不需要是相同类型</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-keyword">let</span> <span class="hljs-keyword">tuple</span> = (<span class="hljs-number">20</span>,<span class="hljs-string">&quot;test&quot;</span>)<br><br><span class="hljs-keyword">let</span> (age,str) = <span class="hljs-keyword">tuple</span><br></code></pre></td></tr></table></figure><h3 id="常见数据类型"><a href="#常见数据类型" class="headerlink" title="常见数据类型"></a>常见数据类型</h3><p><strong>swift大致可以分为两种，一种是值类型，一种是引用类型</strong><br>如图</p><p><img src="/img/ios/swift/basic/type.png"></p>]]></content>
    
    
    <categories>
      
      <category>Swift</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>访问控制</title>
    <link href="/2020/12/02/swift-AccessControl/"/>
    <url>/2020/12/02/swift-AccessControl/</url>
    
    <content type="html"><![CDATA[<h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><p>swift提供了5个不同的访问权限</p><ul><li><p>open: 公开权限, 最高的权限, 可以被其他模块访问, 继承及复写</p></li><li><p>public: 允许在定义实体的模块，其他模块访问，不允许被其他模块继承重写</p></li><li><p>internal: 只允许在定义的实体模块中访问，不允许在其他模块访问</p></li><li><p>fileprivate: 只允许在定义的实体源文件中访问</p></li><li><p>private: 只允许在定义实体的封闭空间访问</p></li></ul><h3 id="访问级别规则"><a href="#访问级别规则" class="headerlink" title="访问级别规则"></a>访问级别规则</h3><ul><li>一个实体不可以被更低访问级别的实体定义，如下：</li></ul><ol><li><p>变量\常量类型  ≥ 变量\常量</p></li><li><p>参数类型、返回值类型  ≥ 函数</p></li><li><p>父类 ≥子类</p></li><li><p>父协议 ≥子协议</p></li><li><p>原类型 ≥typealias</p></li><li><p>原始值类型、关联值类型 ≥枚举类型</p></li><li><p>定义类型A时用到的其他类型 ≥类型A</p><p>……</p></li></ol><h3 id="元祖、泛型"><a href="#元祖、泛型" class="headerlink" title="元祖、泛型"></a>元祖、泛型</h3><p>元祖访问级别是成员中访问级别最低的那个</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-type">Dog</span> &#123;&#125;<br><span class="hljs-title">fileprivate</span> <span class="hljs-keyword">class</span> <span class="hljs-type">Animal</span> &#123;&#125;<br><br><span class="hljs-title">fileprivate</span> var <span class="hljs-class"><span class="hljs-keyword">data</span>: (<span class="hljs-type">Dog</span>, <span class="hljs-type">Animal</span>) // (<span class="hljs-type">Dog</span>, <span class="hljs-type">Animal</span>)的访问级别是fileprivate</span><br></code></pre></td></tr></table></figure><p>泛型类型的访问级别是类型访问级别以及所有泛型类型参数参数访问级别最低那个</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span>ernal <span class="hljs-keyword">class</span> <span class="hljs-symbol">Dog</span> &#123;&#125;<br>fileprivate <span class="hljs-keyword">class</span> <span class="hljs-symbol">Cat</span> &#123;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Animal</span>&lt;<span class="hljs-symbol">T1, <span class="hljs-symbol">T2</span></span>&gt; &#123;&#125;<br><br>fileprivate var animal = Animal&lt;Dog, Cat&gt;() <span class="hljs-comment">// Animal&lt;Dog, Cat&gt;()的访问级别是fileprivate</span><br></code></pre></td></tr></table></figure><h3 id="成员、嵌套类型"><a href="#成员、嵌套类型" class="headerlink" title="成员、嵌套类型"></a>成员、嵌套类型</h3><p>类型的访问级别会影响成员（属性、方法、初始化器、下标）、嵌套类型的访问级别</p><ul><li>一般情况下，类型为private 或 fileprivate，那么成员\嵌套类型默认也是private 或 fileprivate</li></ul><ul><li>一般情况下，类型为internal 或 public，那么成员\嵌套类型默认是internal</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> name: <span class="hljs-built_in">String</span> = <span class="hljs-string">&quot;zhansan&quot;</span> <span class="hljs-comment">//private</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="getter、setter"><a href="#getter、setter" class="headerlink" title="getter、setter"></a>getter、setter</h3><ul><li><p>getter、setter默认自动接收它们所属环境的访问级别</p></li><li><p>可以给setter单独设置一个比getter更低的访问级别，用以限制写的权限<br>注意：getter的权限不能比setter低</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">num可以在其他实体中被访问，但是只能在当前文件中被修改<br>fileprivate(<span class="hljs-keyword">set</span>) <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> <span class="hljs-keyword">num</span> = <span class="hljs-number">5</span><br><br><span class="hljs-keyword">class</span> Person &#123;<br>    <span class="hljs-keyword">private</span>(<span class="hljs-keyword">set</span>) <span class="hljs-keyword">var</span> <span class="hljs-keyword">name</span> = <span class="hljs-string">&quot;lisi&quot;</span><br>    fileprivate(<span class="hljs-keyword">set</span>) <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span> &#123;<br>        <span class="hljs-keyword">set</span> &#123;&#125;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-number">10</span> &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="初始化器"><a href="#初始化器" class="headerlink" title="初始化器"></a>初始化器</h3><ul><li><p>如果一个public类想在另一个模块调用编译生成的默认无参初始化器，必须 public的无参初始化器</p></li><li><p> 因为public类的默认初始化器是internal级别（在写一些提供给别人用的库的时候会用到）</p></li><li><p>required初始化器≥它的默认访问级别</p></li><li><p>如果结构体有private\fileprivate的存储实例属性，那么它的也是private\fileprivate</p></li></ul><h3 id="枚举类型的case、协议"><a href="#枚举类型的case、协议" class="headerlink" title="枚举类型的case、协议"></a>枚举类型的case、协议</h3><ul><li><p>不能给enum的每个case单独设置访问级别</p></li><li><p>每个case自动接收enum的访问级别</p></li></ul><p>自动接收协议的访问级别，不能单独设置访问级别</p><p>协议实现的访问级别必须 ≥ 类型访问级别,或者 ≥ 协议访问级别</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">TestProtocol</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> : <span class="hljs-title">TestProtocol</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;run&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ul><li><p>如果有显示设置扩展的访问级别，扩展添加的成员自动接收扩展的访问级别</p></li><li><p>如果没有显示设置扩展的访问级别，扩展添加的成员默认访问级别，跟直接在类型中定义的成员一样</p></li><li><p>可以单独给扩展中添加的成员设置访问级别</p></li><li><p>不能给遵守协议的扩展显示设置扩展的访问级别</p></li></ul><p>在同一个文件中的扩展，可以写成类似多个部分的类型声明</p><ul><li>在原本的声明中，声明一个私有成员，可以在同一个文件的扩展中访问它。</li><li>在扩展中声明一个私有成员，也可以在同一个文件的其他扩展中，或者原本的声明中访问它。</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> &#123;<br>        run1()<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">run1</span><span class="hljs-params">()</span></span> &#123;<br>         <br>     &#125;<br>&#125;<br>p<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Swift</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见排序</title>
    <link href="/2020/05/31/Sort/"/>
    <url>/2020/05/31/Sort/</url>
    
    <content type="html"><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p> 冒泡排序是一种简单直观的排序算法，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端</p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ul><li><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p></li><li><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p></li><li><p>针对所有的元素重复以上的步骤，除了最后一个。</p></li><li><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较</p></li></ul><h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><p><img src="/img/ittree/sort/bubbleSort.gif"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BubbleSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span>  i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">let</span> bool = <span class="hljs-literal">false</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; arr.length - <span class="hljs-number">1</span> - i; j++) &#123;<br>           <span class="hljs-keyword">if</span> (arr[j + <span class="hljs-number">1</span>] &lt; arr[j]) &#123;<br>           <span class="hljs-keyword">let</span> tmp = arr[j]<br>           arr[j] = arr[j + <span class="hljs-number">1</span>]<br>           arr[j + <span class="hljs-number">1</span>] = tmp<br>           bool = <span class="hljs-literal">true</span> <br>          &#125;<br>       &#125;<br>       <span class="hljs-keyword">if</span> (bool == <span class="hljs-literal">false</span> ) &#123;<br>             <span class="hljs-keyword">break</span><br>         &#125;<br>    &#125;<br>   <span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>选择排序是一种简单直观的排序算法<br>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置<br>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。<br>重复第二步，直到所有元素均排序完毕</p><h4 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h4><p><img src="/img/ittree/sort/selectionSort.gif"></p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">selectionSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>       <span class="hljs-keyword">let</span> minindex = i<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.length; j++) &#123;<br>           <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minindex]) &#123;<br>                      minindex = j<br>               &#125;<br>           &#125;<br>           <span class="hljs-keyword">if</span> (minindex != i) &#123;<br>                 <span class="hljs-keyword">let</span> tmp = arr[minindex]<br>                  arr[minindex] = arr[i]<br>                 arr[i] = tmp<br>             &#125;<br>         &#125;<br>         <span class="hljs-keyword">return</span> arr<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>插入排序是一种简单直观的排序算法，工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入<br>类似于我们生活中打扑克</p><h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><ul><li><p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p></li><li><p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置</p></li></ul><h4 id="演示-2"><a href="#演示-2" class="headerlink" title="演示"></a>演示</h4><p><img src="/img/ittree/sort/insertionSort.gif"></p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> len = arr.length<br>  <span class="hljs-keyword">var</span>  preIndex,current<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span>  i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>       preIndex = i - <span class="hljs-number">1</span><br>       current = arr[i]<br><br>       <span class="hljs-keyword">while</span>(preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;<br>          arr[preIndex + <span class="hljs-number">1</span>] = arr[preIndex];<br>          preIndex--;<br>       &#125; <br>            <br>           arr[preIndex + <span class="hljs-number">1</span>] = current<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr<br><br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。<br>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。<br>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了</p><h4 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h4><ol><li><p>从数列中挑出一个元素，称为 “基准”（pivot）;</p></li><li><p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p></li><li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序</p></li></ol><h4 id="演示-3"><a href="#演示-3" class="headerlink" title="演示"></a>演示</h4><p><img src="/img/ittree/sort/quickSort.gif"></p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">qiuckSort</span>(<span class="hljs-params">arr,left, right</span>) </span>&#123;<br>    <br>         <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>          <span class="hljs-keyword">let</span> index = getIndex(arr,left,right)<br>          qiuckSort(arr,left,index - <span class="hljs-number">1</span>)<br>            qiuckSort(arr,index + <span class="hljs-number">1</span> ,right)   <br>         &#125;<br>       <span class="hljs-keyword">return</span> arr<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getIndex</span>(<span class="hljs-params">arr,low,hight</span>) </span>&#123;<br> <span class="hljs-keyword">let</span> pivot = arr[low]<br><br>        <span class="hljs-keyword">while</span>(low &lt; hight) &#123;<br>            <span class="hljs-keyword">while</span>(low &lt; hight &amp;&amp; arr[hight] &gt;= pivot) &#123;<br>            hight--<br>            &#125;<br>            arr[low] = arr[hight]<br>             <span class="hljs-keyword">while</span>(low &lt;  hight &amp;&amp; arr[low] &lt;= pivot) &#123;<br>            low++<br>            &#125;<br>           arr[hight] = arr[low]<br>        &#125;<br>        arr[low] = pivot<br><br>        <span class="hljs-keyword">return</span> low<br> &#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ItTree</category>
      
    </categories>
    
    
    <tags>
      
      <tag>basic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>this 指向问题</title>
    <link href="/2020/05/08/this/"/>
    <url>/2020/05/08/this/</url>
    
    <content type="html"><![CDATA[<h3 id="JavaScript-this-关键字"><a href="#JavaScript-this-关键字" class="headerlink" title="JavaScript this 关键字"></a>JavaScript this 关键字</h3><p>面向对象语言中 this 表示当前对象的一个引用。<br>但在 JavaScript 中 this 不是固定不变的，它会随着执行境的改变而改变</p><p><strong>哪个对象调用函数，函数里面的this指向哪个对象</strong></p><p><strong>可以分为这5种情况讨论</strong></p><ol><li>作为普通函数被调用</li><li>作为对象属性被调用</li><li>作为构造函数</li><li>call和apply的应用</li><li>箭头函数</li></ol><h3 id="普通函数被调用"><a href="#普通函数被调用" class="headerlink" title="普通函数被调用"></a>普通函数被调用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;<br>       <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>   &#125;<br>test()<span class="hljs-comment">// Window</span><br></code></pre></td></tr></table></figure><h3 id="对象属性被调用"><a href="#对象属性被调用" class="headerlink" title="对象属性被调用"></a>对象属性被调用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<br>        id:<span class="hljs-string">&#x27;123&#x27;</span>,<br>        <span class="hljs-function"><span class="hljs-title">func</span>(<span class="hljs-params"></span>)</span> &#123;<br>          <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.id);<br>          <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>        &#125;,<br>    &#125;<br>    obj.func();<span class="hljs-comment">// 123 obj</span><br></code></pre></td></tr></table></figure><h3 id="构造函数调用"><a href="#构造函数调用" class="headerlink" title="构造函数调用"></a>构造函数调用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> objclass = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>       <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<span class="hljs-comment">//objclass</span><br>  &#125;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> objclass()<br></code></pre></td></tr></table></figure><p>在构造函数里面返回一个对象，会直接返回这个对象，而不是执行构造函数后创建的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-keyword">let</span> objclass = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.a =<span class="hljs-string">&#x27;1234&#x27;</span><br>     <span class="hljs-keyword">return</span> &#123;<br>         b:<span class="hljs-string">&#x27;456&#x27;</span><br>     &#125;<br>&#125;<br><span class="hljs-keyword">let</span> item  = <span class="hljs-keyword">new</span> objclass()<br><span class="hljs-built_in">console</span>.log(item.a)<span class="hljs-comment">//undefined</span><br></code></pre></td></tr></table></figure><h3 id="call和apply-调用"><a href="#call和apply-调用" class="headerlink" title="call和apply 调用"></a>call和apply 调用</h3><p>apply和call简单来说就是会改变传入函数的this指向</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj1 =  &#123;<br>         name:<span class="hljs-string">&#x27;zhangsan&#x27;</span><br>     &#125;<br>     <span class="hljs-keyword">let</span> obj2 = &#123;<br>         name: <span class="hljs-string">&#x27;lisi&#x27;</span>,<br>         <span class="hljs-function"><span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span> &#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>         &#125;<br>     &#125;<br>     obj2.fn.call(obj1) <span class="hljs-comment">// zhangsan</span><br></code></pre></td></tr></table></figure><p>call 和 apply 两个主要用途：</p><ul><li><p>改变 this 的指向（把 this 从 obj2 指向到 obj1 ）</p></li><li><p>方法借用（ obj1 没有 fn ，只是借用 obj2 方法）</p></li></ul><h3 id="箭头函数调用"><a href="#箭头函数调用" class="headerlink" title="箭头函数调用"></a>箭头函数调用</h3><p>箭头函数没有this，这里的this引用的是最近作用域(aaa函数里的this)的this</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>     <span class="hljs-function"><span class="hljs-title">aaa</span>(<span class="hljs-params"></span>)</span> &#123;<br>       <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>         <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>           <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>) <span class="hljs-comment">//window</span><br>         &#125;)<br>         <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>           <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>) <span class="hljs-comment">//window</span><br>         &#125;)<br>       &#125;)<br>       <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>         <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>           <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>) <span class="hljs-comment">//window</span><br>         &#125;)<br>         <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>           <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>) <span class="hljs-comment">//obj</span><br>         &#125;)<br>       &#125;)<br>     &#125;<br>   &#125;<br>   obj.aaa()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>H5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6特性</title>
    <link href="/2020/05/07/es6/"/>
    <url>/2020/05/07/es6/</url>
    
    <content type="html"><![CDATA[<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>​ES6之前没有块级作用域，ES5的var没有块级作用域的概念，只有function有作用域的概念，ES6的let、const引入了块级作用域。<br>​ES5之前if和for都没有作用域，所以很多时候需要使用function的作用域，比如闭包。</p><h4 id="什么是变量作用域"><a href="#什么是变量作用域" class="headerlink" title="什么是变量作用域"></a>什么是变量作用域</h4><p>​变量在什么范围内可用，类似Java的全局变量和局部变量的概念，全局变量，全局都可用，局部变量只在范围内可用。ES5之前的var是没有块级作用域的概念，使用var声明的变量就是全局的。</p><h4 id="没有块级作用域造成的问题"><a href="#没有块级作用域造成的问题" class="headerlink" title="没有块级作用域造成的问题"></a>没有块级作用域造成的问题</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> func;<br><span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>)&#123;<br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;zzz&#x27;</span>;<br>func = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">console</span>.log(name);<br>&#125;<br>func();<br> &#125;<br>name = <span class="hljs-string">&#x27;ttt&#x27;</span>;<br>func();<br><span class="hljs-built_in">console</span>.log(name);<br></code></pre></td></tr></table></figure><p>​代码输出结果为<code>&#39;zzz&#39;,&#39;ttt&#39;,&#39;ttt&#39;</code>，第一次调用func()，此时name=‘zzz’，在if块外将name置成‘ttt’，此时生效了，if没有块级作用域。</p><h4 id="for块级"><a href="#for块级" class="headerlink" title="for块级"></a>for块级</h4><p>​    定义五个按钮，增加事件，点击哪个按钮打印“第哪个按钮被点击了”。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;ie=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>块级作用域<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>按钮1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>按钮2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>按钮3<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>按钮4<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>按钮5<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">      <span class="hljs-comment">// 3.没有块级作用域引起的问题:for块级</span></span><br><span class="javascript">      <span class="hljs-keyword">var</span> btns = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&quot;button&quot;</span>);</span><br><span class="javascript">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; btns.length; i++) &#123;</span><br><span class="javascript">        btns[i].addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">param</span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;第&quot;</span>+i+<span class="hljs-string">&quot;个按钮被点击了&quot;</span>);</span><br>        &#125;);<br>      &#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>​    for块级中使用<code>var</code>声明变量i时，是全局变量，点击任意按钮结果都是“第五个按钮被点击了”。说明在执行<code>btns[i].addEventListener(&#39;click&#39;,function())</code>时，for块级循环已经走完，此时<code>i=5</code>，所有添加的事件的i都是5。</p><p>​    改造上述代码，将for循环改造，由于函数有作用域，使用闭包能解决上述问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 使用闭包,函数有作用域</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; btns.length; i++) &#123;<br>  (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">i</span>) </span>&#123;<br>    btns[i].addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">param</span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;第&quot;</span>+i+<span class="hljs-string">&quot;个按钮被点击了&quot;</span>);<br>    &#125;)<br>  &#125;)(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    结果如图所示，借用函数的作用域解决块级作用域的问题，因为有块级作用域，每次添加的i都是当前i。</p><p><strong>在ES6中使用let/const解决块级作用域问题，let和const有块级作用域，const定义常量，在for块级中使用let解决块级作用域问题。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ES6使用let/const</span><br><span class="hljs-keyword">const</span> btns = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&quot;button&quot;</span>);*<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; btns.length; i++) &#123;<br>  btns[i].addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">param</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;第&quot;</span>+i+<span class="hljs-string">&quot;个按钮被点击了&quot;</span>);<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>​结果和使用闭包解决一致。</p><h3 id="const-使用"><a href="#const-使用" class="headerlink" title="const 使用"></a>const 使用</h3><p>1.const用来定义常量，赋值知乎不能再赋值，再次赋值会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script&gt;<br>    <span class="hljs-comment">//1.定义常量，赋值后不能再赋值，在赋值报错</span><br>    <span class="hljs-keyword">const</span> count = <span class="hljs-number">1</span><br>    <span class="hljs-comment">// count = 2</span><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>​    2.const不能只声明不赋值，会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script&gt;<br>    <span class="hljs-comment">//2.只声明不赋值，必须赋值</span><br>    <span class="hljs-comment">// const count;</span><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>​3.const常量含义是你不能改变其指向的对象，例如user，都是你可以改变user属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script&gt;<br>    <span class="hljs-comment">//3.常量的含义是你不能改变其指向的对象user，但是你可以改变user属性</span><br>    <span class="hljs-keyword">const</span> user = &#123;<br>        name:<span class="hljs-string">&quot;zzz&quot;</span>,<br>        age:<span class="hljs-number">24</span>,<br>        height:<span class="hljs-number">175</span><br>    &#125;<br>    <span class="hljs-built_in">console</span>.log(user)<br>    user.name = <span class="hljs-string">&quot;ttt&quot;</span><br>    user.age = <span class="hljs-number">22</span><br>    user.height = <span class="hljs-number">188</span><br>    <span class="hljs-built_in">console</span>.log(user)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="ES6的对象属性增强型写法"><a href="#ES6的对象属性增强型写法" class="headerlink" title="ES6的对象属性增强型写法"></a>ES6的对象属性增强型写法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;zzz&quot;</span>;<br><span class="hljs-keyword">const</span> age = <span class="hljs-number">18</span>;<br><span class="hljs-keyword">const</span> user = &#123;<br>  name:name,<br>  age:age<br>&#125;<br><span class="hljs-built_in">console</span>.log(user);<br></code></pre></td></tr></table></figure><p>​    ES6写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;zzz&quot;</span>;<br><span class="hljs-keyword">const</span> age = <span class="hljs-number">18</span>;<br><span class="hljs-keyword">const</span> user = &#123;<br>name,age<br>&#125;<br><span class="hljs-built_in">console</span>.log(user);<br></code></pre></td></tr></table></figure><h3 id="ES6对象的函数增强型写法"><a href="#ES6对象的函数增强型写法" class="headerlink" title="ES6对象的函数增强型写法"></a>ES6对象的函数增强型写法</h3><p>​    ES6之前对象内定义函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;<br>  run:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;奔跑&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>  ES6写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span>&#123;<br>     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;奔跑&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><blockquote><p>传统定义函数的方式</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> aaa = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">param</span>) </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>对象字面量中定义函数</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;<br>    bbb (param) &#123;  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ES6中的箭头函数</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//const ccc = (参数列表) =&gt; &#123;&#125;</span><br>  <span class="hljs-keyword">const</span> ccc = <span class="hljs-function">() =&gt;</span> &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="箭头函数的参数和返回值"><a href="#箭头函数的参数和返回值" class="headerlink" title="箭头函数的参数和返回值"></a>箭头函数的参数和返回值</h3><blockquote><p>1.放入两个参数</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> sum = <span class="hljs-function">(<span class="hljs-params">num1,num2</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> num1 + num2 <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>2.放入一个参数,()可以省略</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> power = <span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> num * num<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="函数内部"><a href="#函数内部" class="headerlink" title="函数内部"></a>函数内部</h4><blockquote><p>1.函数中代码块中有多行代码</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> test = <span class="hljs-function">() =&gt;</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;hello zzz&quot;</span>)<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;hello vue&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>2.函数代码块中只有一行代码，可以省略return</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// const mul = (num1,num2) =&gt; &#123;</span><br><span class="hljs-comment">//   return num1 * num2</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-keyword">const</span> mul = <span class="hljs-function">(<span class="hljs-params">num1,num2</span>) =&gt;</span> num1* num2<br><span class="hljs-comment">// const log = () =&gt; &#123;</span><br><span class="hljs-comment">//   console.log(&quot;log&quot;)</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-keyword">const</span> log = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;log&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>####filter过滤函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> nums = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">77</span>,<span class="hljs-number">55</span>,<span class="hljs-number">100</span>,<span class="hljs-number">200</span>]<br><span class="hljs-comment">//要求获取nums中大于50的数</span><br><span class="hljs-comment">//回调函数会遍历nums中每一个数，传入回调函数，在回调函数中写判断逻辑，返回true则会被数组接收，false会被拒绝</span><br><span class="hljs-keyword">let</span> newNums = nums.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">num</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">50</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br> &#125;)<br><br> <span class="hljs-comment">//可以使用箭头函数简写</span><br> <span class="hljs-keyword">let</span> newNums = nums.filter(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> num &gt;<span class="hljs-number">50</span>)<br></code></pre></td></tr></table></figure><h4 id="map高阶函数"><a href="#map高阶函数" class="headerlink" title="map高阶函数"></a>map高阶函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 要求将已经过滤的新数组每项乘以2</span><br><span class="hljs-comment">//map函数同样会遍历数组每一项，传入回调函数为参数，num是map遍历的每一项，回调函数function返回值会被添加到新数组中</span><br><span class="hljs-keyword">let</span> newNums2 = newNums.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">num</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> num * <span class="hljs-number">2</span><br> &#125;)<br> <span class="hljs-comment">//简写</span><br><span class="hljs-comment">//  let newNums2 = newNums.map(num =&gt; num * 2)</span><br><span class="hljs-built_in">console</span>.log(newNums2);<br></code></pre></td></tr></table></figure><h4 id="reduce高阶函数"><a href="#reduce高阶函数" class="headerlink" title="reduce高阶函数"></a>reduce高阶函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 3.reduce高阶函数</span><br><span class="hljs-comment">//要求将newNums2的数组所有数累加</span><br><span class="hljs-comment">//reduce函数同样会遍历数组每一项，传入回调函数和‘0’为参数，0表示回调函数中preValue初始值为0，回调函数中参数preValue是每一次回调函数function返回的值，currentValue是当前值</span><br><span class="hljs-comment">//例如数组为[154, 110, 200, 400],则回调函数第一次返回值为0+154=154，第二次preValue为154，返回值为154+110=264，以此类推直到遍历完成</span><br><span class="hljs-keyword">let</span> newNum = newNums2.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">preValue,currentValue</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> preValue + currentValue<br> &#125;,<span class="hljs-number">0</span>)<br><span class="hljs-comment">//简写</span><br><span class="hljs-comment">// let newNum = newNums2.reduce((preValue,currentValue) =&gt; preValue + currentValue)</span><br><span class="hljs-built_in">console</span>.log(newNum);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>H5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vuex</title>
    <link href="/2020/05/07/vuex/"/>
    <url>/2020/05/07/vuex/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是Vuex"><a href="#什么是Vuex" class="headerlink" title="什么是Vuex"></a>什么是Vuex</h3><p>Vuex就是一个状态管理模式，为什么叫模式？因为Vuex包含了一套对state(状态)的操作规范，集中存储管理应用的所有组件的状态。</p><ul><li><p>简单来说就是管理各个组件共享的数据，类似session</p></li><li><p>session可以存数据，存的过程就是管理，数据的每一次赋值就是当次状态。</p></li><li><p>Vuex在Vue实例顶层中。</p><p>Vuex也可以理解为java中的一个map，这个map是static（静态资源）的，每次获取map的值，都需要调用java的api，比如map.get(key)获取对应的值，也可以放入数据map.put(data)，而且这个数据是所有类都可以调用的，只需要导入这个map就能使用里面的共享数据。</p><p>不了解java也没关系，你也可以理解成为百度百科就是一个容纳百科知识的容器，你要搜vuex，百科就会出现vuex的描述，这个搜索就是获取状态，如果你角色百科的vuex描述有误。你也可以发起修改操作，改成正确的vuex描述，这个修改操作就是修改vuex在百科里面的状态。当然你可以搜索修改vuex，别人也可以，因为这个状态是共享的。</p><p>简单来看实现这个功能好像我们自己封装一个对象就能实现，但是Vuex有一个特性就是响应式。如果我们自己封装对象想做到完美响应式比较麻烦，所有Vuex帮我们做了这个事情。</p></li></ul><blockquote><p>什么状态需要Vuex去管理？</p></blockquote><ul><li>比如用户的登录的状态（token）、用户的信息（头像、名称、地理位置信息）等等</li><li>比如商品的收藏，购物车的商品等等</li><li>这些状态应该是响应式的，用户昵称、头像修改了需要响应</li></ul><p><img src="/img/h5/vue/vuex/19-01.png"></p><ul><li><strong>state</strong>，驱动应用的数据源；</li><li><strong>view</strong>，以声明方式将 <strong>state</strong> 映射到视图；</li><li><strong>actions</strong>，响应在 <strong>view</strong> 上的用户输入导致的状态变化。</li></ul><p>这是一个单页面数据流向，比如想要修改用户昵称，当前用户昵称的状态是A，通过输入框输入了新的昵称B，调用ajax请求后端修改成功后将state改成B，然后视图响应用户昵称的变化从A到B。</p><p>但是，当我们的应用遇到<strong>多个组件共享状态</strong>时，单向数据流的简洁性很容易被破坏：</p><ul><li>多个视图依赖于同一状态。</li><li>来自不同视图的行为需要变更同一状态。</li><li>所以我们需要vuex的规范操作来管理状态。</li></ul><h3 id="Vuex的核心概念"><a href="#Vuex的核心概念" class="headerlink" title="Vuex的核心概念"></a>Vuex的核心概念</h3><ul><li>State</li><li>Getters</li><li>Mutation</li><li>Action</li><li>Moudule</li></ul><h3 id="Vuex的流程"><a href="#Vuex的流程" class="headerlink" title="Vuex的流程"></a>Vuex的流程</h3><p><img src="/img/h5/vue/vuex/19-03.png"></p><ul><li>Vue Components是vue组件</li><li>Mutations ：更改 Vuex 的 store 中的状态的唯一方法是提交 mutation</li><li>State 是vuex中状态的集合</li><li>Actions与Mutations 类似，经常与后端交互，不同在于：<ul><li>Action 提交的是 mutation，而不是直接变更状态。</li><li>Action 可以包含任意异步操作。</li></ul></li></ul><p>组件中修改state，通过提交 mutation，修改完成后vuex帮我们响应到vue组件上。</p><blockquote><p>修改index.js使用mutation</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 2.创建对象</span><br><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>  state: &#123; <span class="hljs-comment">// 状态集合</span><br>    count: <span class="hljs-number">0</span> <span class="hljs-comment">// 具体的状态数据</span><br>  &#125;,<br>  mutations: &#123; <span class="hljs-comment">// 操作修改state（状态）</span><br>    increment (state) &#123; <span class="hljs-comment">// 增加</span><br>      state.count++<br>    &#125;,<br>    decrement (state) &#123; <span class="hljs-comment">// 减少</span><br>      state.count--<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div id&#x3D;&quot;app&quot;&gt;<br>    &lt;h3&gt;&#123;&#123; message &#125;&#125;&lt;&#x2F;h3&gt;<br>    &lt;h3&gt;&#123;&#123; $store.state.count &#125;&#125;&lt;&#x2F;h3&gt;<br>    &lt;button @click&#x3D;&quot;add&quot;&gt;+&lt;&#x2F;button&gt;<br>    &lt;button @click&#x3D;&quot;sub&quot;&gt;-&lt;&#x2F;button&gt;<br>    &lt;hello-vuex &#x2F;&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>import HelloVuex from &#39;.&#x2F;components&#x2F;HelloVuex&#39;<br><br>export default &#123;<br>  name: &#39;App&#39;,<br>  data () &#123;<br>    return &#123;<br>      message: &#39;&#39;<br>    &#125;<br>  &#125;,<br>  components: &#123;<br>    HelloVuex<br>  &#125;,<br>  methods: &#123;<br>    add () &#123;<br>      this.$store.commit(&#39;increment&#39;)<br>    &#125;,<br>    sub () &#123;<br>      this.$store.commit(&#39;decrement&#39;)<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><h3 id="State（单一状态树）"><a href="#State（单一状态树）" class="headerlink" title="State（单一状态树）"></a>State（单一状态树）</h3><p>Vuex 使用<strong>单一状态树</strong>——是的，用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源 (<a href="https://en.wikipedia.org/wiki/Single_source_of_truth">SSOT</a>)”而存在。。这也意味着，每个应用将仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。</p><p>简单说就是把数据所有有关的数据封装到一个对象中，这个对象就是store实例，无论是数据的状态（state），以及对数据的操作（mutation、action）等都在store实例中，便于管理维护操作。<br>直接通过<code>this.$store.state</code>获取state对象。</p><h3 id="Mutation（状态更新）"><a href="#Mutation（状态更新）" class="headerlink" title="Mutation（状态更新）"></a>Mutation（状态更新）</h3><ul><li><p>Vuex的store状态更新的唯一方式：<strong>提交Mutation</strong></p></li><li><p>Mutation主要包括两个部分：</p><ol><li><p>字符串的<strong>事件类型（type）</strong></p></li><li><p>一个<strong>回调函数（handler）</strong>，这个回调函数就是我们实际进行状态更改的地方，该回调函数的<strong>第一个参数就是state</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">mutation: &#123;<br>    increment (state) &#123;<br>        state.count++<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>通过Mutation更新</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">mutation () &#123;<br><span class="hljs-built_in">this</span>.$store.commit(<span class="hljs-string">&#x27;increment&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="mutation-提交风格"><a href="#mutation-提交风格" class="headerlink" title="mutation 提交风格"></a>mutation 提交风格</h4><ol><li><p>普通提交风格</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">this</span>.$store.commot(<span class="hljs-string">&#x27;increment&#x27;</span>, count)<br></code></pre></td></tr></table></figure><p>此时count传过去的就是count=10</p></li><li><p>特殊的提交封装</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">this</span>.$store.commit(&#123;<br>type: <span class="hljs-string">&#x27;addCount&#x27;</span>,<br>count<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">addCount (state, payload) &#123; <span class="hljs-comment">// 此时传入的就不是一个count值了，而是一个对象</span><br>state.count += payload.count<br>&#125;<br></code></pre></td></tr></table></figure><p>此时count传过去是一个对象payload（载荷）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>type: <span class="hljs-string">&#x27;incrementCount&#x27;</span>,<br>count: <span class="hljs-number">10</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h4></li></ol><p>处理异步操作，如网络请求等，然后再使用mutation操作更新</p><p>Action 类似于 mutation，不同在于：</p><ul><li>Action 提交的是 mutation，而不是直接变更状态。</li><li>Action 可以包含任意异步操作。</li></ul><ol><li>新增一个mutation</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">updateName (state, name) &#123;<br>state.user.name = name<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>新增一个actions</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">actions: &#123;<br>    <span class="hljs-comment">// context：上下文</span><br>    aUpdateInfo (context, name) &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        context.commit(updateName, <span class="hljs-number">12</span>)<br>        &#125;, <span class="hljs-number">1000</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>提交方法</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">aUpdateInfo () &#123;<br><span class="hljs-built_in">this</span>.$store.dispatch(<span class="hljs-string">&#x27;aUpdateInfo&#x27;</span>, <span class="hljs-string">&#x27;lisi&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>点击按钮之后，信息修改了，dev-tools也能跟踪到state的变化。通过<code>$store.dispacth()</code>方法来调用actions，发送异步请求，在actions中需要提交mutation来修改state。</p><h3 id="moudules（模块）"><a href="#moudules（模块）" class="headerlink" title="moudules（模块）"></a>moudules（模块）</h3><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p><p>为了解决以上问题，Vuex 允许我们将 store 分割成<strong>模块（module）</strong>。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> moduleA = &#123;<br>  state: <span class="hljs-function">() =&gt;</span> (&#123; ... &#125;),<br>  mutations: &#123; ... &#125;,<br>  actions: &#123; ... &#125;,<br>  getters: &#123; ... &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> moduleB = &#123;<br>  state: <span class="hljs-function">() =&gt;</span> (&#123; ... &#125;),<br>  mutations: &#123; ... &#125;,<br>  actions: &#123; ... &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>  modules: &#123;<br>    a: moduleA,<br>    b: moduleB<br>  &#125;<br>&#125;)<br><br>store.state.a <span class="hljs-comment">// -&gt; moduleA 的状态</span><br>store.state.b <span class="hljs-comment">// -&gt; moduleB 的状</span><br></code></pre></td></tr></table></figure><h4 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h4><ol><li>应用层级的状态应该集中到单个 store 对象中。</li><li>提交 <strong>mutation</strong> 是更改状态的唯一方法，并且这个过程是同步的。</li><li>异步逻辑都应该封装到 <strong>action</strong> 里面。</li></ol><p>只要你遵守以上规则，如何组织代码随你便。如果你的 store 文件太大，只需将 action、mutation 和 getter 分割到单独的文件。</p><p>对于大型应用，我们会希望把 Vuex 相关代码分割到模块中。下面是项目结构示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">├── index.html<br>├── main.js<br>├── api<br>│   └── ... <span class="hljs-comment"># 抽取出API请求</span><br>├── components<br>│   ├── App.vue<br>│   └── ...<br>└── store<br>    ├── index.js          <span class="hljs-comment"># 我们组装模块并导出 store 的地方</span><br>    ├── actions.js        <span class="hljs-comment"># 根级别的 action</span><br>    ├── mutations.js      <span class="hljs-comment"># 根级别的 mutation</span><br>    └── modules<br>        ├── cart.js       <span class="hljs-comment"># 购物车模块</span><br>        └── products.js   <span class="hljs-comment"># 产品模块</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue-router</title>
    <link href="/2020/05/07/vue-router/"/>
    <url>/2020/05/07/vue-router/</url>
    
    <content type="html"><![CDATA[<h3 id="路由简介"><a href="#路由简介" class="headerlink" title="路由简介"></a>路由简介</h3><p><strong>什么是路由？</strong></p><ul><li><p>路由就是通过互联的网络把信息用源地址传送到目的地的活动</p></li><li><p>路由提供了两种机制：路由和传送</p><ul><li>路由是决定数据包从来源到目的地的路径</li><li>转送就是将数据转移</li></ul></li><li><p>路由表</p><ul><li>路由表本质就是一个映射表，决定了数据包的指向</li></ul></li></ul><h3 id="前端-后端路由"><a href="#前端-后端路由" class="headerlink" title="前端/后端路由"></a>前端/后端路由</h3><ul><li><p>后端渲染（服务端渲染）<br> jsp技术<br> 后端路由，后端处理URL和页面映射关系，例如springmvc中的@requestMapping注解配置的URL地址，映射前端页面</p></li><li><p>前后端分离（ajax请求数据）<br> 后端只负责提供数据<br> 静态资源服务器（html+css+js）<br> ajax发送网络请求后端服务器，服务器回传数据<br> js代码渲染dom</p></li><li><p>单页面富应用（SPA页面）<br> 前后端分离加上前端路由，前端路由的url映射表不会向服务器请求，是单独url的的页面自己的ajax请求后端，后端只提供api负责响应数据请求。改变url，页面不进行整体的刷新。<br> 整个网站只有一个html页面。</p></li></ul><h3 id="URL的hash和HTML5的history"><a href="#URL的hash和HTML5的history" class="headerlink" title="URL的hash和HTML5的history"></a>URL的hash和HTML5的history</h3><h4 id="URL的hash"><a href="#URL的hash" class="headerlink" title="URL的hash"></a>URL的hash</h4><ul><li>URL的hash是通过锚点(#)，其本质上改变的是window.location的href属性。</li><li>可以通过直接赋值location.hash来改变href，但是页面并不会发生刷新。</li></ul><p><img src="/img/h5/vue/vuerouter/17-1.png"></p><p>使用命令<code>vue init webpack 01-vue-router-vuecli2</code>创建新的vuecli2工程,等待创建完成后，使用<code>npm run dev</code>启动服务器，在浏览器通过 <a href="http://localhost:8080/">http://localhost:8080</a> 进入工程主页。 测试通过改变hash，查看是否会刷新页面，浏览器的url地址是否改变。</p><p><img src="/img/h5/vue/vuerouter/17-2.gif"></p><p><strong>结论</strong></p><p>测试发现url的地址栏改变了变成了<a href="http://localhost:8080/#/zty">http://localhost:8080/#/zty</a>  ，通过查看network发现只有favicon.ico资源重新请求了，这个是工程的logo图标，其他资源都未请求。可以通过改变hash改变url，此时页面是未刷新的。</p><p>vue-router其实用的就是这样的机制，改变url地址，这个url地址存在一份路由映射表里面，比如<code>/user</code>代表要请求用户页面，只要配置了这个路由表（路由关系），就可以前端跳转而不刷新页面，所有的数据请求都走ajax。</p><h4 id="HTML5的history模式"><a href="#HTML5的history模式" class="headerlink" title="HTML5的history模式"></a>HTML5的history模式</h4><blockquote><p>pushState</p></blockquote><p>同样的使用HTML5的history模式也是不会刷新页面的,history对象栈结构，先进后出，pushState类似压入栈中，back是回退。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">hristory.pushState(&#123;&#125;, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;/foo&#x27;</span>)<br>history.back()<br></code></pre></td></tr></table></figure><p><img src="/img/h5/vue/vuerouter/17-3.png"></p><blockquote><p>replaceState</p></blockquote><p>replaceState模式与pushState模式区别在于replaceState模式浏览器没有返回只是替换，不是压入栈中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">history.replaceState(&#123;&#125;, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;home&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="/img/h5/vue/vuerouter/17-4.png"></p><blockquote><p>go</p></blockquote><p>go只能在pushState模式中使用，go是前进后退到哪个历史页面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">history.go(-<span class="hljs-number">1</span>)<span class="hljs-comment">//回退一个页面</span><br>history.go(<span class="hljs-number">1</span>)<span class="hljs-comment">//前进一个页面</span><br>history.forward()<span class="hljs-comment">//等价于go(1)</span><br>history.back()<span class="hljs-comment">//等价于go(-1)</span><br></code></pre></td></tr></table></figure><h3 id="vue-router的安装配置"><a href="#vue-router的安装配置" class="headerlink" title="vue-router的安装配置"></a>vue-router的安装配置</h3><ol><li><p>使用<code>npm install vue-router --save</code>来安装vue-router插件模块</p></li><li><p>在模块化工程中使用他(因为是一个插件，所以可以通过Vue.user来安装路由功能)</p><ul><li>在src下创建一个router文件夹（一般安装vue-router时候会自动创建）用来存放vue-router的路由信息导入路由对象，并且调用<strong>Vue.use(VueRouter)</strong></li><li>创建路由实例，并且传入路由<strong>映射配置</strong></li><li>在vue实例中挂载创建的<strong>路由实例对象</strong></li></ul><blockquote><p>router文件夹中的index.js</p></blockquote></li></ol><h3 id="lt-router-link-gt-的其他属性"><a href="#lt-router-link-gt-的其他属性" class="headerlink" title="&lt;router-link&gt;的其他属性"></a><code>&lt;router-link&gt;</code>的其他属性</h3><ol><li><p><code>to</code>属性：用于跳转到指定路径。</p></li><li><p><code>tag</code>属性：可以指定<code>&lt;router-link&gt;</code>之后渲染成什么组件使用<code>&lt;router-link to=&#39;/home&#39; tag=&#39;button&#39;&gt;</code>会被渲染成一个按钮，而不是a标签。</p></li><li><p><code>relapce</code>属性：在history模式下指定<code>&lt;router-link to=&#39;/home&#39; tag=&#39;button&#39; replace&gt;</code>使用<code>replaceState</code>而不是pushState，此时浏览器的返回按钮是不能使用的。</p></li><li><p><code>active-class</code>属性：当<code>&lt;router-link&gt;</code>对应的路由匹配成功的时候，会自动给当前元素设置一个<code>router-link-active</code>的class，设置active-class可以修改默认的名称。</p></li></ol><ul><li><p>在进行高亮显示的导航菜单或者底部tabbar时，会用到该属性</p></li><li><p>但是通常不会修改类的属性，会直接使用默认的<code>router-link-active</code></p></li><li><p><code>&lt;router-link to=&#39;/home&#39; tag=&#39;button&#39; active-class=&#39;active&#39;&gt;</code>此时被选中的<code>&lt;router-link&gt;</code>就会有active的class。</p></li><li><p>如果每个<code>&lt;router-link&gt;</code>都要加上<code>active-class=&#39;active&#39;</code>，那就在路由里面统一更改。</p></li></ul><h3 id="通过代码修改路由跳转"><a href="#通过代码修改路由跳转" class="headerlink" title="通过代码修改路由跳转"></a>通过代码修改路由跳转</h3><p>修改app.vue，将<code>&lt;router-link&gt;</code>换成<code>button</code>等任何组件，添加上点击事件，并写好点击事件响应方法，此时使用<code>this.$router.push(&#39;/home&#39;)</code>，push方法 等价于pushState方法，replace 方法等价于replaceState方法。</p><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>一个页面的path路径可能是不确定的，例如可能有<code>/user/aaaa</code>或者<code>/user/bbbb</code>，除了<code>/user</code>之外，后面还跟上了用户ID<code>/user/123</code>等。这种path和component的匹配关系，叫动态路由。</p><h4 id="params-模式"><a href="#params-模式" class="headerlink" title="params 模式"></a>params 模式</h4><blockquote><p>配置路由参数index.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  path: <span class="hljs-string">&#x27;/user/:userId&#x27;</span>,<br>  name: <span class="hljs-string">&#x27;User&#x27;</span>,<br>  component: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/components/User&#x27;</span>) <span class="hljs-comment">//懒加载组件</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>新建一个User组件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class&#x3D;&quot;page-contianer&quot;&gt;<br>    &lt;h2&gt;这是用户界面&lt;&#x2F;h2&gt;<br>    &lt;p&gt;这里是用户页面的内容。&lt;&#x2F;p&gt;<br>    &lt;p&gt;用户ID是: &#123;&#123; userId &#125;&#125;&lt;&#x2F;p&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br>&lt;script type&#x3D;&quot;text&#x2F;ecmascript-6&quot;&gt;<br>export default &#123;<br>  name: &#39;User&#39;,<br>  computed:&#123;<br>    userId() &#123;<br>      return this.$route.params.userId<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;&#x2F;script&gt;<br>&lt;style scoped&gt;<br>&lt;&#x2F;style&gt;<br><br></code></pre></td></tr></table></figure><p>该组件定义一个计算属性，通过<code>this.$route.params.userId</code>获取处于激活状态的路由参数<code>userId</code>。</p><h4 id="query-模式"><a href="#query-模式" class="headerlink" title="query 模式"></a>query 模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class&#x3D;&quot;page-contianer&quot;&gt;<br>    &lt;h2&gt;这是档案界面&lt;&#x2F;h2&gt;<br>    &lt;p&gt;这里是档案页面的内容。&lt;&#x2F;p&gt;<br>    &lt;p&gt;档案的名字是: &#123;&#123; profileInfo.name &#125;&#125;&lt;&#x2F;p&gt;<br>    &lt;p&gt;档案的年龄是: &#123;&#123; profileInfo.age &#125;&#125;&lt;&#x2F;p&gt;<br>    &lt;p&gt;档案的身高是: &#123;&#123; profileInfo.height &#125;&#125;&lt;&#x2F;p&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br>&lt;script type&#x3D;&quot;text&#x2F;ecmascript-6&quot;&gt;<br>export default &#123;<br>  name: &#39;Profile&#39;,<br>  computed: &#123;<br>    profileInfo() &#123;<br>      return this.$route.query.profileInfo<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;&#x2F;script&gt;<br>&lt;style scoped&gt;&lt;&#x2F;style&gt;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  path: <span class="hljs-string">&#x27;/profile&#x27;</span>,<br>  name: <span class="hljs-string">&#x27;Profile&#x27;</span>,<br>  component: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/components/Profile&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;router-link :to&#x3D;&quot;&#123; path: &#39;&#x2F;profile&#39;, query: &#123; profileInfo &#125; &#125;&quot;&gt;档案&lt;&#x2F;router-link&gt;<br></code></pre></td></tr></table></figure><p>在app.vue中设置初始的对象<code>profileInfo</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">data ()&#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    userId: <span class="hljs-string">&#x27;zty&#x27;</span>,<br>    profileInfo: &#123;<br>      name: <span class="hljs-string">&quot;zty&quot;</span>,<br>      age: <span class="hljs-number">24</span>,<br>      height: <span class="hljs-number">177</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用代码编写传递数据，使用<code>button</code>代替<code>&lt;router-link&gt;</code>，并添加点击事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;button @click&#x3D;&quot;userClick&quot;&gt;用户&lt;&#x2F;button&gt;<br>&lt;button @click&#x3D;&quot;profileClick&quot;&gt;档案&lt;&#x2F;button&gt;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">userClick</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-built_in">this</span>.$router.push(<span class="hljs-string">&#x27;/user/&#x27;</span> + <span class="hljs-built_in">this</span>.userId)<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;userClick&quot;</span>)<br>&#125;,<br><span class="hljs-function"><span class="hljs-title">profileClick</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-keyword">let</span> profileInfo = <span class="hljs-built_in">this</span>.profileInfo<br>  <span class="hljs-built_in">this</span>.$router.push(&#123;<br>    path: <span class="hljs-string">&#x27;/profile&#x27;</span>,<br>    query: &#123;<br>      profileInfo<br>    &#125;<br>  &#125;)<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;profileClick&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>传递参数主要有两种类型：params和query</p><blockquote><p>params的类型也就是动态路由形式</p></blockquote><ul><li>配置路由的格式：<code>/user/:userId</code></li><li>传递的方式：在path后面跟上对应的userId</li><li>传递形成的路径：<code>/user/123</code>，<code>/user/xxx</code></li><li>通过<code>$route.params.userId</code>获取指定userId</li></ul><blockquote><p>query的类型</p></blockquote><ul><li>配置路由的格式：<code>/profile</code>，也就是普通的配置</li><li>传递的方式：对象中使用query的key作为传递的方式</li><li>传递形成的路径：<code>/profile?name=zty&amp;age=24&amp;height=177</code>（这个传递的是三个键值对），<code>/profile?profileInfo=%5Bobject%20Object%5D</code>（这个query传递的是一个对象的键值对，key为profileInfo，value是一个对象）</li></ul><h3 id="vue-router的导航守卫"><a href="#vue-router的导航守卫" class="headerlink" title="vue-router的导航守卫"></a>vue-router的导航守卫</h3><p>问题：我们经常需要在路由跳转后，例如从用户页面跳转到首页，页面内容虽然可以自己定义，但是只有一个html文件，也只有一个title标签，我们需要改变标题。</p><p>可以使用js去修改title，可以使用vue的生命周期函数在组件被创建的时候修改title标签内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-comment">//创建的时候修改title</span><br>    <span class="hljs-built_in">document</span>.title = <span class="hljs-string">&#x27;关于&#x27;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">//数据被挂载到dom上的时候修改title</span><br>&#125;<br><span class="hljs-function"><span class="hljs-title">update</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">//页面刷新的时候修改</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当然不能每个组件去写生命周期函数，如果我们能监听路由的变化(了解路由从哪来往哪里跳转)，那我们就能在跳转中修改title标签，这就是导航守卫能做的事情。</p><p>修改<code>router/index.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 前置钩子：从from跳转到to</span><br><span class="hljs-comment"> * from 来的路由</span><br><span class="hljs-comment"> * to 要去的路由</span><br><span class="hljs-comment"> */</span><br>router.beforeEach(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">document</span>.title = to.matched[<span class="hljs-number">0</span>].meta.title <span class="hljs-comment">//给目标路由的页面的title赋值</span><br>  next()<span class="hljs-comment">//必须调用，不调用不会跳转</span><br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>router.beforeEach()称为前置钩子(前置守卫)，顾名思义，跳转之前做一些处理。</p></blockquote><p>当然每个路由配置上也要加上meta属性，不然就取不到了，为什么要使用<code>matched[0]</code>，因为如果你是嵌套路由，有没有给子路由添加meta（元数据：描述数据的数据）属性，就会显示<code>undefined</code>，使用<code>matched[0]</code>表示取到匹配的第一个就会找到父路由的meta属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//配置路由和组件之间的对应关系</span><br>&#123;<br>  path: <span class="hljs-string">&#x27;/home&#x27;</span>,<span class="hljs-comment">//home  前端路由地址</span><br>  name: <span class="hljs-string">&#x27;Home&#x27;</span>,<br>  component: Home, <span class="hljs-comment">//组件名</span><br>  meta: &#123;<br>    title: <span class="hljs-string">&#x27;首页&#x27;</span><br>  &#125;,<br>  children: [<br>    &#123;<br>      path: <span class="hljs-string">&#x27;&#x27;</span>,<br>      redirect: <span class="hljs-string">&#x27;/home/news&#x27;</span><span class="hljs-comment">//缺省时候重定向到/home/news</span><br>    &#125;,<br>    &#123;<br>      path: <span class="hljs-string">&#x27;news&#x27;</span>,<span class="hljs-comment">//子嵌套路由 无须加/</span><br>      name: <span class="hljs-string">&#x27;News&#x27;</span>,<br>      component: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/components/HomeNews&#x27;</span>) <span class="hljs-comment">//懒加载组件</span><br>    &#125;,<br>    &#123;<br>      path: <span class="hljs-string">&#x27;message&#x27;</span>,<br>      name: <span class="hljs-string">&#x27;Message&#x27;</span>,<br>      component: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/components/HomeMessage&#x27;</span>) <span class="hljs-comment">//懒加载组件</span><br>    &#125;<br>  ]<br>&#125;,<br></code></pre></td></tr></table></figure><h3 id="导航守卫补充"><a href="#导航守卫补充" class="headerlink" title="导航守卫补充"></a>导航守卫补充</h3><p>前面说了前置守卫router.beforeEach()，相对的应该也存在后置守卫(后置钩子)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 后置钩子</span><br><span class="hljs-comment"> */</span><br>router.afterEach(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;后置钩子调用了----&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>顾名思义，也就是在跳转之后的回调函数。</p><ul><li>前置守卫和后置守卫都是<strong>全局守卫</strong>。</li><li>还有<a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E8%B7%AF%E7%94%B1%E7%8B%AC%E4%BA%AB%E7%9A%84%E5%AE%88%E5%8D%AB">路由独享守卫</a></li><li><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E7%BB%84%E4%BB%B6%E5%86%85%E7%9A%84%E5%AE%88%E5%8D%AB">组件内的守卫</a></li></ul><blockquote><p>路由独享守卫，路由私有的</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  path: <span class="hljs-string">&#x27;/about&#x27;</span>,<span class="hljs-comment">//about 前端路由地址</span><br>  name: <span class="hljs-string">&#x27;About&#x27;</span>,<br>  component: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/components/About&#x27;</span>),<br>  beforeEnter: <span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;来自&#x27;</span> + <span class="hljs-keyword">from</span>.path + <span class="hljs-string">&#x27;,要去&#x27;</span> + to.path)<br>    next()<br>  &#125;,<br>  meta: &#123;<br>    title: <span class="hljs-string">&#x27;关于&#x27;</span><br>  &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p><code>beforeEnter</code>的参数与全局守卫一样，修改<code>about</code>路由的参数，添加路由独享守卫，此时只有跳转到<code>about</code>路由，才会打印日志。</p><blockquote><p>组件内的守卫，直接在组件中定义的属性</p></blockquote><ul><li><code>beforeRouteEnter</code></li><li><code>beforeRouteUpdate</code> (2.2 新增)</li><li><code>beforeRouteLeave</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> Foo = &#123;<br>  template: <span class="hljs-string">`...`</span>,<br>  beforeRouteEnter (to, <span class="hljs-keyword">from</span>, next) &#123;<br>    <span class="hljs-comment">// 在渲染该组件的对应路由被 confirm 前调用</span><br>    <span class="hljs-comment">// 不！能！获取组件实例 `this`</span><br>    <span class="hljs-comment">// 因为当守卫执行前，组件实例还没被创建</span><br>  &#125;,<br>  beforeRouteUpdate (to, <span class="hljs-keyword">from</span>, next) &#123;<br>    <span class="hljs-comment">// 在当前路由改变，但是该组件被复用时调用</span><br>    <span class="hljs-comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span><br>    <span class="hljs-comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span><br>    <span class="hljs-comment">// 可以访问组件实例 `this`</span><br>  &#125;,<br>  beforeRouteLeave (to, <span class="hljs-keyword">from</span>, next) &#123;<br>    <span class="hljs-comment">// 导航离开该组件的对应路由时调用</span><br>    <span class="hljs-comment">// 可以访问组件实例 `this`</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>beforeRouteEnter</code> 守卫 <strong>不能</strong> 访问 <code>this</code>，因为守卫在导航确认前被调用,因此即将登场的新组件还没被创建。</p><p>不过，你可以通过传一个回调给 <code>next</code>来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">beforeRouteEnter (to, <span class="hljs-keyword">from</span>, next) &#123;<br>  next(<span class="hljs-function"><span class="hljs-params">vm</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 通过 `vm` 访问组件实例</span><br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>注意 <code>beforeRouteEnter</code> 是支持给 <code>next</code> 传递回调的唯一守卫。对于 <code>beforeRouteUpdate</code> 和 <code>beforeRouteLeave</code> 来说，<code>this</code> 已经可用了，所以<strong>不支持</strong>传递回调，因为没有必要了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">beforeRouteUpdate (to, <span class="hljs-keyword">from</span>, next) &#123;<br>  <span class="hljs-comment">// just use `this`</span><br>  <span class="hljs-built_in">this</span>.name = to.params.name<br>  next()<br>&#125;<br></code></pre></td></tr></table></figure><p>这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 <code>next(false)</code> 来取消。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">beforeRouteLeave (to, <span class="hljs-keyword">from</span> , next) &#123;<br>  <span class="hljs-keyword">const</span> answer = <span class="hljs-built_in">window</span>.confirm(<span class="hljs-string">&#x27;Do you really want to leave? you have unsaved changes!&#x27;</span>)<br>  <span class="hljs-keyword">if</span> (answer) &#123;<br>    next()<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    next(<span class="hljs-literal">false</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完整的导航解析流程"><a href="#完整的导航解析流程" class="headerlink" title="完整的导航解析流程"></a>完整的导航解析流程</h3><ol><li>导航被触发。</li><li>在失活的组件里调用离开守卫。</li><li>调用全局的 <code>beforeEach</code> 守卫。</li><li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫 (2.2+)。</li><li>在路由配置里调用 <code>beforeEnter</code>。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li><li>调用全局的 <code>beforeResolve</code> 守卫 (2.5+)。</li><li>导航被确认。</li><li>调用全局的 <code>afterEach</code> 钩子。</li><li>触发 DOM 更新。</li><li>用创建好的实例调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数。</li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端模块化</title>
    <link href="/2020/05/07/modules/"/>
    <url>/2020/05/07/modules/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是前端模块化"><a href="#什么是前端模块化" class="headerlink" title="什么是前端模块化"></a>什么是前端模块化</h3><p>模块化侧重的功能的封装，主要是针对Javascript代码，隔离、组织复制的javascript代码，将它封装成一个个具有特定功能的的模块。</p><p>模块可以通过传递参数的不同修改这个功能的的相关配置，每个模块都是一个单独的作用域，根据需要调用。</p><p>一个模块的实现可以依赖其它模块</p><h3 id="为什么要有模块化"><a href="#为什么要有模块化" class="headerlink" title="为什么要有模块化"></a>为什么要有模块化</h3><p>​随着前端项目越来越大，团队人数越来越多，多人协调开发一个项目成为常态。例如现在小明和小张共同开发一个项目，小明定义一个aaa.js，小王定义了一个bbb.js。</p><blockquote><p>aaa.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//小明开发</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;小明&#x27;</span><br><span class="hljs-keyword">var</span> age = <span class="hljs-number">22</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">num1, num2</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> num1 + num2<br>&#125;<br><span class="hljs-keyword">var</span> flag = <span class="hljs-literal">true</span><br><span class="hljs-keyword">if</span> (flag) &#123;<br>  <span class="hljs-built_in">console</span>.log(sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>此时小明的<code>sum</code>是没有问题的。</p><blockquote><p>bbb.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//小红</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;小王&quot;</span><br><span class="hljs-keyword">var</span> flag = <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>此时小明和小王各自用各自的<code>flag</code>你变量没问题。</p><blockquote><p>但是此时小明又创建了一个mmm.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//小明</span><br><span class="hljs-keyword">if</span>(flag)&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;flag是true&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>在index.html页面导入这些js文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">&lt;script src&#x3D;&quot;aaa.js&quot; &gt;&lt;&#x2F;script&gt;<br>&lt;script src&#x3D;&quot;bbb.js&quot; &gt;&lt;&#x2F;script&gt;<br>&lt;script src&#x3D;&quot;ccc.js&quot; &gt;&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><p>此时小明知道自己在aaa.js中定义的<code>flag</code>是<code>true</code>，认为打印没有问题，但是不知道小王的bbb.js中也定义了<code>flag</code>为<code>true</code>，所以mmm.js文件并没有打印出“flag是true”。</p><p><strong>这就是全局变量同名问题</strong></p><h3 id="常见的模块化规范"><a href="#常见的模块化规范" class="headerlink" title="常见的模块化规范"></a>常见的模块化规范</h3><p>CommonJS、AMD、CMD、 ES6的Moudels</p><h3 id="全局变量模块解决全局变量同名问题"><a href="#全局变量模块解决全局变量同名问题" class="headerlink" title="全局变量模块解决全局变量同名问题"></a>全局变量模块解决全局变量同名问题</h3><blockquote><p>aaa.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//模块对象</span><br><span class="hljs-keyword">var</span> moduleA = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">param</span>) </span>&#123;<br>  <span class="hljs-comment">//导出对象</span><br>  <span class="hljs-keyword">var</span> obj = &#123;&#125;<br>  <span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;小明&#x27;</span><br>  <span class="hljs-keyword">var</span> age = <span class="hljs-number">22</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">num1, num2</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> num1 + num2<br>  &#125;<br>  <span class="hljs-keyword">var</span> flag = <span class="hljs-literal">true</span><br>  <span class="hljs-keyword">if</span> (flag) &#123;<br>    <span class="hljs-built_in">console</span>.log(sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>))<br>  &#125;<br>  obj.flag=<span class="hljs-literal">false</span><br>  <span class="hljs-keyword">return</span> obj<br>&#125;)()<br></code></pre></td></tr></table></figure><blockquote><p>mmm.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//小明</span><br><span class="hljs-comment">//使用全局变量moduleA</span><br><span class="hljs-keyword">if</span>(moduleA.flag)&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;flag是true&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这样直接使用aaa.js导出的moduleA变量获取小明自己定义的<code>flag</code>。</p><h3 id="CommonJS的模块化实现"><a href="#CommonJS的模块化实现" class="headerlink" title="CommonJS的模块化实现"></a>CommonJS的模块化实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//CommonJS需要nodeJS支持</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;小明&#x27;</span><br><span class="hljs-keyword">var</span> age = <span class="hljs-number">22</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">num1, num2</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> num1 + num2<br>&#125;<br><span class="hljs-keyword">var</span> flag = <span class="hljs-literal">true</span><br><span class="hljs-keyword">if</span> (flag) &#123;<br>  <span class="hljs-built_in">console</span>.log(sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>))<br>&#125;<br><br><span class="hljs-comment">//导出对象</span><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  flag,<br>  sum<br>&#125;<br></code></pre></td></tr></table></figure><p>使用<code>module.exports = &#123;&#125;</code>导出需要的对象。</p><blockquote><p>mmm.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//导入对象,nodejs语法,需要node支持,从aaa.js取出对象</span><br><span class="hljs-keyword">var</span> &#123;flag,sum&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./aaa&quot;</span>)<br><br><span class="hljs-built_in">console</span>.log(sum(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>));<br><br><span class="hljs-keyword">if</span>(flag)&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;flag is true&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>var &#123;flag,sum&#125; = require(&quot;./aaa&quot;)</code>获取已经导出的对象中自己所需要的对象。</p><h3 id="ES6的模块化实现"><a href="#ES6的模块化实现" class="headerlink" title="ES6的模块化实现"></a>ES6的模块化实现</h3><p>​如何实现模块化，在html中需要使用<code>type=&#39;module&#39;</code>属性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;aaa.js&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;bbb.js&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;mmm.js&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>此时表示aaa.js是一个单独的模块，此模块是有作用域的。如果要使用aaa.js内的变量，需要在aaa.js中先导出变量，再在需要使用的地方导出变量。</p><h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;小明&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>使用</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;name&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./aaa.js&#x27;</span><br></code></pre></td></tr></table></figure><p><code>./aaa.js</code>表示aaa.js和mmm.js在同级目录。</p><p>如图打印结果。</p><h4 id="统一导出"><a href="#统一导出" class="headerlink" title="统一导出"></a>统一导出</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> age = <span class="hljs-number">22</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">num1, num2</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> num1 + num2<br>&#125;<br><span class="hljs-keyword">var</span> flag = <span class="hljs-literal">true</span><br><span class="hljs-keyword">if</span> (flag) &#123;<br>  <span class="hljs-built_in">console</span>.log(sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>))<br>&#125;<br><span class="hljs-comment">//2.最后统一导出</span><br><span class="hljs-keyword">export</span> &#123;<br>  flag,sum,age<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>使用<code>import &#123;name,flag,sum&#125; from &#39;./aaa.js&#39;</code>导入多个变量</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;name,flag,sum&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./aaa.js&#x27;</span><br><br><span class="hljs-built_in">console</span>.log(name)<br><br><span class="hljs-keyword">if</span>(flag)&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;小明是天才&quot;</span>);<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(sum(<span class="hljs-number">20</span>,<span class="hljs-number">30</span>));<br></code></pre></td></tr></table></figure><blockquote><p>使用{}将需要的变量放置进去</p></blockquote><h4 id="导出函数-类"><a href="#导出函数-类" class="headerlink" title="导出函数/类"></a>导出函数/类</h4><blockquote><p>在aaa.js中添加</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//3.导出函数/类</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">say</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(value);<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;奔跑&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在mmm.js中添加</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;name,flag,sum,say,Person&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./aaa.js&#x27;</span><br><br><span class="hljs-built_in">console</span>.log(name)<br><br><span class="hljs-keyword">if</span>(flag)&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;小明是天才&quot;</span>);<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(sum(<span class="hljs-number">20</span>,<span class="hljs-number">30</span>));<br><br>say(<span class="hljs-string">&#x27;hello&#x27;</span>)<br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> Person();<br>p.run();<br></code></pre></td></tr></table></figure><blockquote><p>如图</p></blockquote><p><img src="./images/14.4-3.png"></p><p>###默认导入 export default</p><blockquote><p>导出</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  flag,sum,age<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>导入</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//4.默认导入 export default</span><br><span class="hljs-keyword">import</span> aaa <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./aaa.js&#x27;</span><br><span class="hljs-built_in">console</span>.log(aaa.sum(<span class="hljs-number">10</span>,<span class="hljs-number">110</span>));<br></code></pre></td></tr></table></figure><blockquote><p>注意：使用默认导出会将所有需要导出的变量打包成一个对象，此时导出一个对象，此时我在<code>mmm.js</code>中导入变量时候命名为aaa，如果要调用变量需要使用aaa.变量。</p></blockquote><h3 id="统一全部导入"><a href="#统一全部导入" class="headerlink" title="统一全部导入"></a>统一全部导入</h3><blockquote><p>​    使用<code>import * as aaa from &#39;./aaa.js&#39;</code>统一全部导入</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 5.统一全部导入</span><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> aaa <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./aaa.js&#x27;</span><br><span class="hljs-built_in">console</span>.log(aaa.flag);<br><span class="hljs-built_in">console</span>.log(aaa.name);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>H5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-链表</title>
    <link href="/2020/03/24/LinkedList/"/>
    <url>/2020/03/24/LinkedList/</url>
    
    <content type="html"><![CDATA[<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表是一种非常常见的用于存储线数据的线性结构，链表和数组一样，可以用于存储一系列的元素，但链表和数组的实现机制完全不同</p><h3 id="链表和数组的缺点"><a href="#链表和数组的缺点" class="headerlink" title="链表和数组的缺点"></a>链表和数组的缺点</h3><p> 要存储多个元素，数组可能是最常用的数据结构，几乎每一种编程语言都有默认实现数组结构</p><p> <strong>数组的缺点</strong></p><ul><li><p>创建一个数组通常需要申请一段连续的内存的空间，并且大小是固定（大多数语言，所以当前数组不能满足容量的需求是，需要扩容（一般情况是申请一个更大的数组，比如2倍，然后将原数数组的元素复制过去）。</p></li><li><p>数组开头或者中间位置插入数据的成本很高，需要进行大量元素的位移</p></li></ul><p><strong>相对于数组，链表有哪些优点</strong></p><ul><li><p>内存空间不是必须连续的，可以充分利用好计算机的内存，实现灵活的内存动态管理</p></li><li><p>链表不必再创建时就确定大小，并且大小可以无限延伸下去</p></li><li><p>链表在插入和删除的数据时，时间复杂度可以达到O(1),相对数组效率高很多</p></li></ul><h3 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h3><p>单向链表(单链表)是链表的一种，它由节点组成，每个节点都包含下一个节点的指针，head指针指向第一个节点称为表头，而终止于最后一个指向nuLL的指针</p><h4 id="单向链表示意图"><a href="#单向链表示意图" class="headerlink" title="单向链表示意图"></a>单向链表示意图</h4><p><img src="/img/dataStructures/linklist.jpg"></p><p><strong>js单向链表节点Node封装</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 封装节点类</span><br>export <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-keyword">constructor</span>(<span class="hljs-keyword">data</span>) &#123;<br>      <span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span> = <span class="hljs-keyword">data</span>;<br>      <span class="hljs-keyword">this</span>.next = <span class="hljs-literal">null</span>;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p><strong>js单向链表封装</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 单向链表结构的封装</span><br> <span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span> </span>&#123;<br> <br>   <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>     <span class="hljs-comment">// 初始链表长度为 0</span><br>     <span class="hljs-built_in">this</span>.length = <span class="hljs-number">0</span>;<br> <br>     <span class="hljs-comment">// 初始 head 为 null，head 指向链表的第一个节点</span><br>     <span class="hljs-built_in">this</span>.head = <span class="hljs-literal">null</span>;<br>   &#125;<br> <br>   <span class="hljs-comment">// ------------ 链表的常见操作 ------------ //</span><br> <br>   <span class="hljs-comment">// append(data) 往链表尾部追加数据</span><br>   <span class="hljs-function"><span class="hljs-title">append</span>(<span class="hljs-params">data</span>)</span> &#123;<br>     <span class="hljs-comment">// 1、创建新节点</span><br>     <span class="hljs-keyword">const</span> newNode = <span class="hljs-keyword">new</span> Node(data);<br> <br>     <span class="hljs-comment">// 2、追加新节点</span><br>     <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.length === <span class="hljs-number">0</span>) &#123;<br>       <span class="hljs-comment">// 链表长度为 0 时，即只有 head 的时候</span><br>       <span class="hljs-built_in">this</span>.head = newNode;<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-comment">// 链表长度大于 0 时，在最后面添加新节点</span><br>       <span class="hljs-keyword">let</span> currentNode = <span class="hljs-built_in">this</span>.head;<br> <br>       <span class="hljs-comment">// 当 currentNode.next 不为空时，</span><br>       <span class="hljs-comment">// 循序依次找最后一个节点，即节点的 next 为 null 时</span><br>       <span class="hljs-keyword">while</span> (currentNode.next !== <span class="hljs-literal">null</span>) &#123;<br>         currentNode = currentNode.next;<br>       &#125;<br> <br>       <span class="hljs-comment">// 最后一个节点的 next 指向新节点</span><br>       currentNode.next = newNode;<br>     &#125;<br> <br>     <span class="hljs-comment">// 3、追加完新节点后，链表长度 + 1</span><br>     <span class="hljs-built_in">this</span>.length++;<br>   &#125;<br> <br>   <span class="hljs-comment">// insert(position, data) 在指定位置（position）插入节点</span><br>   <span class="hljs-function"><span class="hljs-title">insert</span>(<span class="hljs-params">position, data</span>)</span> &#123;<br>     <span class="hljs-comment">// position 新插入节点的位置</span><br>     <span class="hljs-comment">// position = 0 表示新插入后是第一个节点</span><br>     <span class="hljs-comment">// position = 1 表示新插入后是第二个节点，以此类推</span><br> <br>     <span class="hljs-comment">// 1、对 position 进行越界判断，不能小于 0 或大于链表长度</span><br>     <span class="hljs-keyword">if</span> (position &lt; <span class="hljs-number">0</span> || position &gt; <span class="hljs-built_in">this</span>.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br> <br>     <span class="hljs-comment">// 2、创建新节点</span><br>     <span class="hljs-keyword">const</span> newNode = <span class="hljs-keyword">new</span> Node(data);<br> <br>     <span class="hljs-comment">// 3、插入节点</span><br>     <span class="hljs-keyword">if</span> (position === <span class="hljs-number">0</span>) &#123;<br>       <span class="hljs-comment">// position = 0 的情况</span><br>       <span class="hljs-comment">// 让新节点的 next 指向 原来的第一个节点，即 head</span><br>       newNode.next = <span class="hljs-built_in">this</span>.head;<br> <br>       <span class="hljs-comment">// head 赋值为 newNode</span><br>       <span class="hljs-built_in">this</span>.head = newNode;<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-comment">// 0 &lt; position &lt;= length 的情况</span><br> <br>       <span class="hljs-comment">// 初始化一些变量</span><br>       <span class="hljs-keyword">let</span> currentNode = <span class="hljs-built_in">this</span>.head; <span class="hljs-comment">// 当前节点初始化为 head</span><br>       <span class="hljs-keyword">let</span> previousNode = <span class="hljs-literal">null</span>; <span class="hljs-comment">// head 的 上一节点为 null</span><br>       <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; <span class="hljs-comment">// head 的 index 为 0</span><br> <br>       <span class="hljs-comment">// 在 0 ~ position 之间遍历，不断地更新 currentNode 和 previousNode</span><br>       <span class="hljs-comment">// 直到找到要插入的位置</span><br>       <span class="hljs-keyword">while</span> (index++ &lt; position) &#123;<br>         previousNode = currentNode;<br>         currentNode = currentNode.next;<br>       &#125;<br> <br>       <span class="hljs-comment">// 在当前节点和当前节点的上一节点之间插入新节点，即它们的改变指向</span><br>       newNode.next = currentNode;<br>       previousNode.next = newNode;<br>     &#125;<br> <br>     <span class="hljs-comment">// 更新链表长度</span><br>     <span class="hljs-built_in">this</span>.length++;<br>     <span class="hljs-keyword">return</span> newNode;<br>   &#125;<br> <br>   <span class="hljs-comment">// getData(position) 获取指定位置的 data</span><br>   <span class="hljs-function"><span class="hljs-title">getData</span>(<span class="hljs-params">position</span>)</span> &#123;<br>     <span class="hljs-comment">// 1、position 越界判断</span><br>     <span class="hljs-keyword">if</span> (position &lt; <span class="hljs-number">0</span> || position &gt;= <span class="hljs-built_in">this</span>.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br> <br>     <span class="hljs-comment">// 2、获取指定 position 节点的 data</span><br>     <span class="hljs-keyword">let</span> currentNode = <span class="hljs-built_in">this</span>.head;<br>     <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br> <br>     <span class="hljs-keyword">while</span> (index++ &lt; position) &#123;<br>       currentNode = currentNode.next;<br>     &#125;<br> <br>     <span class="hljs-comment">// 3、返回 data</span><br>     <span class="hljs-keyword">return</span> currentNode.data;<br>   &#125;<br> <br>   <span class="hljs-comment">// indexOf(data) 返回指定 data 的 index，如果没有，返回 -1。</span><br>   <span class="hljs-function"><span class="hljs-title">indexOf</span>(<span class="hljs-params">data</span>)</span> &#123;<br>     <span class="hljs-keyword">let</span> currentNode = <span class="hljs-built_in">this</span>.head;<br>     <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br> <br>     <span class="hljs-keyword">while</span> (currentNode) &#123;<br>       <span class="hljs-keyword">if</span> (currentNode.data === data) &#123;<br>         <span class="hljs-keyword">return</span> index;<br>       &#125;<br>       currentNode = currentNode.next;<br>       index++;<br>     &#125;<br> <br>     <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>   &#125;<br> <br>   <span class="hljs-comment">// update(position, data) 修改指定位置节点的 data</span><br>   <span class="hljs-function"><span class="hljs-title">update</span>(<span class="hljs-params">position, data</span>)</span> &#123;<br>     <span class="hljs-comment">// 涉及到 position 都要进行越界判断</span><br>     <span class="hljs-comment">// 1、position 越界判断</span><br>     <span class="hljs-keyword">if</span> (position &lt; <span class="hljs-number">0</span> || position &gt;= <span class="hljs-built_in">this</span>.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br> <br>     <span class="hljs-comment">// 2、痛过循环遍历，找到指定 position 的节点</span><br>     <span class="hljs-keyword">let</span> currentNode = <span class="hljs-built_in">this</span>.head;<br>     <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">while</span> (index++ &lt; position) &#123;<br>       currentNode = currentNode.next;<br>     &#125;<br> <br>     <span class="hljs-comment">// 3、修改节点 data</span><br>     currentNode.data = data;<br> <br>     <span class="hljs-keyword">return</span> currentNode;<br>   &#125;<br> <br>   <span class="hljs-comment">// removeAt(position) 删除指定位置的节点，并返回删除的那个节点</span><br>   <span class="hljs-function"><span class="hljs-title">removeAt</span>(<span class="hljs-params">position</span>)</span> &#123;<br>     <span class="hljs-comment">// 1、position 越界判断</span><br>     <span class="hljs-keyword">if</span> (position &lt; <span class="hljs-number">0</span> || position &gt;= <span class="hljs-built_in">this</span>.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br> <br>     <span class="hljs-comment">// 2、删除指定 position 节点</span><br>     <span class="hljs-keyword">let</span> currentNode = <span class="hljs-built_in">this</span>.head;<br>     <span class="hljs-keyword">if</span> (position === <span class="hljs-number">0</span>) &#123;<br>       <span class="hljs-comment">// position = 0 的情况</span><br>       <span class="hljs-built_in">this</span>.head = <span class="hljs-built_in">this</span>.head.next;<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-comment">// position &gt; 0 的情况</span><br>       <span class="hljs-comment">// 通过循环遍历，找到指定 position 的节点，赋值到 currentNode</span><br> <br>       <span class="hljs-keyword">let</span> previousNode = <span class="hljs-literal">null</span>;<br>       <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br> <br>       <span class="hljs-keyword">while</span> (index++ &lt; position) &#123;<br>         previousNode = currentNode;<br>         currentNode = currentNode.next;<br>       &#125;<br> <br>       <span class="hljs-comment">// 巧妙之处，让上一节点的 next 指向到当前的节点的 next，相当于删除了当前节点。</span><br>       previousNode.next = currentNode.next;<br>     &#125;<br> <br>     <span class="hljs-comment">// 3、更新链表长度 -1</span><br>     <span class="hljs-built_in">this</span>.length--;<br> <br>     <span class="hljs-keyword">return</span> currentNode;<br>   &#125;<br> <br>   <span class="hljs-comment">// remove(data) 删除指定 data 的节点，并返回删除的那个节点</span><br>   <span class="hljs-function"><span class="hljs-title">remove</span>(<span class="hljs-params">data</span>)</span> &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.removeAt(<span class="hljs-built_in">this</span>.indexOf(data));<br>   &#125;<br> <br>   <span class="hljs-comment">// isEmpty() 判断链表是否为空</span><br>   <span class="hljs-function"><span class="hljs-title">isEmpty</span>(<span class="hljs-params"></span>)</span> &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.length === <span class="hljs-number">0</span>;<br>   &#125;<br> <br>   <span class="hljs-comment">// size() 获取链表的长度</span><br>   <span class="hljs-function"><span class="hljs-title">size</span>(<span class="hljs-params"></span>)</span> &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.length;<br>   &#125;<br> <br>   <span class="hljs-comment">// toString() 链表数据以字符串形式返回</span><br>   <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span> &#123;<br>     <span class="hljs-keyword">let</span> currentNode = <span class="hljs-built_in">this</span>.head;<br>     <span class="hljs-keyword">let</span> result = <span class="hljs-string">&#x27;&#x27;</span>;<br> <br>     <span class="hljs-comment">// 遍历所有的节点，拼接为字符串，直到节点为 null</span><br>     <span class="hljs-keyword">while</span> (currentNode) &#123;<br>       result += currentNode.data + <span class="hljs-string">&#x27; &#x27;</span>;<br>       currentNode = currentNode.next;<br>     &#125;<br> <br>     <span class="hljs-keyword">return</span> result;<br>   &#125;<br> &#125;<br> <br></code></pre></td></tr></table></figure><h3 id="链表翻转（常见面试问题）"><a href="#链表翻转（常见面试问题）" class="headerlink" title="链表翻转（常见面试问题）"></a>链表翻转（常见面试问题）</h3><h4 id="递归翻转"><a href="#递归翻转" class="headerlink" title="递归翻转"></a>递归翻转</h4><p><img src="/img/dataStructures/digulinklist.png"></p><p>具体代码实现</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-keyword">function</span> reversList<span class="hljs-built_in">(head</span>) &#123;<br>    //设置递归出口<br>  <span class="hljs-keyword">if</span><span class="hljs-built_in">(head</span> == null ||<span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span> == null) &#123;<br>      <span class="hljs-keyword">return</span><span class="hljs-built_in"> head</span><br>  &#125;<br>   <span class="hljs-keyword">let</span> newNode = reversList<span class="hljs-built_in">(head</span>.<span class="hljs-keyword">next</span>)<br>  <span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span> =<span class="hljs-built_in"> head</span> // <span class="hljs-number">4</span> -&gt; <span class="hljs-number">5</span><br>  <span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span> = null // <span class="hljs-number">5</span> -&gt; null<br>  <span class="hljs-keyword">return</span> newHead<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="迭代翻转"><a href="#迭代翻转" class="headerlink" title="迭代翻转"></a>迭代翻转</h4><p><img src="/img/dataStructures/diedailinklist.png"></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reversList</span></span>(head) &#123;<br>  <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> head<br>  &#125;<br>   let <span class="hljs-keyword">new</span><span class="hljs-type">Head</span> = <span class="hljs-literal">null</span> <br>   <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">null</span>) &#123;<br>       let tmp = head.next<br>       head.next = <span class="hljs-keyword">new</span><span class="hljs-type">Head</span><br><span class="hljs-type"></span>       <span class="hljs-keyword">new</span><span class="hljs-type">Head</span> = head<br>       head = tmp<br>   &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span><span class="hljs-type">Head</span><br><span class="hljs-type"></span>&#125;<br></code></pre></td></tr></table></figure><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>双向链表顾名思义，就是链表由单向的链变成了双向链。 使用这种数据结构，我们可以不再拘束于单链表的单向创建于遍历等操作，大大减少了在使用中存在的问题</p><h4 id="双向链表示意图"><a href="#双向链表示意图" class="headerlink" title="双向链表示意图"></a>双向链表示意图</h4><p><img src="/img/dataStructures/doublinklist.png"></p><h4 id="双向链表的特点"><a href="#双向链表的特点" class="headerlink" title="双向链表的特点"></a>双向链表的特点</h4><ul><li><p>可以使用一个head 和一个 tail 分别指向头部和尾部的特点</p></li><li><p>每个节点都有三部分注册 前一个节点的指针（prev),data,后一个节点指针（next）</p></li><li><p>双向链表的第一个节点的prev是null</p></li><li><p>双向链表的最后的节点的next是null</p></li></ul><h4 id="js-双向链表封装"><a href="#js-双向链表封装" class="headerlink" title="js 双向链表封装"></a>js 双向链表封装</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//继承单节点</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoublyNode</span> <span class="hljs-title">extends</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-keyword">constructor</span>(element) &#123;<br>        <span class="hljs-keyword">super</span>(element)<br>        <span class="hljs-keyword">this</span>.prev = <span class="hljs-literal">null</span> <br>    &#125;<br>&#125;<br><br>export <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoublyLinkList</span> <span class="hljs-title">extends</span> <span class="hljs-title">LinkedList</span> </span>&#123;<br>   <span class="hljs-keyword">constructor</span>() &#123;<br>       <span class="hljs-keyword">super</span>()<br>       <span class="hljs-keyword">this</span>.tail = <span class="hljs-literal">null</span><br>   &#125;<br>   <span class="hljs-comment">//拼接节点</span><br>    append(element) &#123;<br>        <span class="hljs-keyword">const</span> newNode = DoublyNode(element)<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">this</span>.head  = newNode<br>            <span class="hljs-keyword">this</span>.tail = newNode<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">this</span>.tail.next = newNode<br>            newNode.prev = <span class="hljs-keyword">this</span>.tail<br>            <span class="hljs-keyword">this</span>.tail = newNode<br>        &#125;<br>        <span class="hljs-keyword">this</span>.length++<br>    &#125;<br>    <span class="hljs-comment">//插入节点</span><br>    insert(position,element) &#123;<br>     <span class="hljs-keyword">if</span> (position &lt; <span class="hljs-number">0</span> || position &gt; <span class="hljs-keyword">this</span>.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      <span class="hljs-keyword">const</span> newNode = DoublyNode(element)<br>      <span class="hljs-keyword">if</span> (position ===  <span class="hljs-number">0</span>) &#123;<br>         <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">this</span>.head = newNode<br>            <span class="hljs-keyword">this</span>.tail = newNode<br>         &#125;<span class="hljs-keyword">else</span>&#123;<br>             newNode.next = <span class="hljs-keyword">this</span>.head<br>             <span class="hljs-keyword">this</span>.head.prev = newNode<br>             <span class="hljs-keyword">this</span>.head = newNode<br>         &#125;<br>         <br>      &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (position ==   <span class="hljs-keyword">this</span>.length)&#123;<br>        <span class="hljs-keyword">this</span>.tail.next = newNode;<br>        newNode.prev = <span class="hljs-keyword">this</span>.tail<br>        <span class="hljs-keyword">this</span>.tail = newNode<br>      &#125;<span class="hljs-keyword">else</span> &#123;<br>          let index = <span class="hljs-number">0</span><br>          let currrent = <span class="hljs-keyword">this</span>.head<br>          let preverd  = <span class="hljs-literal">null</span><br>          <span class="hljs-keyword">while</span>(index++ &lt; position) &#123;<br>              preverd = currrent<br>              currrent = currrent.next<br>          &#125;<br>          newNode.prev = preverd<br>          preverd.next = newNode<br><br>          newNode.next = currrent<br>          currrent.prev  = newNode<br>      &#125;<br><br>      <span class="hljs-keyword">this</span>.length++<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-comment">//删除节点</span><br>    removeAt(position) &#123;<br>        <span class="hljs-keyword">if</span> (position &lt; <span class="hljs-number">0</span> || position &gt; <span class="hljs-keyword">this</span>.length - <span class="hljs-number">1</span>)  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        let currrent = <span class="hljs-keyword">this</span>.head<br>        <span class="hljs-keyword">if</span> (position === <span class="hljs-number">0</span> ) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.length === <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">this</span>.head = <span class="hljs-literal">null</span><br>                <span class="hljs-keyword">this</span>.tail = <span class="hljs-literal">null</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">this</span>.head = <span class="hljs-keyword">this</span>.head.next<br>                <span class="hljs-keyword">this</span>.head.prev = <span class="hljs-literal">null</span><br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (position === <span class="hljs-keyword">this</span>.length - <span class="hljs-number">1</span>) &#123;<br>           currrent = <span class="hljs-keyword">this</span>.tail<br>           <span class="hljs-keyword">this</span>.tail = <span class="hljs-keyword">this</span>.tail.prev<br>           <span class="hljs-keyword">this</span>.tail.next = <span class="hljs-literal">null</span><br>         <br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            let index = <span class="hljs-number">0</span><br>            let preverd  = <span class="hljs-literal">null</span><br>            <span class="hljs-keyword">while</span>(index++ &lt; position) &#123;<br>                preverd = currrent<br>                currrent = currrent.next<br>            &#125;<br>            preverd.next = currrent.next<br>            currrent.next.prev = preverd<br>        &#125;<br><br>        <span class="hljs-keyword">this</span>.length--<br>        <span class="hljs-keyword">return</span> currrent.element<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>datastructure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-队列</title>
    <link href="/2020/03/23/Queue/"/>
    <url>/2020/03/23/Queue/</url>
    
    <content type="html"><![CDATA[<h3 id="队列介绍"><a href="#队列介绍" class="headerlink" title="队列介绍"></a>队列介绍</h3><p>队列是一种特殊的线性表，先进先出（FIFO），特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列</p><h4 id="队列示意图"><a href="#队列示意图" class="headerlink" title="队列示意图"></a>队列示意图</h4><p><img src="/img/dataStructures/queue.jpg"></p><h4 id="js-队列封装"><a href="#js-队列封装" class="headerlink" title="js 队列封装"></a>js 队列封装</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs javascript">/ 队列结构的封装<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Queue</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.items = [];<br>  &#125;<br><br>  <span class="hljs-comment">// enqueue(item) 入队，将元素加入到队列中</span><br>  <span class="hljs-function"><span class="hljs-title">enqueue</span>(<span class="hljs-params">item</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.items.push(item);<br>  &#125;<br><br>  <span class="hljs-comment">// dequeue() 出队，从队列中删除队头元素，返回删除的那个元素</span><br>  <span class="hljs-function"><span class="hljs-title">dequeue</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items.shift();<br>  &#125;<br><br>  <span class="hljs-comment">// front() 查看队列的队头元素</span><br>  <span class="hljs-function"><span class="hljs-title">front</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items[<span class="hljs-number">0</span>];<br>  &#125;<br><br>  <span class="hljs-comment">// isEmpty() 查看队列是否为空</span><br>  <span class="hljs-function"><span class="hljs-title">isEmpty</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items.length === <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// size() 查看队列中元素的个数</span><br>  <span class="hljs-function"><span class="hljs-title">size</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items.length;<br>  &#125;<br><br>  <span class="hljs-comment">// toString() 将队列中的元素以字符串形式返回</span><br>  <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> <span class="hljs-built_in">this</span>.items) &#123;<br>      result += item + <span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="击鼓传花问题-（队列使用）"><a href="#击鼓传花问题-（队列使用）" class="headerlink" title="击鼓传花问题 （队列使用）"></a>击鼓传花问题 （队列使用）</h4><ul><li><p>题目：几个朋友一起玩一个游戏，围城一个圆圈，开始数数，疏导某个数字的自动淘汰，最后剩下的那个人会取得胜利</p></li><li><p>封装一个基于队列的函数，参数是人名字，基于数字，结果是最终剩下的一人的姓名</p></li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 利用队列结构的特点实现击鼓传花游戏求解方法的封装</span><br><span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> function <span class="hljs-title">passGame</span><span class="hljs-params">(nameList, number)</span> </span>&#123;<br>  <span class="hljs-comment">// 1、new 一个 Queue 对象</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-built_in">queue</span> = <span class="hljs-keyword">new</span> Queue();<br><br>  <span class="hljs-comment">// 2、将 nameList 里面的每一个元素入队</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> name of nameList) &#123;<br>    <span class="hljs-built_in">queue</span>.enqueue(name);<br>  &#125;<br><br>  <span class="hljs-comment">// 3、开始数数</span><br>  <span class="hljs-comment">// 队列中只剩下 1 个元素时就停止数数</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-built_in">queue</span>.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">// 不是 number 时，重新加入到队尾</span><br>    <span class="hljs-comment">// 是 number 时，将其删除</span><br><br>    <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; number - <span class="hljs-number">1</span>; i++) &#123;<br>      <span class="hljs-comment">// number 数字之前的人重新放入到队尾（即把队头删除的元素，重新加入到队列中）</span><br>      <span class="hljs-built_in">queue</span>.enqueue(<span class="hljs-built_in">queue</span>.dequeue());<br>    &#125;<br><br>    <span class="hljs-comment">// number 对应这个人，直接从队列中删除</span><br>    <span class="hljs-comment">// 由于队列没有像数组一样的下标值不能直接取到某一元素，</span><br>    <span class="hljs-comment">// 所以采用，把 number 前面的 number - 1 个元素先删除后添加到队列末尾，</span><br>    <span class="hljs-comment">// 这样第 number 个元素就排到了队列的最前面，可以直接使用 dequeue 方法进行删除</span><br>    <span class="hljs-built_in">queue</span>.dequeue();<br>  &#125;<br><br>  <span class="hljs-comment">// 4、获取最后剩下的那个人</span><br>  <span class="hljs-keyword">const</span> endName = <span class="hljs-built_in">queue</span>.front();<br><br>  <span class="hljs-comment">// 5、返回这个人在原数组中对应的索引</span><br>  <span class="hljs-keyword">return</span> nameList.indexOf(endName);<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>datastructure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-栈</title>
    <link href="/2020/03/23/Stack/"/>
    <url>/2020/03/23/Stack/</url>
    
    <content type="html"><![CDATA[<h3 id="栈的介绍"><a href="#栈的介绍" class="headerlink" title="栈的介绍"></a>栈的介绍</h3><p>它是一种运算受限的线性表后进先出（LFIO）。限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素</p><h4 id="栈的示意图"><a href="#栈的示意图" class="headerlink" title="栈的示意图"></a>栈的示意图</h4><p><img src="/img/dataStructures/stack.png"></p><h4 id="栈题目"><a href="#栈题目" class="headerlink" title="栈题目"></a>栈题目</h4><p><strong>根据六个元素6,5,4,3,2,1的顺序进栈哪一个不是合法出栈的序列</strong></p><p>A 5,4,3,6,1,2   </p><p>B 4,5,3,2,1,6  </p><p>C 3,4,6,5,2,1  </p><p>D 2,3,4,1,5,6</p><p>答案是 c</p><ul><li><p>A 65入5出，4入4出 3入3出 6出 21入 1出 2出</p></li><li><p>B 65入4出5出 3入3出 2入2出 1入1出 6出</p></li><li><p>C 6543入 3 出 4出 应该是5出 所以不符合</p></li><li><p>D 65432入 2出 3出 4出 1入1出 5出 6出</p></li></ul><p><strong>十进制 转化成二进制</strong></p><p>js 根据数组封装一个栈</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.items = []<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">push</span>(<span class="hljs-params">element</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.items.push(element)<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-title">pop</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items.pop()<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">peek</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items[<span class="hljs-built_in">this</span>.items.length-<span class="hljs-number">1</span>]<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">isEmpty</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items.length === <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">size</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items.length<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体方法实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dec2bin</span>(<span class="hljs-params">num</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> stack = <span class="hljs-keyword">new</span> Stack()<br>    <span class="hljs-comment">// 循环取余数</span><br>    <span class="hljs-keyword">while</span>(num &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">let</span> remainder = num % <span class="hljs-number">2</span><br>        num = <span class="hljs-built_in">Math</span>.floor(num / <span class="hljs-number">2</span>)<br>        stack.push(remainder)<br>    &#125;<br>    <span class="hljs-comment">// 拼接字符串</span><br>    <span class="hljs-keyword">let</span> binString = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">while</span>(!stack.isEmpty()) &#123;<br>        binString += stack.pop()<br>    &#125;<br>    <span class="hljs-keyword">return</span> binString<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>datastructure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2020/02/16/Git/"/>
    <url>/2020/02/16/Git/</url>
    
    <content type="html"><![CDATA[<h3 id="Git介绍"><a href="#Git介绍" class="headerlink" title="Git介绍"></a>Git介绍</h3><p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。<br>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。<br>Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持</p><h3 id="git安装（mac）"><a href="#git安装（mac）" class="headerlink" title="git安装（mac）"></a>git安装（mac）</h3><p>Mac的终端上输入git检测是否安装git</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>t-scm.com/downloads<br><br></code></pre></td></tr></table></figure><p>安装完成之后查看git版本</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">git <span class="hljs-comment">--version</span><br><br></code></pre></td></tr></table></figure><p>创建一个全局用户名、全局邮箱作为配置信息</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog">git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> user<span class="hljs-variable">.name</span> <span class="hljs-string">&quot;your_name&quot;</span>  <br>git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> user<span class="hljs-variable">.email</span> <span class="hljs-string">&quot;your_email@youremail.com&quot;</span><br><br></code></pre></td></tr></table></figure><h3 id="git-本地仓库创建"><a href="#git-本地仓库创建" class="headerlink" title="git 本地仓库创建"></a>git 本地仓库创建</h3><p>打开终端</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-meta"><span class="hljs-meta-keyword">$cd</span> 某一个文件夹下</span><br><span class="hljs-symbol">$</span> git init<br><span class="hljs-symbol">$</span> git add .<br><span class="hljs-symbol">$</span> git commit -m <span class="hljs-string">&#x27;初始化项目版本&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="如果远端已有仓库"><a href="#如果远端已有仓库" class="headerlink" title="如果远端已有仓库"></a>如果远端已有仓库</h4><p>使用命令<br>$git remote add origin 添加远端仓库<br>$git push -u origin master 推送到远端仓库</p><h3 id="工作区域"><a href="#工作区域" class="headerlink" title="工作区域"></a>工作区域</h3><p>git本地有三个工作区域：工作目录 (working) 、暂存区(stage)、本地仓（local rep,如果添加远端git仓（Rmmote）</p><p><img src="/img/ittree/gitimg/gitwork.png"></p><h4 id="git-常用六个命令"><a href="#git-常用六个命令" class="headerlink" title="git 常用六个命令"></a>git 常用六个命令</h4><ul><li><p>git add file: 本地文件添加到暂存区</p></li><li><p>git commit: 提交到本地仓库</p></li><li><p>git push: 推送到远端仓库</p></li><li><p>git pull: 拉取远端分支内容</p></li><li><p>git reset: 撤销提交内容</p></li><li><p>git checkout: 撤销缓存内容</p></li></ul><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>切出分支命令</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> checkout -<span class="hljs-keyword">b</span> dev<br><br></code></pre></td></tr></table></figure><p>创建项目时，会针对不同环境创建三个常设分支</p><ul><li><p>master: 主分支发布版本不轻易修改</p></li><li><p>dev: 功能开发分支</p></li><li><p>test: 测试分支，提交给测试部门</p></li></ul><p><img src="/img/ittree/gitimg/gitliucheng.png"></p><h3 id="git-撤销回滚"><a href="#git-撤销回滚" class="headerlink" title="git 撤销回滚"></a>git 撤销回滚</h3><h4 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h4><p><strong>文件被修改了，但未执行git add操作</strong></p><ul><li><p> git checkout – fliename  某个文件名</p></li><li><p>  git checkout – .   将多个文件一次性撤销可以用</p></li></ul><p><strong>已经添加到暂存区域，从暂存区撤销</strong></p><ul><li><p>git reset HEAD filename 撤销某个</p></li><li><p>git reset HEAD 多个撤销</p></li></ul><p><strong>commit之后，想要撤销到某个版本</strong></p><ol><li><p>git log查看提交记录</p></li><li><p>git  reset –hard  commit_id</p></li></ol><h4 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h4><p><strong>回滚一次错误的合并</strong></p><ol><li><p>git branch backup 备份一个</p></li><li><p>git push origin backup: backup 推送到远端</p></li><li><p>git reset –hard xxxxx 本地仓库彻底回退到xxxxx版本，xxxxx版本之后的commit信息将丢失</p></li><li><p>git push origin :master 删除对应远端分支</p></li><li><p>git push origin master 重新创建远端分支</p></li></ol><p>git revert<br><strong>是回滚某个 commit ，不是回滚“到”某个</strong></p><p>如果错误的修改已经不是最新的commit，回退某次提交的上一步，用git revert。并且会生成一个新的提交来撤销某次提交，此次提交之前的commit都会被保留。</p><p>比如：a操作添加了“haha”，commit了a，b操作添加了“xixi”，commit b。现在想回滚到只添加了“haha”，需要的是删除“xixi”，也就是逆向操作b，所以应该<code>git revert b的commit_id</code>。 <code>git revert</code> 应该翻译成“反转、逆转”比较好理解，而不是回退</p><p>git reset<br>删除commit 之前提交的内容 </p>]]></content>
    
    
    <categories>
      
      <category>ItTree</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络相关</title>
    <link href="/2020/02/15/network/"/>
    <url>/2020/02/15/network/</url>
    
    <content type="html"><![CDATA[<h3 id="概括-http协议-、https网络安全、tcp-upd、DNS解析、Session-Cookie"><a href="#概括-http协议-、https网络安全、tcp-upd、DNS解析、Session-Cookie" class="headerlink" title="概括: http协议 、https网络安全、tcp/upd、DNS解析、Session/Cookie"></a>概括: http协议 、https网络安全、tcp/upd、DNS解析、Session/Cookie</h3><h3 id="网络七层协议"><a href="#网络七层协议" class="headerlink" title="网络七层协议"></a>网络七层协议</h3><p><img src="/img/ittree/network/networkqc.png"></p><h3 id="http协议介绍"><a href="#http协议介绍" class="headerlink" title="http协议介绍"></a>http协议介绍</h3><p>HTTP协议（HyperText Transfer Protocol，超文本传输协议）是因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。<br>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等</p><h4 id="http请求报文"><a href="#http请求报文" class="headerlink" title="http请求报文"></a>http请求报文</h4><p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式</p><p><img src="/img/ittree/network/httprequset.png"></p><h4 id="http-响应报文"><a href="#http-响应报文" class="headerlink" title="http 响应报文"></a>http 响应报文</h4><p>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文</p><p><img src="/img/ittree/network/httprsp.jpg"></p><h4 id="http-请求方法"><a href="#http-请求方法" class="headerlink" title="http 请求方法"></a>http 请求方法</h4><p>get、post、head、options、put、delete 等</p><h4 id="GET-和POST方式的区别"><a href="#GET-和POST方式的区别" class="headerlink" title="GET 和POST方式的区别"></a>GET 和POST方式的区别</h4><ul><li><p>get请求参数以？分割拼接到URL后面，POST请求参数在body里面</p></li><li><p>get参数长度限制2048个字符，post一般没有改限制</p></li><li><p>get请求不安全， post请求比较安全</p></li></ul><p>从语义角度来回答</p><p>get  是获取资源 安全的 幂等的 可缓存的</p><p>post 是处理资源 非安全 非幂等的 不可缓存</p><p>安全性: 不应该引起server端的任何状态变化</p><p>幂等性: 同一个请求方法执行多次和执行一次的效果完全相同</p><h3 id="tcp连接-三次握手-四次挥手"><a href="#tcp连接-三次握手-四次挥手" class="headerlink" title="tcp连接 三次握手 四次挥手"></a>tcp连接 三次握手 四次挥手</h3><p>如图</p><p><img src="/img/ittree/network/tcplink.png"></p><h4 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h4><p>为了防止服务器端开启一些无用的连接增加服务器开销以及防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p><p>由于网络传输是有延时的(要通过网络光纤和各种中间代理服务器)，在传输的过程中，比如客户端发起了SYN=1创建连接的请求(第一次握手)。</p><p>如果服务器端就直接创建了这个连接并返回包含SYN、ACK和Seq等内容的数据包给客户端，这个数据包因为网络传输的原因丢失了，丢失之后客户端就一直没有接收到服务器返回的数据包。</p><p>客户端可能设置了一个超时时间，时间到了就关闭了连接创建的请求。再重新发出创建连接的请求，而服务器端是不知道的，如果没有第三次握手告诉服务器端客户端收的到服务器端传输的数据的话，</p><p>服务器端是不知道客户端有没有接收到服务器端返回的信息的</p><h4 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h4><p>TCP释放连接时之所以需要“四次挥手”,是因为FIN释放连接报文与ACK确认接收报文是分别由第二次和第三次”握手”传输的。为何建立连接时一起传输，释放连接时却要分开传输？</p><p>建立连接时，被动方服务器端结束CLOSED阶段进入“握手”阶段并不需要任何准备，可以直接返回SYN和ACK报文，开始建立连接。<br>释放连接时，被动方服务器，突然收到主动方客户端释放连接的请求时并不能立即释放连接，因为还有必要的数据需要处理，所以服务器先返回ACK确认收到报文，经过CLOSE-WAIT阶段准备好释放连接之后，才能返回FIN释放连接报文</p><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><h4 id="https-介绍"><a href="#https-介绍" class="headerlink" title="https 介绍"></a>https 介绍</h4><p>基于HTTP协议，通过SSL或TLS提供加密处理数据、验证对方身份以及数据完整性保护</p><h4 id="https-连接过程"><a href="#https-连接过程" class="headerlink" title="https 连接过程"></a>https 连接过程</h4><p><img src="/img/ittree/network/ssl.png"></p><p>客户端会发送给服务端一个加密算法的列表，tsl版本号 随机数c ,然后服务端再回给客户端<br>一个ssl证书和商定的加密算法，首先通过非对称加密进行对称加密密钥的传输，之后https之间的<br>网络请求就通过被非对称加密所保护的对称密钥进后续网络访问</p><h4 id="https都使用了什么加密手段"><a href="#https都使用了什么加密手段" class="headerlink" title="https都使用了什么加密手段"></a>https都使用了什么加密手段</h4><ul><li><p>建立连接过程使用非对称加密，非对称加密很耗时</p></li><li><p>后续通信过程使用对称加密</p></li></ul><h3 id="tcp-upd"><a href="#tcp-upd" class="headerlink" title="tcp upd"></a>tcp upd</h3><p>TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP</p><ul><li><p>TCP面向连接; UDP是无连接 的，即发送数据之前不需要建立连接</p></li><li><p>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付</p></li><li><p>tcp 连接是 1对1,UDP支持一对一，一对多，多对一和多对多的交互通信</p></li></ul><h4 id="tcp-特点"><a href="#tcp-特点" class="headerlink" title="tcp 特点"></a>tcp 特点</h4><p>面向连接 可靠传输 面向字节流 流量控制 拥塞控制</p><p>可靠传输 停止等待协议</p><p> 无差错情况 超时重传 确认丢失 确认迟到</p><p>面向字节流</p><p><img src="/img/ittree/network/bit.png"></p><p>流量控制 滑动窗口协议</p><p><img src="/img/ittree/network/chuankou.png"></p><p>拥塞控制</p><p>慢开始、拥塞避免<br>快恢复、快重传</p><p><img src="/img/ittree/network/yongse.png"></p><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>域名到IP地址的映射，DNS解析请求采用UDP数据包且明文</p><p><img src="/img/ittree/network/dns.png"></p><h4 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h4><h4 id="DNS劫持与HTTP的关系是怎样的？"><a href="#DNS劫持与HTTP的关系是怎样的？" class="headerlink" title="DNS劫持与HTTP的关系是怎样的？"></a>DNS劫持与HTTP的关系是怎样的？</h4><p> 没有关系，DNS解析发生在http建立连接之前，DNS解析请求使用UDP数据包，端口是 53</p><h4 id="怎样解决DNS-劫持"><a href="#怎样解决DNS-劫持" class="headerlink" title="怎样解决DNS 劫持"></a>怎样解决DNS 劫持</h4><ul><li>httpNDS </li><li>长连接</li></ul><p>httpDNS: 使用http协议向DNS服务器的80端口进行请求</p><p>长连接：通过长连接通道向 apiserver请求</p><h3 id="session-cookie"><a href="#session-cookie" class="headerlink" title="session/cookie"></a>session/cookie</h3><p>http协议是无状态的，使用 session 和 cookie 作为补偿</p><h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><p>cookie 主要用来记录用户状态，区分用户，状态保存在客户端</p><p>怎样修改cookie?</p><ul><li><p>新cooki覆盖旧cookie</p></li><li><p>覆盖规则: name、path、domain等需要与原cookie一致</p></li></ul><p>怎样删除cookie?</p><p>设置 cookie的expires= 过去的一个时间点，或者maxage= 0</p><h4 id="session"><a href="#session" class="headerlink" title="session"></a>session</h4><p>sessoin 和 cookie的关系是怎样的？</p><ul><li>session需要依赖于cooKie机制</li></ul><p><img src="/img/ittree/network/session.png"></p>]]></content>
    
    
    <categories>
      
      <category>ItTree</category>
      
    </categories>
    
    
    <tags>
      
      <tag>basic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Runloop</title>
    <link href="/2019/12/17/iOS-Runloop/"/>
    <url>/2019/12/17/iOS-Runloop/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是Runloop"><a href="#什么是Runloop" class="headerlink" title="什么是Runloop"></a>什么是Runloop</h3><p>从语义角度 runloop 是通过内部事件循环来处理事件/消息的一个对象</p><ul><li><p>没有消息需要处理时，休眠避免占用资源 （用户态 到 核心态）</p></li><li><p>有消息处理时，立刻被唤醒 （核心态到用户态）</p></li></ul><h4 id="为什么main-函数为什么能够保持一直-运行的状态而不退出？"><a href="#为什么main-函数为什么能够保持一直-运行的状态而不退出？" class="headerlink" title="为什么main 函数为什么能够保持一直 运行的状态而不退出？"></a>为什么main 函数为什么能够保持一直 运行的状态而不退出？</h4><p>在main函数中会启动主线程的runloop,而runloop又是对事件循环的一种维护机制，在有事做的可以去做事，没有事做的时候，从用户态到内核态进行切换，避免资源占用</p><p><img src="/img/ios/runloop/main.png"></p><h3 id="runloop-数据结构"><a href="#runloop-数据结构" class="headerlink" title="runloop 数据结构"></a>runloop 数据结构</h3><p>NSRunloop 是CFRunloop的封装，提供了面向对象的api</p><ul><li><p>CFRunloop</p></li><li><p>CFRunloopMode</p></li><li><p>source/Timer/observer</p></li></ul><h3 id="CFRunloop-结构"><a href="#CFRunloop-结构" class="headerlink" title="CFRunloop 结构"></a>CFRunloop 结构</h3><p><img src="/img/ios/runloop/cfrunloop.png"></p><p>从 pthread 可以看出是和线程一一对应</p><h4 id="CFRunloopMode-分为哪些"><a href="#CFRunloopMode-分为哪些" class="headerlink" title="CFRunloopMode 分为哪些"></a>CFRunloopMode 分为哪些</h4><ul><li><p> UITrackingRunLoopMode (UI模式,只能被UI事件触发 优先级非常高)</p></li><li><p>NSDefaultRunLoopMode (默认模式,处理时钟网络事件)</p></li><li><p>NSRunLoopCommonModes (占位模式,以上两种模式都添加)</p></li><li><p>UIInitializationRunLoopMode  App启动时第一个模式, runloop会处理启动事件,这个模式只运行一次(苹果不开放)</p></li><li><p> GSEventReceiveRunLoopMode系统事件的内部模式(苹果不开放)</p></li></ul><h4 id="CFRunloopSource-分为哪些"><a href="#CFRunloopSource-分为哪些" class="headerlink" title="CFRunloopSource 分为哪些"></a>CFRunloopSource 分为哪些</h4><ul><li><p>source0 需要手动唤醒线程</p></li><li><p>source1 具备唤醒线程的能力</p></li></ul><h4 id="CFRunloopObserver-观测事件点"><a href="#CFRunloopObserver-观测事件点" class="headerlink" title="CFRunloopObserver 观测事件点"></a>CFRunloopObserver 观测事件点</h4><ul><li><p>KCFRunLoopEntry  runloop 进入循环</p></li><li><p>KCFRunLoopBeforeTimers  runloop 处理Timers事件前</p></li><li><p>KCFRunLoopBeforeSources  runloop 处理 source 事件前</p></li><li><p>KCFRunLoopBeforeWaiting  runloop 休眠前</p></li><li><p>KCFRunLoopAfterWaiting  runloop 休眠后</p></li><li><p>KCFRunLoopExit runloop 退出</p></li></ul><h4 id="各个数据结构之间的关系"><a href="#各个数据结构之间的关系" class="headerlink" title="各个数据结构之间的关系"></a>各个数据结构之间的关系</h4><p>runloop 对应mode 一对多 mode 对应 source、timer、observer 一对多</p><h4 id="commmode的特殊性"><a href="#commmode的特殊性" class="headerlink" title="commmode的特殊性"></a>commmode的特殊性</h4><ul><li><p>commmode不是实际存在的一种mode</p></li><li><p>是同步 source/Timer/observe 到多个mode 中的一种技术方案</p></li></ul><h3 id="Runloop-机制"><a href="#Runloop-机制" class="headerlink" title="Runloop 机制"></a>Runloop 机制</h3><p><img src="/img/ios/runloop/runloopjizhi.png"></p><h3 id="怎样实现一个常驻线程"><a href="#怎样实现一个常驻线程" class="headerlink" title="怎样实现一个常驻线程"></a>怎样实现一个常驻线程</h3><ul><li><p>在当前线程中开启一个runloop </p></li><li><p>向该runloop中添加一个Port/Source 等维持Runloop 的事件循环</p></li><li><p>启动该runloop</p></li></ul><h3 id="怎样保证子线程数据回来更新UI的时候不打断用户滑动操作-？"><a href="#怎样保证子线程数据回来更新UI的时候不打断用户滑动操作-？" class="headerlink" title="怎样保证子线程数据回来更新UI的时候不打断用户滑动操作?？"></a>怎样保证子线程数据回来更新UI的时候不打断用户滑动操作?？</h3><ul><li><p>用户滑动当前runloop 运行在UItrackingrunloopmode下</p></li><li><p> 我们一般在子线程中进行网络请求，所以可以在子线程给主线程数据进行UI更新的逻辑封装起来提交到主线       线程NSDefaultRunloopmode下 具体方法 [self performSelectorOnmainThred@selector(reloadData)       withobjc:nil waitUniteDone:No modes:NSDefaultRunloopmode]</p></li><li><p>这样抛回来的任务，当用户滑动处于UITrackingRunLoopMode 下就不会执行，当滑动停止，当前mode切换NSDefaultRunloopmode再处理子线线程抛上来的任务</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程</title>
    <link href="/2019/12/16/iOS-Multithreading/"/>
    <url>/2019/12/16/iOS-Multithreading/</url>
    
    <content type="html"><![CDATA[<h3 id="iOS系统为我们提供那些多线程技术"><a href="#iOS系统为我们提供那些多线程技术" class="headerlink" title="iOS系统为我们提供那些多线程技术"></a>iOS系统为我们提供那些多线程技术</h3><p>主要是这三种</p><ul><li><p>GCD</p></li><li><p>NSOperation</p></li><li><p>NSTread</p></li></ul><h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><h4 id="分为-同步-异步和-串行-并发"><a href="#分为-同步-异步和-串行-并发" class="headerlink" title="分为 同步/异步和 串行/并发"></a>分为 同步/异步和 串行/并发</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">dispatch_sync</span><span class="hljs-params">(serial_queue,^(任务)</span></span>)<br><span class="hljs-function"><span class="hljs-title">dispatch_async</span><span class="hljs-params">(serial_queue,^(任务)</span></span>)<br><span class="hljs-function"><span class="hljs-title">dispatch_sync</span><span class="hljs-params">(concurrent_queue,^(任务)</span></span>)<br><span class="hljs-function"><span class="hljs-title">dispatch_async</span><span class="hljs-params">(concurrent_queue,^(任务)</span></span>)<br><br></code></pre></td></tr></table></figure><p>同步并发队列</p><p>下面代码输出啥</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- （viewDidLoad）&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1&quot;</span>);<br>    <span class="hljs-built_in">dispatch_sync</span>(global_queue,^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;2&quot;</span>);<br><br>        <span class="hljs-built_in">dispatch_sync</span>(global_queue,^&#123;<br><br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;3&quot;</span>);<br>         &#125;)；<br><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;4&quot;</span>);<br>    &#125;)；<br>     <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;5&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>同步阻塞当前线程 所以打印1之后执行 block 打印2 由于是并发队列操作 所以执行打印3，如果是串行造成死锁</p><p> 异步并发队列<br>下面代码输出啥</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- （viewDidLoad）&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1&quot;</span>);<br>    <span class="hljs-built_in">dispatch_async</span>(global_queue,^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;2&quot;</span>);<br>        [<span class="hljs-keyword">self</span> performSelector：<span class="hljs-keyword">@selector</span>(printlog) withObject:<span class="hljs-literal">nil</span> afterDelay:<span class="hljs-number">0</span>]<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;3&quot;</span>);<br>    &#125;)；<br>&#125;<br>- (<span class="hljs-keyword">void</span>)printlog&#123;<span class="hljs-built_in">NSlog</span>(<span class="hljs-string">@&quot;2&quot;</span>)&#125;<br><br></code></pre></td></tr></table></figure><p>输出13，block内线程没有 runloop,所以 performSelector不会执行</p><h4 id="怎样用GCd实现多读单写呢"><a href="#怎样用GCd实现多读单写呢" class="headerlink" title="怎样用GCd实现多读单写呢"></a>怎样用GCd实现多读单写呢</h4><p>dipatch_barrier_async()</p><p><img src="/img/ios/multith/barrier.png"></p><h3 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h3><p>NSOperation 需要和 NSOperationqueue配合来实现多线程方案</p><p>特点</p><ul><li><p>添加任务依赖</p></li><li><p>任务执行状态控制</p></li><li><p>最大并发量</p></li></ul><h4 id="任务执行状态"><a href="#任务执行状态" class="headerlink" title="任务执行状态"></a>任务执行状态</h4><ul><li><p>isReady</p></li><li><p>isExecuting</p></li><li><p>isFinished</p></li><li><p>isCancelled</p></li></ul><p>状态控制</p><ul><li><p>如果只是重写了main方法，底层控制变更执行完成状态，以及任务退出</p></li><li><p>如果重写start方法，自行控制任务状态</p></li></ul><p>系统是怎样移除一个isfinished=Yes的NSOperation？</p><p>通过kvo</p><h3 id="NSTread"><a href="#NSTread" class="headerlink" title="NSTread"></a>NSTread</h3><p>启动流程</p><p><img src="/img/ios/multith/tread.png"></p><p>一般我们用NSTread和runloop 结合来是一个常驻线程</p><h3 id="dispatch-semaphore-t"><a href="#dispatch-semaphore-t" class="headerlink" title="dispatch_semaphore_t"></a>dispatch_semaphore_t</h3><p>信号量：就是一种可用来控制访问资源的数量的标识，设定了一个信号量，在线程访问之前，加上信号量的处理，则可告知系统按照我们指定的信号量数量来执行多个线程。<br>异步线程下同步问题</p><p>//创建信号量，参数：信号量的初值，如果小于0则会返回NULL<br>dispatch_semaphore_create（信号量值）</p><p>//等待降低信号量<br>dispatch_semaphore_wait（信号量，等待时间）</p><p>//提高信号量<br>dispatch_semaphore_signal(信号量)</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>一般我们用CGD来实现实现一些 简单线程同步 子线程放的分派，包括多读单写这些场景的一些问题的解决，</p></li><li><p>对于NSOpeation 由于它 任务依赖，任务状态控制，可以设置最大并发量的一些的特点，像afn sdwebimg 这些框架都会使用它</p></li><li><p>对于NSTread往往我们用它来实现一个常驻线程</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS_Autoreleasepool</title>
    <link href="/2019/12/14/iOS-Autoreleasepool/"/>
    <url>/2019/12/14/iOS-Autoreleasepool/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是自动释放池"><a href="#什么是自动释放池" class="headerlink" title="什么是自动释放池"></a>什么是自动释放池</h3><ul><li><p>是以栈为结点通过双向链表形式组合而成</p></li><li><p>是和线程一一对应</p></li></ul><p>ARC下，我们使用@autoreleasepool{}来使用一个AutoreleasePool，随后编译器将其改写成下面的样子:</p><p><img src="/img/ios/autoreleasePool/autoreleasby.png"></p><p><strong>push转化</strong><br><img src="/img/ios/autoreleasePool/push.png"></p><p><strong>pop转化</strong><br><img src="/img/ios/autoreleasePool/pop.png"></p><p>一次pop实际上是相当于一次批量的pop操作</p><h4 id="AutoreleasePoolPage"><a href="#AutoreleasePoolPage" class="headerlink" title="AutoreleasePoolPage"></a>AutoreleasePoolPage</h4><p>而这两个函数都是对AutoreleasePoolPage的简单封装，所以自动释放机制的核心就在于这个类</p><h5 id="AutoreleasePoolPage数据结构"><a href="#AutoreleasePoolPage数据结构" class="headerlink" title="AutoreleasePoolPage数据结构"></a>AutoreleasePoolPage数据结构</h5><p><img src="/img/ios/autoreleasePool/page.png"></p><ul><li><p>AutoreleasePool并没有单独的结构，惹事由若干个AutoreleasePoolPage以双向链表的形式组合而成</p></li><li><p>AutoreleasePool是按线程一一对应的（结构中的thread指针指向当前线程）</p></li><li><p>AutoreleasePoolPage每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存autorelease对象的地址</p></li><li><p>一个AutoreleasePoolPage的空间被占满时，会新建一个AutoreleasePoolPage对象，连接链表，后来的autorelease对象在新的page加入</p></li><li><p>上面的id *next指针作为游标指向栈顶最新add进来的autorelease对象的下一个位置</p></li></ul><h5 id="AutoreleasePoolPage-push"><a href="#AutoreleasePoolPage-push" class="headerlink" title="AutoreleasePoolPage::push"></a>AutoreleasePoolPage::push</h5><p><img src="/img/ios/autoreleasePool/pagepush.png"></p><p>每当进行一次objc_autoreleasePoolPush调用时，runtime向当前的AutoreleasePoolPage中add进一个哨兵对象，值为0（也就是个nil）</p><h5 id="objc-autorelease-流程"><a href="#objc-autorelease-流程" class="headerlink" title="[objc autorelease] 流程"></a>[objc autorelease] 流程</h5><p><img src="/img/ios/autoreleasePool/liuchen.png"></p><h5 id="AutoreleasePoolPage-pop"><a href="#AutoreleasePoolPage-pop" class="headerlink" title="AutoreleasePoolPage::pop"></a>AutoreleasePoolPage::pop</h5><ul><li><p>根据传入的哨兵对象地址找到哨兵对象所处的page</p></li><li><p>在当前page中，将晚于哨兵对象插入的所有autorelease对象都发送一次- release消息，并向回移动next指针到正确位置</p></li></ul><p><img src="/img/ios/autoreleasePool/pagepop1.png"></p><p><img src="/img/ios/autoreleasePool/pagepop2.png"></p><h4 id="多层嵌套的AutoreleasePool、"><a href="#多层嵌套的AutoreleasePool、" class="headerlink" title="多层嵌套的AutoreleasePool、"></a>多层嵌套的AutoreleasePool、</h4><p>知道了上面的原理，嵌套的AutoreleasePool就非常简单了，pop的时候总会释放到上次push的位置为止，多层的pool就是多个哨兵对象而已，就像剥洋葱一样，每次一层，互不影响</p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS 内存管理</title>
    <link href="/2019/12/14/iOS-Memory/"/>
    <url>/2019/12/14/iOS-Memory/</url>
    
    <content type="html"><![CDATA[<h3 id="汇总：内存分布、内存管理方法、数据结构、ARC-amp-MRC-、weak"><a href="#汇总：内存分布、内存管理方法、数据结构、ARC-amp-MRC-、weak" class="headerlink" title="汇总：内存分布、内存管理方法、数据结构、ARC&amp;MRC 、weak"></a>汇总：内存分布、内存管理方法、数据结构、ARC&amp;MRC 、weak</h3><h4 id="内存分布"><a href="#内存分布" class="headerlink" title="内存分布"></a>内存分布</h4><p>Objective-C是基于C的，不放看下C程序进程的内存分布</p><p><img src="/img/ios/arm/buju.png"></p><p>可以分为部分</p><ul><li><p>.text: 代码区存放函数，程序结束后由系统释放</p></li><li><p>.data: 已经初始化的全局变量和静态变量的一块内存区域。数据段属于静态内存分配,可以分为只读数据段和读写数据段。字符串常量等,是放在只读数据段中，结束程序时才会被收回。</p></li></ul><ul><li><p>.bss: 存放程序中未初始化的全局变量和静态变量的一块内存区域</p></li><li><p>heap:堆区存放进程运行中被动态分配的内存段,它的大小并不固定,可动态扩张或缩减。</p></li></ul><ul><li>stack: 由编译器自动分配并释放，存放函数的参数值，局部变量等</li></ul><h4 id="内存管理方案"><a href="#内存管理方案" class="headerlink" title="内存管理方案"></a>内存管理方案</h4><ul><li><p>TaggedPointer （小对象管理 短string 、NSNumber、NSdata等）</p></li><li><p>NONPOINTER_ISA （iOS arm64位架构下 非指针型isa）</p></li><li><p>散列表 （引用计数表、弱引用表）</p></li></ul><h5 id="散列表方式"><a href="#散列表方式" class="headerlink" title="散列表方式"></a>散列表方式</h5><h5 id="散列表结构"><a href="#散列表结构" class="headerlink" title="散列表结构"></a>散列表结构</h5><p><img src="/img/ios/arm/sideTables.png"></p><h5 id="SideTable结构"><a href="#SideTable结构" class="headerlink" title="SideTable结构"></a>SideTable结构</h5><p><img src="/img/ios/arm/sidetable.png"></p><p><strong>思考：为什么不用一张表管理？</strong></p><p>假如说只有一张sideTable,我们在内存中所有分配的对象，它们引用计数或者弱引用存储都在这张大表当中，我们要操作它们引用计数值，有可能它们是在不同的线程中进行操作吗，由于数据安全访问问题，所以我们要进行加锁，那么这样就会存在一个效率问题。</p><p><img src="/img/ios/arm/sidetablesuo.png"></p><h5 id="散列表数据结构"><a href="#散列表数据结构" class="headerlink" title="散列表数据结构"></a>散列表数据结构</h5><ul><li><p>Spinlock_t</p></li><li><p>RefcountMap </p></li><li><p>weak_table_t</p></li></ul><p>spinLock_t 特点</p><ul><li><p>是 “忙等”的锁</p></li><li><p>适用于轻量访问</p></li></ul><p>如果当前锁已被其他线程所获取，当前线程会不断的探测这锁有没有被释放，如果释放，自己第一时间去获取，所以说自旋锁是一种忙等的锁</p><p>再比如其他锁，如信号量，如果当前线程获取不到这个锁，它会把当前线程进行阻塞休眠，等到其他线程<br>释放这个锁的时候，再唤醒这个线程</p><h5 id="引用用计数"><a href="#引用用计数" class="headerlink" title="引用用计数"></a>引用用计数</h5><p>引用计数分为两种：</p><ul><li><p>手动引用计数（MRC）</p></li><li><p>自动引用计数（ARC）</p></li></ul><p>OC的内存机制可以简单概括为：谁持有(retain)谁释放(release)。retain引用计数+1，release反之</p><p><strong>ARC</strong></p><ul><li><p>ARC 是LLVM和Runtime协同的结果</p></li><li><p>ACR 中禁止手动调用 retain/release/retainCount/dealloc</p></li><li><p>ACR 新增weak、strong 属性关键字</p></li></ul><h5 id="引用计数管理"><a href="#引用计数管理" class="headerlink" title="引用计数管理"></a>引用计数管理</h5><p>实现原理分析</p><ul><li><p>alloc</p></li><li><p>retain</p></li><li><p>release</p></li><li><p>dealloc</p></li></ul><blockquote><ul><li>alloc实现<br> 经过一系列的调用，最终调用了C函数calloc<br> 此时并没有设置引用计数为1</li></ul></blockquote><blockquote><ul><li>retain 实现</li></ul></blockquote><p><img src="/img/ios/arm/retain.png"></p><p>我们在进行retain 操作的时候，系统是怎样查找它对应引用计数的？是经过两次hash查找，查找到它对应的引用计数，然后再响应进行 +1 操作</p><blockquote><ul><li>release实现</li></ul></blockquote><p><img src="/img/ios/arm/release.png"></p><blockquote><ul><li>dealloc 实现</li></ul></blockquote><p><img src="/img/ios/arm/dealloc.png"></p><h4 id="弱引用管理（weak）"><a href="#弱引用管理（weak）" class="headerlink" title="弱引用管理（weak）"></a>弱引用管理（weak）</h4><p>weak 关键字的作用弱引用，所引用对象的计数器不会加一，并在引用对象被释放的时候自动被设置为 nil</p><p><strong>weak编译</strong></p><p><img src="/img/ios/arm/weakgl.png"></p><p><strong>weak变量怎样添加到弱引用表？</strong></p><p><img src="/img/ios/arm/addweak.png"></p><p>一个被声明为 __weak的对象指针，经过编译器编译之后会调用 objc_initWeak 方法，经过一系列的函数调用栈，最终在weak_rgister_no_lock()这样一个函数中，进行弱引用变量添加，具体添加的位置是通过哈希算法进行位置，如果查找到对应位置已经有了所对应的弱引用数组，就把新的弱引用用变量添加到数组中，如果没有就创建一个新的弱引用数，第0位置添加新的弱引用指针，其他位置初始化为nil</p><p><strong>weak释放为nil过程</strong></p><p><img src="/img/ios/arm/deallocweak.png"><br>当一个对象被dealloc,在dealloc内部实现当中会调用弱引用相关清理函数，在这个函数内部实现当中会根据当前对象的指针，查找弱引用表，把当前对象相应的弱引用都拿出来，是一个数组，遍历数组当中所有弱引用指针，分别置为nil</p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS_Block</title>
    <link href="/2019/11/12/iOS-Block/"/>
    <url>/2019/11/12/iOS-Block/</url>
    
    <content type="html"><![CDATA[<h3 id="Block-介绍"><a href="#Block-介绍" class="headerlink" title="Block 介绍"></a>Block 介绍</h3><p>block 是将函数及其执行上下文分装起来的对象</p><p>例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&#123;<br>    <span class="hljs-keyword">int</span> mutltiplier = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">int</span>(^Block)(<span class="hljs-keyword">int</span>) = ^<span class="hljs-keyword">int</span>(<span class="hljs-keyword">int</span> num)&#123;<br>        <span class="hljs-keyword">return</span> num * mutltiplier<br>    &#125;<br>    Block(<span class="hljs-number">2</span>)<br><br>&#125;<br><br>``` <br>经由编译编译之后，使用 clange -rewrite-objc  file.m 查看编译器内容<br>``` <br>struct __block_impl &#123;<br>    <span class="hljs-keyword">void</span> *isa; isa指针，Block 是对象的标志<br>    <span class="hljs-keyword">int</span> Flags;<br>    <span class="hljs-keyword">int</span> Reserved;<br>    <span class="hljs-keyword">void</span> *FuncPtr;<span class="hljs-comment">// 无类型的函数指针</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_impl_0</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">block_impl</span> <span class="hljs-title">impl</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span>* <span class="hljs-title">Desc</span>;</span><br>  __main_block_impl_0(<span class="hljs-keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="hljs-keyword">int</span> flags=<span class="hljs-number">0</span>) &#123;<br>    impl.isa = &amp;_NSConcreteStackBlock;<br>    impl.Flags = flags;<br>    impl.FuncPtr = fp;<br>    Desc = desc;<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span> &#123;</span><br>  <span class="hljs-keyword">size_t</span> reserved;<br>  <span class="hljs-keyword">size_t</span> Block_size;<br>&#125; __main_block_desc_0_DATA = &#123; <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct __main_block_impl_0)&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])</span> </span>&#123;<br>    <span class="hljs-comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool;<br>        (<span class="hljs-keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="hljs-keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="block-截获变量特性"><a href="#block-截获变量特性" class="headerlink" title="block 截获变量特性"></a>block 截获变量特性</h3><p>如下代码，看一下最终输出结果</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">&#123;<br>    <span class="hljs-built_in">int</span> mutltiplier = <span class="hljs-number">3</span>;<br>    <span class="hljs-built_in">int</span>(^Block)(<span class="hljs-built_in">int</span>) = ^<span class="hljs-built_in">int</span>(<span class="hljs-built_in">int</span> num)&#123;<br>        return num<span class="hljs-operator"> * </span>mutltiplier<br>    &#125;<br>    <span class="hljs-constructor">Block(2)</span><br>   mutltiplier = <span class="hljs-number">4</span><br>   <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;result is %d&quot;</span>,Block(2)</span>)<br>&#125;<br>result is <span class="hljs-number">6</span><br><br>``` <br><br><br>**block 对以下类类型的变量都有哪些特点**<br><br><br>- 局部变量 （基本数据类型 、 对象类型）<br><br>- 静态局部变量<br><br>- 全局变量<br><br>- 静态全局变量<br><br>``` <br><span class="hljs-built_in">int</span> global_var = <span class="hljs-number">4</span>;<br><br>static <span class="hljs-built_in">int</span> static_global_var = <span class="hljs-number">5</span>;<br><br>- (void)<span class="hljs-keyword">method</span> &#123;<br>    <span class="hljs-comment">//基本数据类型</span><br>    <span class="hljs-built_in">int</span> var = <span class="hljs-number">3</span>;<br>     <span class="hljs-comment">//对象类型</span><br>    __unsafe_unretained id unsafe_obj = nil ;<br>    <br>    __strong id strong_obj = nil ;<br>    <br>    static <span class="hljs-built_in">int</span> static_var = <span class="hljs-number">7</span>;<br>    <br>    void (^Block)(void) = ^&#123;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;局部变量&lt;基本数据类型&gt; var %d&quot;</span>,<span class="hljs-params">var</span>)</span>;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;局部变量 &lt;对象类型&gt;var %@&quot;</span>,<span class="hljs-params">unsafe_obj</span>)</span>;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;局部变量 &lt;对象类型&gt;var %@&quot;</span>,<span class="hljs-params">strong_obj</span>)</span>;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;静态变量  %d&quot;</span>,<span class="hljs-params">static_var</span>)</span>;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;全局变量 global_var %d&quot;</span>,<span class="hljs-params">global_var</span>)</span>;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;静态全局变量 static_global_var %d&quot;</span>,<span class="hljs-params">static_global_var</span>)</span>;<br>    &#125;;<br>    <span class="hljs-constructor">Block()</span>;<br>    <br>    <br>&#125;<br>``` <br>使用 clange -rewrite-objc -fobjc-arc file.m<br><br>.cpp 编译文件中结果<br>``` <br><span class="hljs-built_in">int</span> global_var = <span class="hljs-number">4</span>;<br><br>static <span class="hljs-built_in">int</span> static_global_var = <span class="hljs-number">5</span>;<br><br><br><span class="hljs-keyword">struct</span> __McBlock__method_block_impl_0 &#123;<br>  <span class="hljs-keyword">struct</span> __block_impl impl;<br>  <span class="hljs-keyword">struct</span> __McBlock__method_block_desc_0* Desc;<br>  <span class="hljs-built_in">int</span> var;<br>  __unsafe_unretained id unsafe_obj;<br>  __strong id strong_obj;<br>  <span class="hljs-built_in">int</span> *static_var;<br>  <span class="hljs-constructor">__McBlock__method_block_impl_0(<span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">fp</span>, <span class="hljs-params">struct</span> <span class="hljs-params">__McBlock__method_block_desc_0</span> <span class="hljs-operator">*</span><span class="hljs-params">desc</span>, <span class="hljs-params">int</span> <span class="hljs-params">_var</span>, <span class="hljs-params">__unsafe_unretained</span> <span class="hljs-params">id</span> <span class="hljs-params">_unsafe_obj</span>, <span class="hljs-params">__strong</span> <span class="hljs-params">id</span> <span class="hljs-params">_strong_obj</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">_static_var</span>, <span class="hljs-params">int</span> <span class="hljs-params">flags</span>=0)</span> : var(_var), unsafe<span class="hljs-constructor">_obj(<span class="hljs-params">_unsafe_obj</span>)</span>, strong<span class="hljs-constructor">_obj(<span class="hljs-params">_strong_obj</span>)</span>, static<span class="hljs-constructor">_var(<span class="hljs-params">_static_var</span>)</span> &#123;<br>    impl.isa = &amp;_NSConcreteStackBlock;<br>    impl.Flags = flags;<br>    impl.FuncPtr = fp;<br>    Desc = desc;<br>  &#125;<br>&#125;;<br><br>``` <br><br>**总结**<br><br>- 对于基本数据类型的局部变量截获其值<br><br>- 对于对象类型的局部变量连同所有权修饰符一起截获<br><br>- 对于局部静态变量是以指针形式进行截获<br><br>- 对于全局变量、静态全局变量不截获<br><br><br>### __block 修饰符<br><br> 一般情况下，对截获变量值进行复制操作需要添加__blcok 修饰符<br><br>``` <br> &#123;<br>    NSMutableArray *<span class="hljs-built_in">array</span> = <span class="hljs-literal">[NSM<span class="hljs-identifier">utableArray</span> <span class="hljs-identifier">array</span>]</span>;<br>    void(^Block)(void) = ^&#123;<br>        <span class="hljs-literal">[<span class="hljs-identifier">array</span> <span class="hljs-identifier">addobjcet</span>: @<span class="hljs-number">1234</span>]</span><br>    &#125;<br>    <span class="hljs-constructor">Block()</span><br> &#125;<br></code></pre></td></tr></table></figure><p>是否使用__block 修饰符？</p><p><strong>__block 使用场景</strong></p><ul><li><p>对于局部变量赋值需要</p></li><li><p>对于静态局部变量、全局变量、静态全局变量 不需要</p></li></ul><p>静态局部变量是捕获指针、全局和静态全局不捕获值</p><p><strong>思考</strong></p><pre><code>&#123;    __block int mutltiplier = 3;    int(^Block)(int) = ^int(int num)&#123;        return num * mutltiplier    &#125;    Block(2)   mutltiplier = 4   NSLog(@&quot;result is %d&quot;,Block(2))&#125;result is 8</code></pre><p>因为__blcok修饰的变量变成了对象</p><pre><code>__block int multiplier  编译转化struct _Block_byref_multiplier_0 &#123;void *_isa;__Block_byref_multiplier_0 * _forwarding;int _flagsint _sizeint multiplier&#125;(multiplier._forwarding -&gt; multiplier )= 4</code></pre><p>栈上的 __block forwarding指针指向自身</p><h3 id="block-内存管理"><a href="#block-内存管理" class="headerlink" title="block 内存管理"></a>block 内存管理</h3><p><strong>block分为哪几类</strong></p><ul><li><p>NSConcreteGlobalBlock 全局block</p></li><li><p>NSConcreteGStackBlock 栈block</p></li><li><p>NSConcreteGMallocBlock 堆block</p></li></ul><h4 id="block-copy操作"><a href="#block-copy操作" class="headerlink" title="block copy操作"></a>block copy操作</h4><p><img src="/img/ios/block/blockcopy.png"></p><p><img src="/img/ios/block/duizhan.png"></p><p>一个对象的成员变量是一个block,在栈上面创建这个blcok,如果我们没有使用copy,当我们通过具体的成员变量访问对应blcok,可能由于栈对应的函数退出之后，在内存中就销毁掉了，再继续访问就会引起内存崩溃</p><p><strong>__forwarding存在的意义</strong></p><p><img src="/img/ios/block/copydui.png"></p><p>栈上的forwarding指针指向自身，block经过copy之后，栈上的forwarding指针指向堆上的__block变量，堆上的forwarding指针指向自身</p><p>不论在任何位置，都可以顺利的访问同一个__blcok 变量</p><h4 id="block-循环引用问题"><a href="#block-循环引用问题" class="headerlink" title="block 循环引用问题"></a>block 循环引用问题</h4><p><strong>思考下面代码有什么问题 如何解决</strong></p><pre><code>&#123;    _array = [NSMutableArray arrayWithObjcet:@&quot;123&quot;];    _strBlock = ^NSString*(NSString* str)&#123;        return [NSString stringWithFormat:@&quot;%@_%@&quot;,str,_array[0]];    &#125;    _strBlock(@&quot;hello&quot;);&#125;</code></pre><p>引起自循环引用，当前对象强引用block,block表达式中又使用了当前对象的成员变量array，在截获变量中连同修饰符权限共同截获<br>所以就有一个strong类型的指针指向当前对象，所以产生了，循环引用</p><p>使用__weak NMutableArray *weakarray = _array 解除循环引用</p><p><strong>思考下面代码有什么问题 如何解决</strong></p><pre><code>&#123;    __block TestBlock* blockSelf = self;    _blk = ^int(int num) &#123;        int result = num *blockSelf.var        return result;    &#125;    _blk(3)&#125;</code></pre><p>在MRC不会有任何问题</p><p>ARC情况下</p><p><img src="/img/ios/block/arcyy.png"></p><p>解决办法在block表达式中 blockSelf = nil</p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS_UI视图汇总</title>
    <link href="/2019/11/10/iOS-UI/"/>
    <url>/2019/11/10/iOS-UI/</url>
    
    <content type="html"><![CDATA[<h3 id="汇总：事件传递-amp-响应链、图像显示原理、卡顿-amp-掉帧、绘制原理-amp-异步绘制"><a href="#汇总：事件传递-amp-响应链、图像显示原理、卡顿-amp-掉帧、绘制原理-amp-异步绘制" class="headerlink" title="汇总：事件传递&amp;响应链、图像显示原理、卡顿&amp;掉帧、绘制原理&amp;异步绘制"></a>汇总：事件传递&amp;响应链、图像显示原理、卡顿&amp;掉帧、绘制原理&amp;异步绘制</h3><hr><h3 id="UIView-和-CALayer-关系是怎么样的？"><a href="#UIView-和-CALayer-关系是怎么样的？" class="headerlink" title="UIView 和 CALayer 关系是怎么样的？"></a>UIView 和 CALayer 关系是怎么样的？</h3><ul><li>UIView 为其提供内容，以及负责触摸等事件，参与响应链</li><li>CALayer 负责显示内容contens<br><img src="/img/ios/UI/uiview.png"></li></ul><p>UIView和CAlayer从系统设计上符合 单一事件原则</p><hr><h3 id="系统UI事件传递及视图响应"><a href="#系统UI事件传递及视图响应" class="headerlink" title="系统UI事件传递及视图响应"></a>系统UI事件传递及视图响应</h3><h4 id="事件传递"><a href="#事件传递" class="headerlink" title="事件传递"></a>事件传递</h4><p>当一个用户事件产生的时候，UIKit 会创建一个事件对象来描述这个用户事件。然后它会将该事件对象放进UIApplication对象所维护的事件队列中。对于触摸事件而言，产生的事件对象便是一个包含UIEvent的集合(NSSet)对象，一个事件会朝着特定的路径进行传递直到遇到一个可以处理它的对象为止</p><p><strong><em>事件传递的两个重要方法</em></strong></p><ul><li><p>-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event</p></li><li><p>-（BOOL）pointInside:(CGPoint)point withEvent:(UIEvent *)event</p></li></ul><p><strong><em>事件传递流程图</em></strong><br><img src="/img/ios/UI/hitTest.png"></p><p>倒序遍历：最后添加的UIView最优先被遍历<br>hitTest如果有值，返回当前视图，结束事件传递,如果没有UIWindow就作为一个响应的视图</p><p><strong><em>hitTest:WithEvent系统是实现如图</em></strong><br><img src="/img/ios/UI/hitTestEvent.png"></p><ol><li><p>优先判读当前视图的：hidden alpha  等属性，如果不满足返回nil,也就是说当前视图，不作为响应者，然后在由父视图遍历同级兄弟视图</p></li><li><p>判读点击的点是否在当前视图，如果不满足返回nil,也就是<br>说当前视图，不作为响应者，然后在由父视图遍历同级兄弟视图</p></li><li><p>以倒序方式遍历当前视图的所有子视图，遍历过程 调用 hittest 方法,如果有对应的响应视图就返回，如果遍历完成之后，没有对应视图，由于 pointinside 在当前视图范围内，返回当前图作为响应视图返回给调用方</p></li></ol><h4 id="响应链"><a href="#响应链" class="headerlink" title="响应链"></a>响应链</h4><p>响应者链条是由响应者对象构成的，它们有一个共同点就是都是继承自UIResponder，UIResponder的程序接口不仅定义了事件处理方式，还有响应者的一些共同行为。UIApplication，UIViewController和UIView都是响应者，这意味着UIView与其所有子类和大多数主要控制器对象都是响应者，符合设计模式中责任链</p><p><img src="/img/ios/UI/responder.png"></p><ul><li><p>响应链:由离 户最近的view向系统传递。initial view –&gt; super view –&gt; …..–&gt; view controller –&gt; window –&gt; Application –&gt; AppDelegate</p></li><li><p>Hit-Testing 链:由系统向离户最近的view传递。 UIKit –&gt; active app’s event queue –&gt; window –&gt; root view –&gt;……–&gt;lowest view </p></li></ul><hr><h3 id="图层显示原理"><a href="#图层显示原理" class="headerlink" title="图层显示原理"></a>图层显示原理</h3><p><strong><em>cpu和gpu都做了哪些事情</em></strong></p><p><img src="/img/ios/UI/imagePrinciple.png"></p><p>cpu 和 gpu 两个是通过总线连接起来，那么我们在cpu中所输出结果往往是一个位图，再经由总线在合适的时机上传给 gpu, gpu 在拿到位图之后，做相应位图图层的渲染包括纹理合成之后再把结果放到帧缓冲区域当中，由视频控制器根据vsync信号在指定时间之前，去提取对应帧缓冲区域当中屏幕显示内容，然后最终显示在手机屏幕上</p><p><strong><em>UI 视图显示在屏幕上的大致过程</em></strong></p><p><img src="/img/ios/UI/iamgePrinciple1.png"></p><p>首先当我们创建了一个UIview 显示控件后，它的显示部分是由CAlayer 来负责，CAlayer 当中有一个contents 属性，就是我们最终要绘制到屏幕上面的位图，比如说我们创建了一个UIlabel,那么contens里面最终放的结果就是关于hello world的一个文字的位图，然后系统会在合适的时机，回调给我们一个drawRect方法，然后我们可以在此基础之上绘制一些，我们想自定义绘制的内容，绘制好的这个位图，最终经由Core Animation这个框架提交给 gpu 部分的openGL 渲染管线，进行最终位图的渲染和纹理合成，然后会显示我们的屏幕上。</p><p><strong><em>cpu工作</em></strong><br><img src="/img/ios/UI/cpu.png"></p><ul><li>layout: UI布局 文本的计算  </li><li>display: 绘制  </li><li>prepare: 图片编解码 </li><li>commit: 提交位图</li></ul><p><strong><em>gpu工作</em></strong></p><p><img src="/img/ios/UI/gpu.png"></p><h3 id="UI卡顿、掉帧的原因"><a href="#UI卡顿、掉帧的原因" class="headerlink" title="UI卡顿、掉帧的原因"></a>UI卡顿、掉帧的原因</h3><p><strong><em>如图</em></strong></p><p><img src="/img/ios/UI/uikadun.png"></p><ul><li>一般说页面滑动的流畅性是60fps , 指的就是每一秒中会有60帧的画面更新，我们在人眼上面看到的就是流畅效果，基于此每隔16.7ms就要产生一帧画面，在这16.7ms内需要 cpu 和 gpu协同完成这一帧的数据.</li><li>比如 cpu 花费一定的时间做 UI布局 文本计算 视图绘制 图片编解码 然后把产生位图提交给 gpu 进行渲染和纹理合成。准好下一帧画面，然后在下一帧的vsync 信号到来时候就可以显示这么样的一个画面。假如说 cpu 占用时间过长，那么留给gpu的时间就非常少，gpu要想完成工作，那么总时间就会超过16.7ms,这样在下一帧的vsync 信号到来时候，我们没有准备好当下的这一帧画面，那就由此产生了掉帧，看到的效果就是滑动的卡顿。</li></ul><p><strong>总结一句话，在规定的16.7ms内在下一帧vsync信号到来之前，并没有gpu和cpu共同完成下一帧画面的合成于是就会导致卡顿、掉帧</strong></p><hr><h3 id="UIView-绘制原理"><a href="#UIView-绘制原理" class="headerlink" title="UIView 绘制原理"></a>UIView 绘制原理</h3><p>当UIview 调用 setNeedDisplay 系统会调用 calayer 的同名方法，之后相当与在当前 layer打上了一个脏标记，然后会在当前runloop将要结束的时候才会调用CALayer display方法，进入当前视图真正绘制流程。</p><p><img src="/img/ios/UI/uiviwedisplay1.png"></p><h4 id="系统绘制流程"><a href="#系统绘制流程" class="headerlink" title="系统绘制流程"></a>系统绘制流程</h4><p><img src="/img/ios/UI/calayerbacking.png"></p><h4 id="异步绘制流程"><a href="#异步绘制流程" class="headerlink" title="异步绘制流程"></a>异步绘制流程</h4><blockquote><ul><li>-[layer.delegate displayLayer]</li><li>代理负责生成对应的bitmap</li><li>设置该bitmap作为 layer.contents的属性的值<br>  、<br><img src="/img/ios/UI/displayLayer.png"></li></ul></blockquote><h3 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h3><p><strong>离屏渲染：当我们指定UI视图的某些属性标记为在未愈合成之前不能用于当前屏幕显示就会触发离屏渲染，离屏渲染的概念起源于CPU层面，指的是GPU在当前屏幕缓冲区以新开辟一个缓冲区进行渲染操作</strong></p><h4 id="何时会触发？"><a href="#何时会触发？" class="headerlink" title="何时会触发？"></a>何时会触发？</h4><ul><li>圆角（当和 maskToBounds 一起使用时）</li><li>图层蒙版</li><li>阴影</li><li>光栅化</li></ul><h4 id="为何要避免？"><a href="#为何要避免？" class="headerlink" title="为何要避免？"></a>为何要避免？</h4><p><strong>在触发离屏渲染的时候，会增加GPU的工作量，而增加GPU的工作量很有可能会导致GPU和CPU的总耗时超过16.7ms,那么可能会导致UI掉帧和卡顿</strong></p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ios_Runtime</title>
    <link href="/2019/10/11/ios-runtime/"/>
    <url>/2019/10/11/ios-runtime/</url>
    
    <content type="html"><![CDATA[<h3 id="runtime-介绍"><a href="#runtime-介绍" class="headerlink" title="runtime 介绍"></a>runtime 介绍</h3><p>Objective-C 扩展了 C 语言，并加入了面向对象特性和 Smalltalk 式的消息传递机制。而这个扩展的核心是一个用 C 和 编译语言 写的 Runtime 库。它是 Objective-C 面向对象和动态机制的基石</p><h4 id="runtime-基础数据结构"><a href="#runtime-基础数据结构" class="headerlink" title="runtime 基础数据结构"></a>runtime 基础数据结构</h4><p><img src="/img/ios/runtime/runtimejc.png"></p><ul><li><p>objc_object</p></li><li><p>objc_class</p></li><li><p>isa 指针</p></li><li><p>method_t</p></li></ul><h4 id="objc-object-数据结构"><a href="#objc-object-数据结构" class="headerlink" title="objc_object 数据结构"></a>objc_object 数据结构</h4><p><img src="/img/ios/runtime/objcobject.png"></p><h4 id="objc-class-数据结构"><a href="#objc-class-数据结构" class="headerlink" title="objc_class 数据结构"></a>objc_class 数据结构</h4><p><img src="/img/ios/runtime/objcclass.png"></p><p>bits: 一个类的变量、属性、方法 在这个数据结构当中</p><h4 id="isa-指针"><a href="#isa-指针" class="headerlink" title="isa 指针"></a>isa 指针</h4><p> c语言中 共用体isa_t</p><ul><li><p>指针型isa 代表class的地址</p></li><li><p>非指针型isa 部分代表class的地址</p></li></ul><p><img src="/img/ios/runtime/isa.png"></p><p><strong>isa指向</strong></p><p><img src="/img/ios/runtime/isazx.png"></p><ul><li><p>如果我们调用实例方法 isa 去类对象中进行查找</p></li><li><p>如果我们调用的是类方法 isa 去元类对象中查找</p></li></ul><h4 id="cache-t-作用"><a href="#cache-t-作用" class="headerlink" title="cache_t 作用"></a>cache_t 作用</h4><ul><li><p>用于快速查找方法执行函数</p></li><li><p>是可增量扩展的哈希表结构</p></li><li><p>是局部原理的最佳应用</p></li></ul><h4 id="cache-t-大致结构"><a href="#cache-t-大致结构" class="headerlink" title="cache_t 大致结构"></a>cache_t 大致结构</h4><p><img src="/img/ios/runtime/cachet.png"></p><blockquote><p>-流程：根据key通过哈希查找算法，来定位这个key所对应的这个bucke_t 这个数据结构位于数组那个位置，当我们定位到这个位置之后，就可以通过提取bucket_t 里面具体函数实现来调用这个函数<br>key: 就是对应SEL<br>imp: 无类型的函数指针</p></blockquote><h4 id="class-data-bits-t-介绍"><a href="#class-data-bits-t-介绍" class="headerlink" title="class_data_bits_t 介绍"></a>class_data_bits_t 介绍</h4><ul><li><p>class_data_bits_t 主要是对class_rw_t的封装</p></li><li><p>class_rw_t 代表类的相关读写信息，对class_ro_t的封装</p></li><li><p>class_ro_t 代表了类相关的只读信息</p></li></ul><p><strong>class_rw_t</strong></p><p><img src="/img/ios/runtime/classrw.png"></p><ul><li>在我们为一个类添加的分类里的一些方法、协议、属性都在class_rw_t 数据结构当中</li></ul><p><strong>class_ro_t</strong></p><p><img src="/img/ios/runtime/classro.png"></p><p><strong>method_t</strong></p><p><img src="/img/ios/runtime/methodt.png"></p><p><strong>Type Encodings</strong></p><p><img src="/img/ios/runtime/typs.png"></p><h4 id="对象、类对象、元类对象"><a href="#对象、类对象、元类对象" class="headerlink" title="对象、类对象、元类对象"></a>对象、类对象、元类对象</h4><ul><li><p>类对象存储实例方法列表等信息</p></li><li><p>元类对象存储类方法列表等信息</p></li></ul><p><strong>消息传递指向isa superclass图</strong></p><p><img src="/img/ios/runtime/msgcd.png"></p><ul><li><p>元类对象的isa 都指向根元类对象</p></li><li><p>根元类对象 superclass 指向根类对象，当我们调用类方法时，如果在元类对象中逐级父类查找，如果找不到，它就会找根类对象中同名的实例方法</p></li></ul><h4 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h4><p><strong>两个方法</strong></p><blockquote><ul><li>void objc_msgSend(void/<em>id self, SEL op,…</em>/)</li></ul></blockquote><blockquote><ul><li>[self class] -&gt; objc_msgSend(self,@selectior(class))</li></ul></blockquote><blockquote><ul><li>void objc_msgSendSuper(void/* struct objc_super *super ,SEL op, … */)</li></ul></blockquote><blockquote><ul><li>[super class] -&gt; objc_msgSendSuper(super,@selector(class))</li></ul></blockquote><p>super 实际上是编译器关键字，recevier 接收者就是当前对象</p><p><strong>消息传递流程</strong></p><p><img src="/img/ios/runtime/msgz.png"></p><p><strong>缓存查找</strong></p><p><img src="/img/ios/runtime/cachecz.png"></p><ul><li>通过给定的key,根据哈希查找，找出bucket_t 在数组对应的位置，然后获取 imp</li></ul><p><strong>当前类中查找</strong></p><ul><li>对于已排序好的列表，采用二分查找算法查找方法对应的执行函数</li><li>对于没有排序的列表，采用一般遍历查找方法对应的执行函数</li></ul><p><strong>父级逐级查找</strong></p><p><img src="/img/ios/runtime/superclass.png"></p><h4 id="消息转发流程"><a href="#消息转发流程" class="headerlink" title="消息转发流程"></a>消息转发流程</h4><p><img src="/img/ios/runtime/msgzf.png"></p><h4 id="dynamic-关键字"><a href="#dynamic-关键字" class="headerlink" title="@dynamic 关键字"></a>@dynamic 关键字</h4><ul><li><p>动态运行时语言将函数决议推迟到运行时</p></li><li><p>编译时语言在编译器进行函数决议</p></li></ul><p><strong>能否向编译后的类添加增加实例变量？</strong></p><p>不能 编译之前定义创建类已经完成了实例变量的布局，在具体分析runtime 数据结构 class_ro_t 是没有办法修改</p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>oc语言特性</title>
    <link href="/2019/10/11/iOS-ocfeature/"/>
    <url>/2019/10/11/iOS-ocfeature/</url>
    
    <content type="html"><![CDATA[<h3 id="汇总：分类-、关联对象、扩展、通知、kvo、kvc、属性关键字"><a href="#汇总：分类-、关联对象、扩展、通知、kvo、kvc、属性关键字" class="headerlink" title="汇总：分类 、关联对象、扩展、通知、kvo、kvc、属性关键字"></a>汇总：分类 、关联对象、扩展、通知、kvo、kvc、属性关键字</h3><hr><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="分类都做了哪些事情"><a href="#分类都做了哪些事情" class="headerlink" title="分类都做了哪些事情"></a>分类都做了哪些事情</h4><ul><li>声明私有方法</li><li>分解体积庞大的类文件</li><li>把Framework的私有方法公开</li></ul><h4 id="分类的特点"><a href="#分类的特点" class="headerlink" title="分类的特点"></a>分类的特点</h4><ul><li>运行时决议</li><li>可以为系统类添加分类</li></ul><h4 id="分类都可以添加哪些内容"><a href="#分类都可以添加哪些内容" class="headerlink" title="分类都可以添加哪些内容"></a>分类都可以添加哪些内容</h4><ul><li>实例方法</li><li>类方法</li><li>协议</li><li>属性 （只是声明了get 和 set 方法 ，并没有添加实例变量）</li></ul><p><strong>分类的数据结构</strong></p><p><img src="/img/ios/octx/categor.png"></p><p><strong>分类调用栈</strong></p><p><img src="/img/ios/octx/categorystaic.png"></p><p>image: 表示的是镜像<br>read_image:读取镜像，加载一些可执行文件到内存中进行处理</p><p><strong>添加的两个分类a和b 有同名方法那个生效？</strong></p><p>源码分析</p><p><img src="/img/ios/octx/categorycode.png"></p><blockquote><ul><li>最先访问，最后编译的分类，添加的两个分类a和b 有同名方法那个生效，取决于分类的编译顺序，最后编译的那个分类才会生效，前面的会被覆盖掉</li></ul></blockquote><p><strong>分类覆盖宿主类</strong></p><p><img src="/img/ios/octx/categorycode1.png"></p><p><img src="/img/ios/octx/categorycode2.png"></p><ul><li>分类添加的方法“覆盖”原类方法</li><li>同名分类方法谁能生效取决于编译顺序</li><li>名字相同的分类会引起编译报错</li></ul><hr><h3 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h3><h4 id="关联对象方法"><a href="#关联对象方法" class="headerlink" title="关联对象方法"></a>关联对象方法</h4><p>//关联对象</p><ol><li>void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)</li></ol><p>//获取关联的对象</p><ol start="2"><li>id objc_getAssociatedObject(id object, const void *key)</li></ol><p>//移除关联的对象</p><ol start="3"><li>void objc_removeAssociatedObjects(id object)</li></ol><h4 id="关联对象本质"><a href="#关联对象本质" class="headerlink" title="关联对象本质"></a>关联对象本质</h4><ul><li><p>关联对象由AssoctionsManager管理并在AssoctionsHashMap存储</p></li><li><p>所有对象的关联内容都在同一个全局容器中</p></li></ul><p><img src="/img/ios/octx/association.png"></p><hr><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><h4 id="扩展做什么"><a href="#扩展做什么" class="headerlink" title="扩展做什么"></a>扩展做什么</h4><ul><li><p>声明私有属性</p></li><li><p>声明私有方法</p></li><li><p>声明私有成员变量</p></li></ul><h4 id="扩展特性"><a href="#扩展特性" class="headerlink" title="扩展特性"></a>扩展特性</h4><ul><li><p>编译时决议</p></li><li><p>只以声明的形式存在，多数情况下寄生于宿主类.m 中</p></li><li><p>不能为系统类添加扩展</p></li></ul><h3 id="通知（NSNOtification）"><a href="#通知（NSNOtification）" class="headerlink" title="通知（NSNOtification）"></a>通知（NSNOtification）</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li><p>是使用观察者模式来实现的用于跨层传递消息的机制</p></li><li><p>传递方式为 一对多</p></li></ul><h4 id="通知机制"><a href="#通知机制" class="headerlink" title="通知机制"></a>通知机制</h4><p><img src="/img/ios/octx/nsnotification.png"></p><h3 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul><li><p>kvo 是 key-value observing 的缩写</p></li><li><p>kvo 是 oc 对观察者模式的又一种实现</p></li><li><p>apple 使用了 isa 混写（isa-swizzing）来实现 kvo</p></li></ul><p><img src="/img/ios/octx/kvoyuanli.png"></p><p>isa_swizzing:<br>          当我们调用 addObserver:forKeyPath:options:context 之后 系统会在运行时创建NSKVONotifying_* 这样一个类 ，同时将原来的类的isa 指针指向新创建的类。<br>           新创的类实际上是原来类的子类，之所以这做，是重写原来类的setter方法，来达到通知所有观察者对象</p><p><strong>重写的Setter添加的方法</strong></p><ul><li><p>-（void）willChangeValueForKey:(NSString *) key</p></li><li><p>-（void）didChangeValueForKey:(NSString *) key</p></li></ul><p><strong>kvo改变值生效问题</strong></p><ul><li><p>使用setter方法改变值才会生效</p></li><li><p>使用setvalue:forkey 改变值会生效</p></li><li><p>成员变量直接修改需手动添加kvo才会生效</p></li></ul><h3 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h3><h4 id="键值编码技术，会破坏面向对象思想"><a href="#键值编码技术，会破坏面向对象思想" class="headerlink" title="键值编码技术，会破坏面向对象思想"></a>键值编码技术，会破坏面向对象思想</h4><p><strong>两个方法</strong></p><ul><li><p>-（id)valueForKey:(NSString *)key</p></li><li><ul><li>(void)setValue:(id)value forKey:(NNString *)key</li></ul></li></ul><p><strong>valueForKey 流程</strong></p><p><img src="/img/ios/octx/valuekey.png"></p><p><strong>setValue 流程</strong></p><p><img src="/img/ios/octx/setvaluekey.png"></p><hr><h3 id="属性关键字"><a href="#属性关键字" class="headerlink" title="属性关键字"></a>属性关键字</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><ul><li>atomic</li><li>noatomic</li></ul><p>atomic: 赋值获取保证线程安全，操作不保证</p><h4 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h4><ul><li><p>修饰基本数据类型，如 int bool 等</p></li><li><p>修饰对象类时，不改变其引用技数</p></li><li><p>会产生悬垂指针</p></li></ul><h4 id="weak"><a href="#weak" class="headerlink" title="weak"></a>weak</h4><ul><li>不改变被修饰对象的引用计数</li><li>所指的对象在被释放后悔自动置为nil</li></ul><h4 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h4><p>浅拷贝</p><p><img src="/img/ios/octx/qicopy.png"></p><p>深拷贝</p><p><img src="/img/ios/octx/mutablecopy.png"></p><p>cop总结</p><p><img src="/img/ios/octx/copyzj.png"></p><ul><li><p>可变对象的copy和mutableCopy都是深拷贝</p></li><li><p>不可变对象的copy是浅拷贝， mutableCopy是深拷贝</p></li><li><p>copy方法返回的都是不可变对象</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS  非指针型ISA(NONPOINTER_ISA)</title>
    <link href="/2019/10/09/iOS-isa/"/>
    <url>/2019/10/09/iOS-isa/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是NONPonter-isa？"><a href="#什么是NONPonter-isa？" class="headerlink" title="什么是NONPonter_isa？"></a>什么是NONPonter_isa？</h3><p> <strong>在iOS arm64架构下，isa指针在内存中占64位/bit,但是实际上并不会使用所有的地址空间,为了提高内存的利用率，在剩余的bit</strong><br> <strong>存储了关于内存管理的一些相关内容，所以说这个叫非指针型的isa</strong></p><h3 id="逐一分析这64个bit都存储那些内容"><a href="#逐一分析这64个bit都存储那些内容" class="headerlink" title="逐一分析这64个bit都存储那些内容"></a>逐一分析这64个bit都存储那些内容</h3><ol><li><strong>0-15 位内存地址</strong></li></ol><p><img src="/img/ios/isa15.png"></p><ul><li>indexed:0 代表的是纯isa 指针代表类对象的内存地址 1代表这个isa存储的不仅是类对象的地址而且内存管理方面的数据</li><li>has_assoc: 代表是否有关联对象  0 代表没有 1代表有</li><li>hass_cxx_ditor: 当前对象是否有使用c++</li><li>shifitcls: 当前对象类类对象的指针地址</li></ul><ol start="2"><li><strong>16-31 位内存地址</strong></li></ol><p><img src="/img/ios/isa31.png"></p><ol start="3"><li><p><strong>32-47 位内存地址</strong></p><p><img src="/img/ios/isa47.png"></p></li></ol><ul><li>magic: 不影响内存管理方面解答</li><li>wekkly_referenced: 标识了是否有 弱引用指针</li><li>deallocating: 当前对象是否正在进行dealloc 操作</li><li>has_sidetable_rc: 当前isa指针当中存储的引用计数已经达到了上限，需要外挂一个sidetable这样一个数据结构存储相关的引用计数内容</li><li>extra_rc: 额外的引用计数 当引用计数很小的时候 存储在isa 指针当中</li></ul><ol start="4"><li><strong>48-63 位内存地址</strong></li></ol><p><img src="/img/ios/isa63.png"></p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
