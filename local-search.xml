<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>常见排序</title>
    <link href="/2021/01/31/Sort/"/>
    <url>/2021/01/31/Sort/</url>
    
    <content type="html"><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p> 冒泡排序是一种简单直观的排序算法，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端</p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ul><li><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p></li><li><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p></li><li><p>针对所有的元素重复以上的步骤，除了最后一个。</p></li><li><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较</p></li></ul><h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><p><img src="/img/ittree/sort/bubbleSort.gif"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BubbleSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span>  i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">let</span> bool = <span class="hljs-literal">false</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; arr.length - <span class="hljs-number">1</span> - i; j++) &#123;<br>           <span class="hljs-keyword">if</span> (arr[j + <span class="hljs-number">1</span>] &lt; arr[j]) &#123;<br>           <span class="hljs-keyword">let</span> tmp = arr[j]<br>           arr[j] = arr[j + <span class="hljs-number">1</span>]<br>           arr[j + <span class="hljs-number">1</span>] = tmp<br>           bool = <span class="hljs-literal">true</span> <br>          &#125;<br>       &#125;<br>       <span class="hljs-keyword">if</span> (bool == <span class="hljs-literal">false</span> ) &#123;<br>             <span class="hljs-keyword">break</span><br>         &#125;<br>    &#125;<br>   <span class="hljs-keyword">return</span> arr<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>选择排序是一种简单直观的排序算法<br>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置<br>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。<br>重复第二步，直到所有元素均排序完毕</p><h4 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h4><p><img src="/img/ittree/sort/selectionSort.gif"></p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">selectionSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>       <span class="hljs-keyword">let</span> minindex = i<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.length; j++) &#123;<br>           <span class="hljs-keyword">if</span> (arr[j] &lt; arr[minindex]) &#123;<br>                      minindex = j<br>               &#125;<br>           &#125;<br>           <span class="hljs-keyword">if</span> (minindex != i) &#123;<br>                 <span class="hljs-keyword">let</span> tmp = arr[minindex]<br>                  arr[minindex] = arr[i]<br>                 arr[i] = tmp<br>             &#125;<br>         &#125;<br>         <span class="hljs-keyword">return</span> arr<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>插入排序是一种简单直观的排序算法，工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入<br>类似于我们生活中打扑克</p><h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><ul><li><p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p></li><li><p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置</p></li></ul><h4 id="演示-2"><a href="#演示-2" class="headerlink" title="演示"></a>演示</h4><p><img src="/img/ittree/sort/insertionSort.gif"></p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> len = arr.length<br>  <span class="hljs-keyword">var</span>  preIndex,current<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span>  i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>       preIndex = i - <span class="hljs-number">1</span><br>       current = arr[i]<br><br>       <span class="hljs-keyword">while</span>(preIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;<br>          arr[preIndex + <span class="hljs-number">1</span>] = arr[preIndex];<br>          preIndex--;<br>       &#125; <br>            <br>           arr[preIndex + <span class="hljs-number">1</span>] = current<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr<br><br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。<br>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。<br>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了</p><h4 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h4><ol><li><p>从数列中挑出一个元素，称为 “基准”（pivot）;</p></li><li><p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p></li><li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序</p></li></ol><h4 id="演示-3"><a href="#演示-3" class="headerlink" title="演示"></a>演示</h4><p><img src="/img/ittree/sort/quickSort.gif"></p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">qiuckSort</span>(<span class="hljs-params">arr,left, right</span>) </span>&#123;<br>    <br>         <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>          <span class="hljs-keyword">let</span> index = getIndex(arr,left,right)<br>          qiuckSort(arr,left,index - <span class="hljs-number">1</span>)<br>            qiuckSort(arr,index + <span class="hljs-number">1</span> ,right)   <br>         &#125;<br>       <span class="hljs-keyword">return</span> arr<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getIndex</span>(<span class="hljs-params">arr,low,hight</span>) </span>&#123;<br> <span class="hljs-keyword">let</span> pivot = arr[low]<br><br>        <span class="hljs-keyword">while</span>(low &lt; hight) &#123;<br>            <span class="hljs-keyword">while</span>(low &lt; hight &amp;&amp; arr[hight] &gt;= pivot) &#123;<br>            hight--<br>            &#125;<br>            arr[low] = arr[hight]<br>             <span class="hljs-keyword">while</span>(low &lt;  hight &amp;&amp; arr[low] &lt;= pivot) &#123;<br>            low++<br>            &#125;<br>           arr[hight] = arr[low]<br>        &#125;<br>        arr[low] = pivot<br><br>        <span class="hljs-keyword">return</span> low<br> &#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ItTree</category>
      
    </categories>
    
    
    <tags>
      
      <tag>basic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>this 指向问题</title>
    <link href="/2021/01/07/this/"/>
    <url>/2021/01/07/this/</url>
    
    <content type="html"><![CDATA[<h3 id="JavaScript-this-关键字"><a href="#JavaScript-this-关键字" class="headerlink" title="JavaScript this 关键字"></a>JavaScript this 关键字</h3><p>面向对象语言中 this 表示当前对象的一个引用。<br>但在 JavaScript 中 this 不是固定不变的，它会随着执行境的改变而改变</p><p><strong>哪个对象调用函数，函数里面的this指向哪个对象</strong></p><p><strong>可以分为这5种情况讨论</strong></p><ol><li>作为普通函数被调用</li><li>作为对象属性被调用</li><li>作为构造函数</li><li>call和apply的应用</li><li>箭头函数</li></ol><h3 id="普通函数被调用"><a href="#普通函数被调用" class="headerlink" title="普通函数被调用"></a>普通函数被调用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;<br>       <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>   &#125;<br>test()<span class="hljs-comment">// Window</span><br></code></pre></td></tr></table></figure><h3 id="对象属性被调用"><a href="#对象属性被调用" class="headerlink" title="对象属性被调用"></a>对象属性被调用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<br>        id:<span class="hljs-string">&#x27;123&#x27;</span>,<br>        <span class="hljs-function"><span class="hljs-title">func</span>(<span class="hljs-params"></span>)</span> &#123;<br>          <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.id);<br>          <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>        &#125;,<br>    &#125;<br>    obj.func();<span class="hljs-comment">// 123 obj</span><br></code></pre></td></tr></table></figure><h3 id="构造函数调用"><a href="#构造函数调用" class="headerlink" title="构造函数调用"></a>构造函数调用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> objclass = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>       <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<span class="hljs-comment">//objclass</span><br>  &#125;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> objclass()<br></code></pre></td></tr></table></figure><p>在构造函数里面返回一个对象，会直接返回这个对象，而不是执行构造函数后创建的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-keyword">let</span> objclass = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.a =<span class="hljs-string">&#x27;1234&#x27;</span><br>     <span class="hljs-keyword">return</span> &#123;<br>         b:<span class="hljs-string">&#x27;456&#x27;</span><br>     &#125;<br>&#125;<br><span class="hljs-keyword">let</span> item  = <span class="hljs-keyword">new</span> objclass()<br><span class="hljs-built_in">console</span>.log(item.a)<span class="hljs-comment">//undefined</span><br></code></pre></td></tr></table></figure><h3 id="call和apply-调用"><a href="#call和apply-调用" class="headerlink" title="call和apply 调用"></a>call和apply 调用</h3><p>apply和call简单来说就是会改变传入函数的this指向</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj1 =  &#123;<br>         name:<span class="hljs-string">&#x27;zhangsan&#x27;</span><br>     &#125;<br>     <span class="hljs-keyword">let</span> obj2 = &#123;<br>         name: <span class="hljs-string">&#x27;lisi&#x27;</span>,<br>         <span class="hljs-function"><span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span> &#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>         &#125;<br>     &#125;<br>     obj2.fn.call(obj1) <span class="hljs-comment">// zhangsan</span><br></code></pre></td></tr></table></figure><p>call 和 apply 两个主要用途：</p><ul><li><p>改变 this 的指向（把 this 从 obj2 指向到 obj1 ）</p></li><li><p>方法借用（ obj1 没有 fn ，只是借用 obj2 方法）</p></li></ul><h3 id="箭头函数调用"><a href="#箭头函数调用" class="headerlink" title="箭头函数调用"></a>箭头函数调用</h3><p>箭头函数没有this，这里的this引用的是最近作用域(aaa函数里的this)的this</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>     <span class="hljs-function"><span class="hljs-title">aaa</span>(<span class="hljs-params"></span>)</span> &#123;<br>       <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>         <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>           <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>) <span class="hljs-comment">//window</span><br>         &#125;)<br>         <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>           <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>) <span class="hljs-comment">//window</span><br>         &#125;)<br>       &#125;)<br>       <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>         <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>           <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>) <span class="hljs-comment">//window</span><br>         &#125;)<br>         <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>           <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>) <span class="hljs-comment">//obj</span><br>         &#125;)<br>       &#125;)<br>     &#125;<br>   &#125;<br>   obj.aaa()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>H5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6特性</title>
    <link href="/2021/01/07/es6/"/>
    <url>/2021/01/07/es6/</url>
    
    <content type="html"><![CDATA[<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>​ES6之前没有块级作用域，ES5的var没有块级作用域的概念，只有function有作用域的概念，ES6的let、const引入了块级作用域。<br>​ES5之前if和for都没有作用域，所以很多时候需要使用function的作用域，比如闭包。</p><h4 id="什么是变量作用域"><a href="#什么是变量作用域" class="headerlink" title="什么是变量作用域"></a>什么是变量作用域</h4><p>​变量在什么范围内可用，类似Java的全局变量和局部变量的概念，全局变量，全局都可用，局部变量只在范围内可用。ES5之前的var是没有块级作用域的概念，使用var声明的变量就是全局的。</p><h4 id="没有块级作用域造成的问题"><a href="#没有块级作用域造成的问题" class="headerlink" title="没有块级作用域造成的问题"></a>没有块级作用域造成的问题</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> func;<br><span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>)&#123;<br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;zzz&#x27;</span>;<br>func = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">console</span>.log(name);<br>&#125;<br>func();<br> &#125;<br>name = <span class="hljs-string">&#x27;ttt&#x27;</span>;<br>func();<br><span class="hljs-built_in">console</span>.log(name);<br></code></pre></td></tr></table></figure><p>​代码输出结果为<code>&#39;zzz&#39;,&#39;ttt&#39;,&#39;ttt&#39;</code>，第一次调用func()，此时name=‘zzz’，在if块外将name置成‘ttt’，此时生效了，if没有块级作用域。</p><h4 id="for块级"><a href="#for块级" class="headerlink" title="for块级"></a>for块级</h4><p>​    定义五个按钮，增加事件，点击哪个按钮打印“第哪个按钮被点击了”。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;ie=edge&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>块级作用域<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>按钮1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>按钮2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>按钮3<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>按钮4<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>按钮5<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">      <span class="hljs-comment">// 3.没有块级作用域引起的问题:for块级</span></span><br><span class="javascript">      <span class="hljs-keyword">var</span> btns = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&quot;button&quot;</span>);</span><br><span class="javascript">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; btns.length; i++) &#123;</span><br><span class="javascript">        btns[i].addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">param</span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;第&quot;</span>+i+<span class="hljs-string">&quot;个按钮被点击了&quot;</span>);</span><br>        &#125;);<br>      &#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>​    for块级中使用<code>var</code>声明变量i时，是全局变量，点击任意按钮结果都是“第五个按钮被点击了”。说明在执行<code>btns[i].addEventListener(&#39;click&#39;,function())</code>时，for块级循环已经走完，此时<code>i=5</code>，所有添加的事件的i都是5。</p><p>​    改造上述代码，将for循环改造，由于函数有作用域，使用闭包能解决上述问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 使用闭包,函数有作用域</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; btns.length; i++) &#123;<br>  (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">i</span>) </span>&#123;<br>    btns[i].addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">param</span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;第&quot;</span>+i+<span class="hljs-string">&quot;个按钮被点击了&quot;</span>);<br>    &#125;)<br>  &#125;)(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    结果如图所示，借用函数的作用域解决块级作用域的问题，因为有块级作用域，每次添加的i都是当前i。</p><p><strong>在ES6中使用let/const解决块级作用域问题，let和const有块级作用域，const定义常量，在for块级中使用let解决块级作用域问题。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ES6使用let/const</span><br><span class="hljs-keyword">const</span> btns = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&quot;button&quot;</span>);*<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; btns.length; i++) &#123;<br>  btns[i].addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">param</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;第&quot;</span>+i+<span class="hljs-string">&quot;个按钮被点击了&quot;</span>);<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>​结果和使用闭包解决一致。</p><h3 id="const-使用"><a href="#const-使用" class="headerlink" title="const 使用"></a>const 使用</h3><p>1.const用来定义常量，赋值知乎不能再赋值，再次赋值会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script&gt;<br>    <span class="hljs-comment">//1.定义常量，赋值后不能再赋值，在赋值报错</span><br>    <span class="hljs-keyword">const</span> count = <span class="hljs-number">1</span><br>    <span class="hljs-comment">// count = 2</span><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>​    2.const不能只声明不赋值，会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script&gt;<br>    <span class="hljs-comment">//2.只声明不赋值，必须赋值</span><br>    <span class="hljs-comment">// const count;</span><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>​3.const常量含义是你不能改变其指向的对象，例如user，都是你可以改变user属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script&gt;<br>    <span class="hljs-comment">//3.常量的含义是你不能改变其指向的对象user，但是你可以改变user属性</span><br>    <span class="hljs-keyword">const</span> user = &#123;<br>        name:<span class="hljs-string">&quot;zzz&quot;</span>,<br>        age:<span class="hljs-number">24</span>,<br>        height:<span class="hljs-number">175</span><br>    &#125;<br>    <span class="hljs-built_in">console</span>.log(user)<br>    user.name = <span class="hljs-string">&quot;ttt&quot;</span><br>    user.age = <span class="hljs-number">22</span><br>    user.height = <span class="hljs-number">188</span><br>    <span class="hljs-built_in">console</span>.log(user)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="ES6的对象属性增强型写法"><a href="#ES6的对象属性增强型写法" class="headerlink" title="ES6的对象属性增强型写法"></a>ES6的对象属性增强型写法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;zzz&quot;</span>;<br><span class="hljs-keyword">const</span> age = <span class="hljs-number">18</span>;<br><span class="hljs-keyword">const</span> user = &#123;<br>  name:name,<br>  age:age<br>&#125;<br><span class="hljs-built_in">console</span>.log(user);<br></code></pre></td></tr></table></figure><p>​    ES6写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;zzz&quot;</span>;<br><span class="hljs-keyword">const</span> age = <span class="hljs-number">18</span>;<br><span class="hljs-keyword">const</span> user = &#123;<br>name,age<br>&#125;<br><span class="hljs-built_in">console</span>.log(user);<br></code></pre></td></tr></table></figure><h3 id="ES6对象的函数增强型写法"><a href="#ES6对象的函数增强型写法" class="headerlink" title="ES6对象的函数增强型写法"></a>ES6对象的函数增强型写法</h3><p>​    ES6之前对象内定义函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;<br>  run:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;奔跑&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>  ES6写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span>&#123;<br>     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;奔跑&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><blockquote><p>传统定义函数的方式</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> aaa = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">param</span>) </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>对象字面量中定义函数</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;<br>    bbb (param) &#123;  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ES6中的箭头函数</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//const ccc = (参数列表) =&gt; &#123;&#125;</span><br>  <span class="hljs-keyword">const</span> ccc = <span class="hljs-function">() =&gt;</span> &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="箭头函数的参数和返回值"><a href="#箭头函数的参数和返回值" class="headerlink" title="箭头函数的参数和返回值"></a>箭头函数的参数和返回值</h3><blockquote><p>1.放入两个参数</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> sum = <span class="hljs-function">(<span class="hljs-params">num1,num2</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> num1 + num2 <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>2.放入一个参数,()可以省略</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> power = <span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> num * num<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="函数内部"><a href="#函数内部" class="headerlink" title="函数内部"></a>函数内部</h4><blockquote><p>1.函数中代码块中有多行代码</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> test = <span class="hljs-function">() =&gt;</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;hello zzz&quot;</span>)<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;hello vue&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>2.函数代码块中只有一行代码，可以省略return</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// const mul = (num1,num2) =&gt; &#123;</span><br><span class="hljs-comment">//   return num1 * num2</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-keyword">const</span> mul = <span class="hljs-function">(<span class="hljs-params">num1,num2</span>) =&gt;</span> num1* num2<br><span class="hljs-comment">// const log = () =&gt; &#123;</span><br><span class="hljs-comment">//   console.log(&quot;log&quot;)</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-keyword">const</span> log = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;log&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>####filter过滤函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> nums = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">77</span>,<span class="hljs-number">55</span>,<span class="hljs-number">100</span>,<span class="hljs-number">200</span>]<br><span class="hljs-comment">//要求获取nums中大于50的数</span><br><span class="hljs-comment">//回调函数会遍历nums中每一个数，传入回调函数，在回调函数中写判断逻辑，返回true则会被数组接收，false会被拒绝</span><br><span class="hljs-keyword">let</span> newNums = nums.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">num</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">50</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br> &#125;)<br><br> <span class="hljs-comment">//可以使用箭头函数简写</span><br> <span class="hljs-keyword">let</span> newNums = nums.filter(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> num &gt;<span class="hljs-number">50</span>)<br></code></pre></td></tr></table></figure><h4 id="map高阶函数"><a href="#map高阶函数" class="headerlink" title="map高阶函数"></a>map高阶函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 要求将已经过滤的新数组每项乘以2</span><br><span class="hljs-comment">//map函数同样会遍历数组每一项，传入回调函数为参数，num是map遍历的每一项，回调函数function返回值会被添加到新数组中</span><br><span class="hljs-keyword">let</span> newNums2 = newNums.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">num</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> num * <span class="hljs-number">2</span><br> &#125;)<br> <span class="hljs-comment">//简写</span><br><span class="hljs-comment">//  let newNums2 = newNums.map(num =&gt; num * 2)</span><br><span class="hljs-built_in">console</span>.log(newNums2);<br></code></pre></td></tr></table></figure><h4 id="reduce高阶函数"><a href="#reduce高阶函数" class="headerlink" title="reduce高阶函数"></a>reduce高阶函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 3.reduce高阶函数</span><br><span class="hljs-comment">//要求将newNums2的数组所有数累加</span><br><span class="hljs-comment">//reduce函数同样会遍历数组每一项，传入回调函数和‘0’为参数，0表示回调函数中preValue初始值为0，回调函数中参数preValue是每一次回调函数function返回的值，currentValue是当前值</span><br><span class="hljs-comment">//例如数组为[154, 110, 200, 400],则回调函数第一次返回值为0+154=154，第二次preValue为154，返回值为154+110=264，以此类推直到遍历完成</span><br><span class="hljs-keyword">let</span> newNum = newNums2.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">preValue,currentValue</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> preValue + currentValue<br> &#125;,<span class="hljs-number">0</span>)<br><span class="hljs-comment">//简写</span><br><span class="hljs-comment">// let newNum = newNums2.reduce((preValue,currentValue) =&gt; preValue + currentValue)</span><br><span class="hljs-built_in">console</span>.log(newNum);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>H5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vuex</title>
    <link href="/2021/01/07/vuex/"/>
    <url>/2021/01/07/vuex/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是Vuex"><a href="#什么是Vuex" class="headerlink" title="什么是Vuex"></a>什么是Vuex</h3><p>Vuex就是一个状态管理模式，为什么叫模式？因为Vuex包含了一套对state(状态)的操作规范，集中存储管理应用的所有组件的状态。</p><ul><li><p>简单来说就是管理各个组件共享的数据，类似session</p></li><li><p>session可以存数据，存的过程就是管理，数据的每一次赋值就是当次状态。</p></li><li><p>Vuex在Vue实例顶层中。</p><p>Vuex也可以理解为java中的一个map，这个map是static（静态资源）的，每次获取map的值，都需要调用java的api，比如map.get(key)获取对应的值，也可以放入数据map.put(data)，而且这个数据是所有类都可以调用的，只需要导入这个map就能使用里面的共享数据。</p><p>不了解java也没关系，你也可以理解成为百度百科就是一个容纳百科知识的容器，你要搜vuex，百科就会出现vuex的描述，这个搜索就是获取状态，如果你角色百科的vuex描述有误。你也可以发起修改操作，改成正确的vuex描述，这个修改操作就是修改vuex在百科里面的状态。当然你可以搜索修改vuex，别人也可以，因为这个状态是共享的。</p><p>简单来看实现这个功能好像我们自己封装一个对象就能实现，但是Vuex有一个特性就是响应式。如果我们自己封装对象想做到完美响应式比较麻烦，所有Vuex帮我们做了这个事情。</p></li></ul><blockquote><p>什么状态需要Vuex去管理？</p></blockquote><ul><li>比如用户的登录的状态（token）、用户的信息（头像、名称、地理位置信息）等等</li><li>比如商品的收藏，购物车的商品等等</li><li>这些状态应该是响应式的，用户昵称、头像修改了需要响应</li></ul><p><img src="/img/h5/vue/vuex/19-01.png"></p><ul><li><strong>state</strong>，驱动应用的数据源；</li><li><strong>view</strong>，以声明方式将 <strong>state</strong> 映射到视图；</li><li><strong>actions</strong>，响应在 <strong>view</strong> 上的用户输入导致的状态变化。</li></ul><p>这是一个单页面数据流向，比如想要修改用户昵称，当前用户昵称的状态是A，通过输入框输入了新的昵称B，调用ajax请求后端修改成功后将state改成B，然后视图响应用户昵称的变化从A到B。</p><p>但是，当我们的应用遇到<strong>多个组件共享状态</strong>时，单向数据流的简洁性很容易被破坏：</p><ul><li>多个视图依赖于同一状态。</li><li>来自不同视图的行为需要变更同一状态。</li><li>所以我们需要vuex的规范操作来管理状态。</li></ul><h3 id="Vuex的核心概念"><a href="#Vuex的核心概念" class="headerlink" title="Vuex的核心概念"></a>Vuex的核心概念</h3><ul><li>State</li><li>Getters</li><li>Mutation</li><li>Action</li><li>Moudule</li></ul><h3 id="Vuex的流程"><a href="#Vuex的流程" class="headerlink" title="Vuex的流程"></a>Vuex的流程</h3><p><img src="/img/h5/vue/vuex/19-03.png"></p><ul><li>Vue Components是vue组件</li><li>Mutations ：更改 Vuex 的 store 中的状态的唯一方法是提交 mutation</li><li>State 是vuex中状态的集合</li><li>Actions与Mutations 类似，经常与后端交互，不同在于：<ul><li>Action 提交的是 mutation，而不是直接变更状态。</li><li>Action 可以包含任意异步操作。</li></ul></li></ul><p>组件中修改state，通过提交 mutation，修改完成后vuex帮我们响应到vue组件上。</p><blockquote><p>修改index.js使用mutation</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 2.创建对象</span><br><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>  state: &#123; <span class="hljs-comment">// 状态集合</span><br>    count: <span class="hljs-number">0</span> <span class="hljs-comment">// 具体的状态数据</span><br>  &#125;,<br>  mutations: &#123; <span class="hljs-comment">// 操作修改state（状态）</span><br>    increment (state) &#123; <span class="hljs-comment">// 增加</span><br>      state.count++<br>    &#125;,<br>    decrement (state) &#123; <span class="hljs-comment">// 减少</span><br>      state.count--<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div id&#x3D;&quot;app&quot;&gt;<br>    &lt;h3&gt;&#123;&#123; message &#125;&#125;&lt;&#x2F;h3&gt;<br>    &lt;h3&gt;&#123;&#123; $store.state.count &#125;&#125;&lt;&#x2F;h3&gt;<br>    &lt;button @click&#x3D;&quot;add&quot;&gt;+&lt;&#x2F;button&gt;<br>    &lt;button @click&#x3D;&quot;sub&quot;&gt;-&lt;&#x2F;button&gt;<br>    &lt;hello-vuex &#x2F;&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br><br>&lt;script&gt;<br>import HelloVuex from &#39;.&#x2F;components&#x2F;HelloVuex&#39;<br><br>export default &#123;<br>  name: &#39;App&#39;,<br>  data () &#123;<br>    return &#123;<br>      message: &#39;&#39;<br>    &#125;<br>  &#125;,<br>  components: &#123;<br>    HelloVuex<br>  &#125;,<br>  methods: &#123;<br>    add () &#123;<br>      this.$store.commit(&#39;increment&#39;)<br>    &#125;,<br>    sub () &#123;<br>      this.$store.commit(&#39;decrement&#39;)<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><h3 id="State（单一状态树）"><a href="#State（单一状态树）" class="headerlink" title="State（单一状态树）"></a>State（单一状态树）</h3><p>Vuex 使用<strong>单一状态树</strong>——是的，用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源 (<a href="https://en.wikipedia.org/wiki/Single_source_of_truth">SSOT</a>)”而存在。。这也意味着，每个应用将仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。</p><p>简单说就是把数据所有有关的数据封装到一个对象中，这个对象就是store实例，无论是数据的状态（state），以及对数据的操作（mutation、action）等都在store实例中，便于管理维护操作。<br>直接通过<code>this.$store.state</code>获取state对象。</p><h3 id="Mutation（状态更新）"><a href="#Mutation（状态更新）" class="headerlink" title="Mutation（状态更新）"></a>Mutation（状态更新）</h3><ul><li><p>Vuex的store状态更新的唯一方式：<strong>提交Mutation</strong></p></li><li><p>Mutation主要包括两个部分：</p><ol><li><p>字符串的<strong>事件类型（type）</strong></p></li><li><p>一个<strong>回调函数（handler）</strong>，这个回调函数就是我们实际进行状态更改的地方，该回调函数的<strong>第一个参数就是state</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">mutation: &#123;<br>    increment (state) &#123;<br>        state.count++<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>通过Mutation更新</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">mutation () &#123;<br><span class="hljs-built_in">this</span>.$store.commit(<span class="hljs-string">&#x27;increment&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="mutation-提交风格"><a href="#mutation-提交风格" class="headerlink" title="mutation 提交风格"></a>mutation 提交风格</h4><ol><li><p>普通提交风格</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">this</span>.$store.commot(<span class="hljs-string">&#x27;increment&#x27;</span>, count)<br></code></pre></td></tr></table></figure><p>此时count传过去的就是count=10</p></li><li><p>特殊的提交封装</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">this</span>.$store.commit(&#123;<br>type: <span class="hljs-string">&#x27;addCount&#x27;</span>,<br>count<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">addCount (state, payload) &#123; <span class="hljs-comment">// 此时传入的就不是一个count值了，而是一个对象</span><br>state.count += payload.count<br>&#125;<br></code></pre></td></tr></table></figure><p>此时count传过去是一个对象payload（载荷）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>type: <span class="hljs-string">&#x27;incrementCount&#x27;</span>,<br>count: <span class="hljs-number">10</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h4></li></ol><p>处理异步操作，如网络请求等，然后再使用mutation操作更新</p><p>Action 类似于 mutation，不同在于：</p><ul><li>Action 提交的是 mutation，而不是直接变更状态。</li><li>Action 可以包含任意异步操作。</li></ul><ol><li>新增一个mutation</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">updateName (state, name) &#123;<br>state.user.name = name<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>新增一个actions</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">actions: &#123;<br>    <span class="hljs-comment">// context：上下文</span><br>    aUpdateInfo (context, name) &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        context.commit(updateName, <span class="hljs-number">12</span>)<br>        &#125;, <span class="hljs-number">1000</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>提交方法</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">aUpdateInfo () &#123;<br><span class="hljs-built_in">this</span>.$store.dispatch(<span class="hljs-string">&#x27;aUpdateInfo&#x27;</span>, <span class="hljs-string">&#x27;lisi&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>点击按钮之后，信息修改了，dev-tools也能跟踪到state的变化。通过<code>$store.dispacth()</code>方法来调用actions，发送异步请求，在actions中需要提交mutation来修改state。</p><h3 id="moudules（模块）"><a href="#moudules（模块）" class="headerlink" title="moudules（模块）"></a>moudules（模块）</h3><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p><p>为了解决以上问题，Vuex 允许我们将 store 分割成<strong>模块（module）</strong>。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> moduleA = &#123;<br>  state: <span class="hljs-function">() =&gt;</span> (&#123; ... &#125;),<br>  mutations: &#123; ... &#125;,<br>  actions: &#123; ... &#125;,<br>  getters: &#123; ... &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> moduleB = &#123;<br>  state: <span class="hljs-function">() =&gt;</span> (&#123; ... &#125;),<br>  mutations: &#123; ... &#125;,<br>  actions: &#123; ... &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>  modules: &#123;<br>    a: moduleA,<br>    b: moduleB<br>  &#125;<br>&#125;)<br><br>store.state.a <span class="hljs-comment">// -&gt; moduleA 的状态</span><br>store.state.b <span class="hljs-comment">// -&gt; moduleB 的状</span><br></code></pre></td></tr></table></figure><h4 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h4><ol><li>应用层级的状态应该集中到单个 store 对象中。</li><li>提交 <strong>mutation</strong> 是更改状态的唯一方法，并且这个过程是同步的。</li><li>异步逻辑都应该封装到 <strong>action</strong> 里面。</li></ol><p>只要你遵守以上规则，如何组织代码随你便。如果你的 store 文件太大，只需将 action、mutation 和 getter 分割到单独的文件。</p><p>对于大型应用，我们会希望把 Vuex 相关代码分割到模块中。下面是项目结构示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">├── index.html<br>├── main.js<br>├── api<br>│   └── ... <span class="hljs-comment"># 抽取出API请求</span><br>├── components<br>│   ├── App.vue<br>│   └── ...<br>└── store<br>    ├── index.js          <span class="hljs-comment"># 我们组装模块并导出 store 的地方</span><br>    ├── actions.js        <span class="hljs-comment"># 根级别的 action</span><br>    ├── mutations.js      <span class="hljs-comment"># 根级别的 mutation</span><br>    └── modules<br>        ├── cart.js       <span class="hljs-comment"># 购物车模块</span><br>        └── products.js   <span class="hljs-comment"># 产品模块</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue-router</title>
    <link href="/2021/01/07/vue-router/"/>
    <url>/2021/01/07/vue-router/</url>
    
    <content type="html"><![CDATA[<h3 id="路由简介"><a href="#路由简介" class="headerlink" title="路由简介"></a>路由简介</h3><p><strong>什么是路由？</strong></p><ul><li><p>路由就是通过互联的网络把信息用源地址传送到目的地的活动</p></li><li><p>路由提供了两种机制：路由和传送</p><ul><li>路由是决定数据包从来源到目的地的路径</li><li>转送就是将数据转移</li></ul></li><li><p>路由表</p><ul><li>路由表本质就是一个映射表，决定了数据包的指向</li></ul></li></ul><h3 id="前端-后端路由"><a href="#前端-后端路由" class="headerlink" title="前端/后端路由"></a>前端/后端路由</h3><ul><li><p>后端渲染（服务端渲染）<br> jsp技术<br> 后端路由，后端处理URL和页面映射关系，例如springmvc中的@requestMapping注解配置的URL地址，映射前端页面</p></li><li><p>前后端分离（ajax请求数据）<br> 后端只负责提供数据<br> 静态资源服务器（html+css+js）<br> ajax发送网络请求后端服务器，服务器回传数据<br> js代码渲染dom</p></li><li><p>单页面富应用（SPA页面）<br> 前后端分离加上前端路由，前端路由的url映射表不会向服务器请求，是单独url的的页面自己的ajax请求后端，后端只提供api负责响应数据请求。改变url，页面不进行整体的刷新。<br> 整个网站只有一个html页面。</p></li></ul><h3 id="URL的hash和HTML5的history"><a href="#URL的hash和HTML5的history" class="headerlink" title="URL的hash和HTML5的history"></a>URL的hash和HTML5的history</h3><h4 id="URL的hash"><a href="#URL的hash" class="headerlink" title="URL的hash"></a>URL的hash</h4><ul><li>URL的hash是通过锚点(#)，其本质上改变的是window.location的href属性。</li><li>可以通过直接赋值location.hash来改变href，但是页面并不会发生刷新。</li></ul><p><img src="/img/h5/vue/vuerouter/17-1.png"></p><p>使用命令<code>vue init webpack 01-vue-router-vuecli2</code>创建新的vuecli2工程,等待创建完成后，使用<code>npm run dev</code>启动服务器，在浏览器通过 <a href="http://localhost:8080/">http://localhost:8080</a> 进入工程主页。 测试通过改变hash，查看是否会刷新页面，浏览器的url地址是否改变。</p><p><img src="/img/h5/vue/vuerouter/17-2.gif"></p><p><strong>结论</strong></p><p>测试发现url的地址栏改变了变成了<a href="http://localhost:8080/#/zty">http://localhost:8080/#/zty</a>  ，通过查看network发现只有favicon.ico资源重新请求了，这个是工程的logo图标，其他资源都未请求。可以通过改变hash改变url，此时页面是未刷新的。</p><p>vue-router其实用的就是这样的机制，改变url地址，这个url地址存在一份路由映射表里面，比如<code>/user</code>代表要请求用户页面，只要配置了这个路由表（路由关系），就可以前端跳转而不刷新页面，所有的数据请求都走ajax。</p><h4 id="HTML5的history模式"><a href="#HTML5的history模式" class="headerlink" title="HTML5的history模式"></a>HTML5的history模式</h4><blockquote><p>pushState</p></blockquote><p>同样的使用HTML5的history模式也是不会刷新页面的,history对象栈结构，先进后出，pushState类似压入栈中，back是回退。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">hristory.pushState(&#123;&#125;, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;/foo&#x27;</span>)<br>history.back()<br></code></pre></td></tr></table></figure><p><img src="/img/h5/vue/vuerouter/17-3.png"></p><blockquote><p>replaceState</p></blockquote><p>replaceState模式与pushState模式区别在于replaceState模式浏览器没有返回只是替换，不是压入栈中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">history.replaceState(&#123;&#125;, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;home&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="/img/h5/vue/vuerouter/17-4.png"></p><blockquote><p>go</p></blockquote><p>go只能在pushState模式中使用，go是前进后退到哪个历史页面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">history.go(-<span class="hljs-number">1</span>)<span class="hljs-comment">//回退一个页面</span><br>history.go(<span class="hljs-number">1</span>)<span class="hljs-comment">//前进一个页面</span><br>history.forward()<span class="hljs-comment">//等价于go(1)</span><br>history.back()<span class="hljs-comment">//等价于go(-1)</span><br></code></pre></td></tr></table></figure><h3 id="vue-router的安装配置"><a href="#vue-router的安装配置" class="headerlink" title="vue-router的安装配置"></a>vue-router的安装配置</h3><ol><li><p>使用<code>npm install vue-router --save</code>来安装vue-router插件模块</p></li><li><p>在模块化工程中使用他(因为是一个插件，所以可以通过Vue.user来安装路由功能)</p><ul><li>在src下创建一个router文件夹（一般安装vue-router时候会自动创建）用来存放vue-router的路由信息导入路由对象，并且调用<strong>Vue.use(VueRouter)</strong></li><li>创建路由实例，并且传入路由<strong>映射配置</strong></li><li>在vue实例中挂载创建的<strong>路由实例对象</strong></li></ul><blockquote><p>router文件夹中的index.js</p></blockquote></li></ol><h3 id="lt-router-link-gt-的其他属性"><a href="#lt-router-link-gt-的其他属性" class="headerlink" title="&lt;router-link&gt;的其他属性"></a><code>&lt;router-link&gt;</code>的其他属性</h3><ol><li><p><code>to</code>属性：用于跳转到指定路径。</p></li><li><p><code>tag</code>属性：可以指定<code>&lt;router-link&gt;</code>之后渲染成什么组件使用<code>&lt;router-link to=&#39;/home&#39; tag=&#39;button&#39;&gt;</code>会被渲染成一个按钮，而不是a标签。</p></li><li><p><code>relapce</code>属性：在history模式下指定<code>&lt;router-link to=&#39;/home&#39; tag=&#39;button&#39; replace&gt;</code>使用<code>replaceState</code>而不是pushState，此时浏览器的返回按钮是不能使用的。</p></li><li><p><code>active-class</code>属性：当<code>&lt;router-link&gt;</code>对应的路由匹配成功的时候，会自动给当前元素设置一个<code>router-link-active</code>的class，设置active-class可以修改默认的名称。</p></li></ol><ul><li><p>在进行高亮显示的导航菜单或者底部tabbar时，会用到该属性</p></li><li><p>但是通常不会修改类的属性，会直接使用默认的<code>router-link-active</code></p></li><li><p><code>&lt;router-link to=&#39;/home&#39; tag=&#39;button&#39; active-class=&#39;active&#39;&gt;</code>此时被选中的<code>&lt;router-link&gt;</code>就会有active的class。</p></li><li><p>如果每个<code>&lt;router-link&gt;</code>都要加上<code>active-class=&#39;active&#39;</code>，那就在路由里面统一更改。</p></li></ul><h3 id="通过代码修改路由跳转"><a href="#通过代码修改路由跳转" class="headerlink" title="通过代码修改路由跳转"></a>通过代码修改路由跳转</h3><p>修改app.vue，将<code>&lt;router-link&gt;</code>换成<code>button</code>等任何组件，添加上点击事件，并写好点击事件响应方法，此时使用<code>this.$router.push(&#39;/home&#39;)</code>，push方法 等价于pushState方法，replace 方法等价于replaceState方法。</p><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>一个页面的path路径可能是不确定的，例如可能有<code>/user/aaaa</code>或者<code>/user/bbbb</code>，除了<code>/user</code>之外，后面还跟上了用户ID<code>/user/123</code>等。这种path和component的匹配关系，叫动态路由。</p><h4 id="params-模式"><a href="#params-模式" class="headerlink" title="params 模式"></a>params 模式</h4><blockquote><p>配置路由参数index.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  path: <span class="hljs-string">&#x27;/user/:userId&#x27;</span>,<br>  name: <span class="hljs-string">&#x27;User&#x27;</span>,<br>  component: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/components/User&#x27;</span>) <span class="hljs-comment">//懒加载组件</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>新建一个User组件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class&#x3D;&quot;page-contianer&quot;&gt;<br>    &lt;h2&gt;这是用户界面&lt;&#x2F;h2&gt;<br>    &lt;p&gt;这里是用户页面的内容。&lt;&#x2F;p&gt;<br>    &lt;p&gt;用户ID是: &#123;&#123; userId &#125;&#125;&lt;&#x2F;p&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br>&lt;script type&#x3D;&quot;text&#x2F;ecmascript-6&quot;&gt;<br>export default &#123;<br>  name: &#39;User&#39;,<br>  computed:&#123;<br>    userId() &#123;<br>      return this.$route.params.userId<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;&#x2F;script&gt;<br>&lt;style scoped&gt;<br>&lt;&#x2F;style&gt;<br><br></code></pre></td></tr></table></figure><p>该组件定义一个计算属性，通过<code>this.$route.params.userId</code>获取处于激活状态的路由参数<code>userId</code>。</p><h4 id="query-模式"><a href="#query-模式" class="headerlink" title="query 模式"></a>query 模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class&#x3D;&quot;page-contianer&quot;&gt;<br>    &lt;h2&gt;这是档案界面&lt;&#x2F;h2&gt;<br>    &lt;p&gt;这里是档案页面的内容。&lt;&#x2F;p&gt;<br>    &lt;p&gt;档案的名字是: &#123;&#123; profileInfo.name &#125;&#125;&lt;&#x2F;p&gt;<br>    &lt;p&gt;档案的年龄是: &#123;&#123; profileInfo.age &#125;&#125;&lt;&#x2F;p&gt;<br>    &lt;p&gt;档案的身高是: &#123;&#123; profileInfo.height &#125;&#125;&lt;&#x2F;p&gt;<br>  &lt;&#x2F;div&gt;<br>&lt;&#x2F;template&gt;<br>&lt;script type&#x3D;&quot;text&#x2F;ecmascript-6&quot;&gt;<br>export default &#123;<br>  name: &#39;Profile&#39;,<br>  computed: &#123;<br>    profileInfo() &#123;<br>      return this.$route.query.profileInfo<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;&#x2F;script&gt;<br>&lt;style scoped&gt;&lt;&#x2F;style&gt;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  path: <span class="hljs-string">&#x27;/profile&#x27;</span>,<br>  name: <span class="hljs-string">&#x27;Profile&#x27;</span>,<br>  component: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/components/Profile&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;router-link :to&#x3D;&quot;&#123; path: &#39;&#x2F;profile&#39;, query: &#123; profileInfo &#125; &#125;&quot;&gt;档案&lt;&#x2F;router-link&gt;<br></code></pre></td></tr></table></figure><p>在app.vue中设置初始的对象<code>profileInfo</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">data ()&#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    userId: <span class="hljs-string">&#x27;zty&#x27;</span>,<br>    profileInfo: &#123;<br>      name: <span class="hljs-string">&quot;zty&quot;</span>,<br>      age: <span class="hljs-number">24</span>,<br>      height: <span class="hljs-number">177</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用代码编写传递数据，使用<code>button</code>代替<code>&lt;router-link&gt;</code>，并添加点击事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;button @click&#x3D;&quot;userClick&quot;&gt;用户&lt;&#x2F;button&gt;<br>&lt;button @click&#x3D;&quot;profileClick&quot;&gt;档案&lt;&#x2F;button&gt;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">userClick</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-built_in">this</span>.$router.push(<span class="hljs-string">&#x27;/user/&#x27;</span> + <span class="hljs-built_in">this</span>.userId)<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;userClick&quot;</span>)<br>&#125;,<br><span class="hljs-function"><span class="hljs-title">profileClick</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-keyword">let</span> profileInfo = <span class="hljs-built_in">this</span>.profileInfo<br>  <span class="hljs-built_in">this</span>.$router.push(&#123;<br>    path: <span class="hljs-string">&#x27;/profile&#x27;</span>,<br>    query: &#123;<br>      profileInfo<br>    &#125;<br>  &#125;)<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;profileClick&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>传递参数主要有两种类型：params和query</p><blockquote><p>params的类型也就是动态路由形式</p></blockquote><ul><li>配置路由的格式：<code>/user/:userId</code></li><li>传递的方式：在path后面跟上对应的userId</li><li>传递形成的路径：<code>/user/123</code>，<code>/user/xxx</code></li><li>通过<code>$route.params.userId</code>获取指定userId</li></ul><blockquote><p>query的类型</p></blockquote><ul><li>配置路由的格式：<code>/profile</code>，也就是普通的配置</li><li>传递的方式：对象中使用query的key作为传递的方式</li><li>传递形成的路径：<code>/profile?name=zty&amp;age=24&amp;height=177</code>（这个传递的是三个键值对），<code>/profile?profileInfo=%5Bobject%20Object%5D</code>（这个query传递的是一个对象的键值对，key为profileInfo，value是一个对象）</li></ul><h3 id="vue-router的导航守卫"><a href="#vue-router的导航守卫" class="headerlink" title="vue-router的导航守卫"></a>vue-router的导航守卫</h3><p>问题：我们经常需要在路由跳转后，例如从用户页面跳转到首页，页面内容虽然可以自己定义，但是只有一个html文件，也只有一个title标签，我们需要改变标题。</p><p>可以使用js去修改title，可以使用vue的生命周期函数在组件被创建的时候修改title标签内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-comment">//创建的时候修改title</span><br>    <span class="hljs-built_in">document</span>.title = <span class="hljs-string">&#x27;关于&#x27;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">//数据被挂载到dom上的时候修改title</span><br>&#125;<br><span class="hljs-function"><span class="hljs-title">update</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">//页面刷新的时候修改</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当然不能每个组件去写生命周期函数，如果我们能监听路由的变化(了解路由从哪来往哪里跳转)，那我们就能在跳转中修改title标签，这就是导航守卫能做的事情。</p><p>修改<code>router/index.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 前置钩子：从from跳转到to</span><br><span class="hljs-comment"> * from 来的路由</span><br><span class="hljs-comment"> * to 要去的路由</span><br><span class="hljs-comment"> */</span><br>router.beforeEach(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">document</span>.title = to.matched[<span class="hljs-number">0</span>].meta.title <span class="hljs-comment">//给目标路由的页面的title赋值</span><br>  next()<span class="hljs-comment">//必须调用，不调用不会跳转</span><br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>router.beforeEach()称为前置钩子(前置守卫)，顾名思义，跳转之前做一些处理。</p></blockquote><p>当然每个路由配置上也要加上meta属性，不然就取不到了，为什么要使用<code>matched[0]</code>，因为如果你是嵌套路由，有没有给子路由添加meta（元数据：描述数据的数据）属性，就会显示<code>undefined</code>，使用<code>matched[0]</code>表示取到匹配的第一个就会找到父路由的meta属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//配置路由和组件之间的对应关系</span><br>&#123;<br>  path: <span class="hljs-string">&#x27;/home&#x27;</span>,<span class="hljs-comment">//home  前端路由地址</span><br>  name: <span class="hljs-string">&#x27;Home&#x27;</span>,<br>  component: Home, <span class="hljs-comment">//组件名</span><br>  meta: &#123;<br>    title: <span class="hljs-string">&#x27;首页&#x27;</span><br>  &#125;,<br>  children: [<br>    &#123;<br>      path: <span class="hljs-string">&#x27;&#x27;</span>,<br>      redirect: <span class="hljs-string">&#x27;/home/news&#x27;</span><span class="hljs-comment">//缺省时候重定向到/home/news</span><br>    &#125;,<br>    &#123;<br>      path: <span class="hljs-string">&#x27;news&#x27;</span>,<span class="hljs-comment">//子嵌套路由 无须加/</span><br>      name: <span class="hljs-string">&#x27;News&#x27;</span>,<br>      component: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/components/HomeNews&#x27;</span>) <span class="hljs-comment">//懒加载组件</span><br>    &#125;,<br>    &#123;<br>      path: <span class="hljs-string">&#x27;message&#x27;</span>,<br>      name: <span class="hljs-string">&#x27;Message&#x27;</span>,<br>      component: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/components/HomeMessage&#x27;</span>) <span class="hljs-comment">//懒加载组件</span><br>    &#125;<br>  ]<br>&#125;,<br></code></pre></td></tr></table></figure><h3 id="导航守卫补充"><a href="#导航守卫补充" class="headerlink" title="导航守卫补充"></a>导航守卫补充</h3><p>前面说了前置守卫router.beforeEach()，相对的应该也存在后置守卫(后置钩子)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 后置钩子</span><br><span class="hljs-comment"> */</span><br>router.afterEach(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;后置钩子调用了----&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>顾名思义，也就是在跳转之后的回调函数。</p><ul><li>前置守卫和后置守卫都是<strong>全局守卫</strong>。</li><li>还有<a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E8%B7%AF%E7%94%B1%E7%8B%AC%E4%BA%AB%E7%9A%84%E5%AE%88%E5%8D%AB">路由独享守卫</a></li><li><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E7%BB%84%E4%BB%B6%E5%86%85%E7%9A%84%E5%AE%88%E5%8D%AB">组件内的守卫</a></li></ul><blockquote><p>路由独享守卫，路由私有的</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  path: <span class="hljs-string">&#x27;/about&#x27;</span>,<span class="hljs-comment">//about 前端路由地址</span><br>  name: <span class="hljs-string">&#x27;About&#x27;</span>,<br>  component: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/components/About&#x27;</span>),<br>  beforeEnter: <span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;来自&#x27;</span> + <span class="hljs-keyword">from</span>.path + <span class="hljs-string">&#x27;,要去&#x27;</span> + to.path)<br>    next()<br>  &#125;,<br>  meta: &#123;<br>    title: <span class="hljs-string">&#x27;关于&#x27;</span><br>  &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p><code>beforeEnter</code>的参数与全局守卫一样，修改<code>about</code>路由的参数，添加路由独享守卫，此时只有跳转到<code>about</code>路由，才会打印日志。</p><blockquote><p>组件内的守卫，直接在组件中定义的属性</p></blockquote><ul><li><code>beforeRouteEnter</code></li><li><code>beforeRouteUpdate</code> (2.2 新增)</li><li><code>beforeRouteLeave</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> Foo = &#123;<br>  template: <span class="hljs-string">`...`</span>,<br>  beforeRouteEnter (to, <span class="hljs-keyword">from</span>, next) &#123;<br>    <span class="hljs-comment">// 在渲染该组件的对应路由被 confirm 前调用</span><br>    <span class="hljs-comment">// 不！能！获取组件实例 `this`</span><br>    <span class="hljs-comment">// 因为当守卫执行前，组件实例还没被创建</span><br>  &#125;,<br>  beforeRouteUpdate (to, <span class="hljs-keyword">from</span>, next) &#123;<br>    <span class="hljs-comment">// 在当前路由改变，但是该组件被复用时调用</span><br>    <span class="hljs-comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span><br>    <span class="hljs-comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span><br>    <span class="hljs-comment">// 可以访问组件实例 `this`</span><br>  &#125;,<br>  beforeRouteLeave (to, <span class="hljs-keyword">from</span>, next) &#123;<br>    <span class="hljs-comment">// 导航离开该组件的对应路由时调用</span><br>    <span class="hljs-comment">// 可以访问组件实例 `this`</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>beforeRouteEnter</code> 守卫 <strong>不能</strong> 访问 <code>this</code>，因为守卫在导航确认前被调用,因此即将登场的新组件还没被创建。</p><p>不过，你可以通过传一个回调给 <code>next</code>来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">beforeRouteEnter (to, <span class="hljs-keyword">from</span>, next) &#123;<br>  next(<span class="hljs-function"><span class="hljs-params">vm</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 通过 `vm` 访问组件实例</span><br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>注意 <code>beforeRouteEnter</code> 是支持给 <code>next</code> 传递回调的唯一守卫。对于 <code>beforeRouteUpdate</code> 和 <code>beforeRouteLeave</code> 来说，<code>this</code> 已经可用了，所以<strong>不支持</strong>传递回调，因为没有必要了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">beforeRouteUpdate (to, <span class="hljs-keyword">from</span>, next) &#123;<br>  <span class="hljs-comment">// just use `this`</span><br>  <span class="hljs-built_in">this</span>.name = to.params.name<br>  next()<br>&#125;<br></code></pre></td></tr></table></figure><p>这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 <code>next(false)</code> 来取消。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">beforeRouteLeave (to, <span class="hljs-keyword">from</span> , next) &#123;<br>  <span class="hljs-keyword">const</span> answer = <span class="hljs-built_in">window</span>.confirm(<span class="hljs-string">&#x27;Do you really want to leave? you have unsaved changes!&#x27;</span>)<br>  <span class="hljs-keyword">if</span> (answer) &#123;<br>    next()<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    next(<span class="hljs-literal">false</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完整的导航解析流程"><a href="#完整的导航解析流程" class="headerlink" title="完整的导航解析流程"></a>完整的导航解析流程</h3><ol><li>导航被触发。</li><li>在失活的组件里调用离开守卫。</li><li>调用全局的 <code>beforeEach</code> 守卫。</li><li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫 (2.2+)。</li><li>在路由配置里调用 <code>beforeEnter</code>。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li><li>调用全局的 <code>beforeResolve</code> 守卫 (2.5+)。</li><li>导航被确认。</li><li>调用全局的 <code>afterEach</code> 钩子。</li><li>触发 DOM 更新。</li><li>用创建好的实例调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数。</li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端模块化</title>
    <link href="/2021/01/07/modules/"/>
    <url>/2021/01/07/modules/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是前端模块化"><a href="#什么是前端模块化" class="headerlink" title="什么是前端模块化"></a>什么是前端模块化</h3><p>模块化侧重的功能的封装，主要是针对Javascript代码，隔离、组织复制的javascript代码，将它封装成一个个具有特定功能的的模块。</p><p>模块可以通过传递参数的不同修改这个功能的的相关配置，每个模块都是一个单独的作用域，根据需要调用。</p><p>一个模块的实现可以依赖其它模块</p><h3 id="为什么要有模块化"><a href="#为什么要有模块化" class="headerlink" title="为什么要有模块化"></a>为什么要有模块化</h3><p>​随着前端项目越来越大，团队人数越来越多，多人协调开发一个项目成为常态。例如现在小明和小张共同开发一个项目，小明定义一个aaa.js，小王定义了一个bbb.js。</p><blockquote><p>aaa.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//小明开发</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;小明&#x27;</span><br><span class="hljs-keyword">var</span> age = <span class="hljs-number">22</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">num1, num2</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> num1 + num2<br>&#125;<br><span class="hljs-keyword">var</span> flag = <span class="hljs-literal">true</span><br><span class="hljs-keyword">if</span> (flag) &#123;<br>  <span class="hljs-built_in">console</span>.log(sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>此时小明的<code>sum</code>是没有问题的。</p><blockquote><p>bbb.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//小红</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;小王&quot;</span><br><span class="hljs-keyword">var</span> flag = <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>此时小明和小王各自用各自的<code>flag</code>你变量没问题。</p><blockquote><p>但是此时小明又创建了一个mmm.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//小明</span><br><span class="hljs-keyword">if</span>(flag)&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;flag是true&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>在index.html页面导入这些js文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">&lt;script src&#x3D;&quot;aaa.js&quot; &gt;&lt;&#x2F;script&gt;<br>&lt;script src&#x3D;&quot;bbb.js&quot; &gt;&lt;&#x2F;script&gt;<br>&lt;script src&#x3D;&quot;ccc.js&quot; &gt;&lt;&#x2F;script&gt;<br></code></pre></td></tr></table></figure><p>此时小明知道自己在aaa.js中定义的<code>flag</code>是<code>true</code>，认为打印没有问题，但是不知道小王的bbb.js中也定义了<code>flag</code>为<code>true</code>，所以mmm.js文件并没有打印出“flag是true”。</p><p><strong>这就是全局变量同名问题</strong></p><h3 id="常见的模块化规范"><a href="#常见的模块化规范" class="headerlink" title="常见的模块化规范"></a>常见的模块化规范</h3><p>CommonJS、AMD、CMD、 ES6的Moudels</p><h3 id="全局变量模块解决全局变量同名问题"><a href="#全局变量模块解决全局变量同名问题" class="headerlink" title="全局变量模块解决全局变量同名问题"></a>全局变量模块解决全局变量同名问题</h3><blockquote><p>aaa.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//模块对象</span><br><span class="hljs-keyword">var</span> moduleA = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">param</span>) </span>&#123;<br>  <span class="hljs-comment">//导出对象</span><br>  <span class="hljs-keyword">var</span> obj = &#123;&#125;<br>  <span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;小明&#x27;</span><br>  <span class="hljs-keyword">var</span> age = <span class="hljs-number">22</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">num1, num2</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> num1 + num2<br>  &#125;<br>  <span class="hljs-keyword">var</span> flag = <span class="hljs-literal">true</span><br>  <span class="hljs-keyword">if</span> (flag) &#123;<br>    <span class="hljs-built_in">console</span>.log(sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>))<br>  &#125;<br>  obj.flag=<span class="hljs-literal">false</span><br>  <span class="hljs-keyword">return</span> obj<br>&#125;)()<br></code></pre></td></tr></table></figure><blockquote><p>mmm.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//小明</span><br><span class="hljs-comment">//使用全局变量moduleA</span><br><span class="hljs-keyword">if</span>(moduleA.flag)&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;flag是true&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这样直接使用aaa.js导出的moduleA变量获取小明自己定义的<code>flag</code>。</p><h3 id="CommonJS的模块化实现"><a href="#CommonJS的模块化实现" class="headerlink" title="CommonJS的模块化实现"></a>CommonJS的模块化实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//CommonJS需要nodeJS支持</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;小明&#x27;</span><br><span class="hljs-keyword">var</span> age = <span class="hljs-number">22</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">num1, num2</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> num1 + num2<br>&#125;<br><span class="hljs-keyword">var</span> flag = <span class="hljs-literal">true</span><br><span class="hljs-keyword">if</span> (flag) &#123;<br>  <span class="hljs-built_in">console</span>.log(sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>))<br>&#125;<br><br><span class="hljs-comment">//导出对象</span><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  flag,<br>  sum<br>&#125;<br></code></pre></td></tr></table></figure><p>使用<code>module.exports = &#123;&#125;</code>导出需要的对象。</p><blockquote><p>mmm.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//导入对象,nodejs语法,需要node支持,从aaa.js取出对象</span><br><span class="hljs-keyword">var</span> &#123;flag,sum&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./aaa&quot;</span>)<br><br><span class="hljs-built_in">console</span>.log(sum(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>));<br><br><span class="hljs-keyword">if</span>(flag)&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;flag is true&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>var &#123;flag,sum&#125; = require(&quot;./aaa&quot;)</code>获取已经导出的对象中自己所需要的对象。</p><h3 id="ES6的模块化实现"><a href="#ES6的模块化实现" class="headerlink" title="ES6的模块化实现"></a>ES6的模块化实现</h3><p>​如何实现模块化，在html中需要使用<code>type=&#39;module&#39;</code>属性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;aaa.js&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;bbb.js&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;mmm.js&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>此时表示aaa.js是一个单独的模块，此模块是有作用域的。如果要使用aaa.js内的变量，需要在aaa.js中先导出变量，再在需要使用的地方导出变量。</p><h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;小明&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>使用</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;name&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./aaa.js&#x27;</span><br></code></pre></td></tr></table></figure><p><code>./aaa.js</code>表示aaa.js和mmm.js在同级目录。</p><p>如图打印结果。</p><h4 id="统一导出"><a href="#统一导出" class="headerlink" title="统一导出"></a>统一导出</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> age = <span class="hljs-number">22</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">num1, num2</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> num1 + num2<br>&#125;<br><span class="hljs-keyword">var</span> flag = <span class="hljs-literal">true</span><br><span class="hljs-keyword">if</span> (flag) &#123;<br>  <span class="hljs-built_in">console</span>.log(sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>))<br>&#125;<br><span class="hljs-comment">//2.最后统一导出</span><br><span class="hljs-keyword">export</span> &#123;<br>  flag,sum,age<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>使用<code>import &#123;name,flag,sum&#125; from &#39;./aaa.js&#39;</code>导入多个变量</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;name,flag,sum&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./aaa.js&#x27;</span><br><br><span class="hljs-built_in">console</span>.log(name)<br><br><span class="hljs-keyword">if</span>(flag)&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;小明是天才&quot;</span>);<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(sum(<span class="hljs-number">20</span>,<span class="hljs-number">30</span>));<br></code></pre></td></tr></table></figure><blockquote><p>使用{}将需要的变量放置进去</p></blockquote><h4 id="导出函数-类"><a href="#导出函数-类" class="headerlink" title="导出函数/类"></a>导出函数/类</h4><blockquote><p>在aaa.js中添加</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//3.导出函数/类</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">say</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(value);<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;奔跑&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在mmm.js中添加</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;name,flag,sum,say,Person&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./aaa.js&#x27;</span><br><br><span class="hljs-built_in">console</span>.log(name)<br><br><span class="hljs-keyword">if</span>(flag)&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;小明是天才&quot;</span>);<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(sum(<span class="hljs-number">20</span>,<span class="hljs-number">30</span>));<br><br>say(<span class="hljs-string">&#x27;hello&#x27;</span>)<br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> Person();<br>p.run();<br></code></pre></td></tr></table></figure><blockquote><p>如图</p></blockquote><p><img src="./images/14.4-3.png"></p><p>###默认导入 export default</p><blockquote><p>导出</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  flag,sum,age<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>导入</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//4.默认导入 export default</span><br><span class="hljs-keyword">import</span> aaa <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./aaa.js&#x27;</span><br><span class="hljs-built_in">console</span>.log(aaa.sum(<span class="hljs-number">10</span>,<span class="hljs-number">110</span>));<br></code></pre></td></tr></table></figure><blockquote><p>注意：使用默认导出会将所有需要导出的变量打包成一个对象，此时导出一个对象，此时我在<code>mmm.js</code>中导入变量时候命名为aaa，如果要调用变量需要使用aaa.变量。</p></blockquote><h3 id="统一全部导入"><a href="#统一全部导入" class="headerlink" title="统一全部导入"></a>统一全部导入</h3><blockquote><p>​    使用<code>import * as aaa from &#39;./aaa.js&#39;</code>统一全部导入</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 5.统一全部导入</span><br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> aaa <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./aaa.js&#x27;</span><br><span class="hljs-built_in">console</span>.log(aaa.flag);<br><span class="hljs-built_in">console</span>.log(aaa.name);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>H5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-队列</title>
    <link href="/2020/12/23/Queue/"/>
    <url>/2020/12/23/Queue/</url>
    
    <content type="html"><![CDATA[<h3 id="队列介绍"><a href="#队列介绍" class="headerlink" title="队列介绍"></a>队列介绍</h3><p>队列是一种特殊的线性表，先进先出（FIFO），特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列</p><h4 id="队列示意图"><a href="#队列示意图" class="headerlink" title="队列示意图"></a>队列示意图</h4><p><img src="/img/dataStructures/queue.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>datastructure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-栈</title>
    <link href="/2020/12/23/Stack/"/>
    <url>/2020/12/23/Stack/</url>
    
    <content type="html"><![CDATA[<h3 id="栈的介绍"><a href="#栈的介绍" class="headerlink" title="栈的介绍"></a>栈的介绍</h3><p>它是一种运算受限的线性表后进先出（LFIO）。限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素</p><h4 id="栈的示意图"><a href="#栈的示意图" class="headerlink" title="栈的示意图"></a>栈的示意图</h4><p><img src="/img/dataStructures/stack.png"></p><h4 id="栈题目"><a href="#栈题目" class="headerlink" title="栈题目"></a>栈题目</h4><p><strong>根据六个元素6,5,4,3,2,1的顺序进栈哪一个不是合法出栈的序列</strong></p><p>A 5,4,3,6,1,2   </p><p>B 4,5,3,2,1,6  </p><p>C 3,4,6,5,2,1  </p><p>D 2,3,4,1,5,6</p><p>答案是 c</p><ul><li><p>A 65入5出，4入4出 3入3出 6出 21入 1出 2出</p></li><li><p>B 65入4出5出 3入3出 2入2出 1入1出 6出</p></li><li><p>C 6543入 3 出 4出 应该是5出 所以不符合</p></li><li><p>D 65432入 2出 3出 4出 1入1出 5出 6出</p></li></ul><p><strong>十进制 转化成二进制</strong></p><p>js 根据数组封装一个栈</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.items = []<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">push</span>(<span class="hljs-params">element</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.items.push(element)<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-title">pop</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items.pop()<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">peek</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items[<span class="hljs-built_in">this</span>.items.length-<span class="hljs-number">1</span>]<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">isEmpty</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items.length === <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">size</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items.length<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体方法实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dec2bin</span>(<span class="hljs-params">num</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> stack = <span class="hljs-keyword">new</span> Stack()<br>    <span class="hljs-comment">// 循环取余数</span><br>    <span class="hljs-keyword">while</span>(num &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">let</span> remainder = num % <span class="hljs-number">2</span><br>        num = <span class="hljs-built_in">Math</span>.floor(num / <span class="hljs-number">2</span>)<br>        stack.push(remainder)<br>    &#125;<br>    <span class="hljs-comment">// 拼接字符串</span><br>    <span class="hljs-keyword">let</span> binString = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">while</span>(!stack.isEmpty()) &#123;<br>        binString += stack.pop()<br>    &#125;<br>    <span class="hljs-keyword">return</span> binString<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>datastructure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Runloop</title>
    <link href="/2020/12/17/iOS-Runloop/"/>
    <url>/2020/12/17/iOS-Runloop/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是Runloop"><a href="#什么是Runloop" class="headerlink" title="什么是Runloop"></a>什么是Runloop</h3><p>从语义角度 runloop 是通过内部事件循环来处理事件/消息的一个对象</p><ul><li><p>没有消息需要处理时，休眠避免占用资源 （用户态 到 核心态）</p></li><li><p>有消息处理时，立刻被唤醒 （核心态到用户态）</p></li></ul><h4 id="为什么main-函数为什么能够保持一直-运行的状态而不退出？"><a href="#为什么main-函数为什么能够保持一直-运行的状态而不退出？" class="headerlink" title="为什么main 函数为什么能够保持一直 运行的状态而不退出？"></a>为什么main 函数为什么能够保持一直 运行的状态而不退出？</h4><p>在main函数中会启动主线程的runloop,而runloop又是对事件循环的一种维护机制，在有事做的可以去做事，没有事做的时候，从用户态到内核态进行切换，避免资源占用</p><p><img src="/img/ios/runloop/main.png"></p><h3 id="runloop-数据结构"><a href="#runloop-数据结构" class="headerlink" title="runloop 数据结构"></a>runloop 数据结构</h3><p>NSRunloop 是CFRunloop的封装，提供了面向对象的api</p><ul><li><p>CFRunloop</p></li><li><p>CFRunloopMode</p></li><li><p>source/Timer/observer</p></li></ul><h3 id="CFRunloop-结构"><a href="#CFRunloop-结构" class="headerlink" title="CFRunloop 结构"></a>CFRunloop 结构</h3><p><img src="/img/ios/runloop/cfrunloop.png"></p><p>从 pthread 可以看出是和线程一一对应</p><h4 id="CFRunloopMode-分为哪些"><a href="#CFRunloopMode-分为哪些" class="headerlink" title="CFRunloopMode 分为哪些"></a>CFRunloopMode 分为哪些</h4><ul><li><p> UITrackingRunLoopMode (UI模式,只能被UI事件触发 优先级非常高)</p></li><li><p>NSDefaultRunLoopMode (默认模式,处理时钟网络事件)</p></li><li><p>NSRunLoopCommonModes (占位模式,以上两种模式都添加)</p></li><li><p>UIInitializationRunLoopMode  App启动时第一个模式, runloop会处理启动事件,这个模式只运行一次(苹果不开放)</p></li><li><p> GSEventReceiveRunLoopMode系统事件的内部模式(苹果不开放)</p></li></ul><h4 id="CFRunloopSource-分为哪些"><a href="#CFRunloopSource-分为哪些" class="headerlink" title="CFRunloopSource 分为哪些"></a>CFRunloopSource 分为哪些</h4><ul><li><p>source0 需要手动唤醒线程</p></li><li><p>source1 具备唤醒线程的能力</p></li></ul><h4 id="CFRunloopObserver-观测事件点"><a href="#CFRunloopObserver-观测事件点" class="headerlink" title="CFRunloopObserver 观测事件点"></a>CFRunloopObserver 观测事件点</h4><ul><li><p>KCFRunLoopEntry  runloop 进入循环</p></li><li><p>KCFRunLoopBeforeTimers  runloop 处理Timers事件前</p></li><li><p>KCFRunLoopBeforeSources  runloop 处理 source 事件前</p></li><li><p>KCFRunLoopBeforeWaiting  runloop 休眠前</p></li><li><p>KCFRunLoopAfterWaiting  runloop 休眠后</p></li><li><p>KCFRunLoopExit runloop 退出</p></li></ul><h4 id="各个数据结构之间的关系"><a href="#各个数据结构之间的关系" class="headerlink" title="各个数据结构之间的关系"></a>各个数据结构之间的关系</h4><p>runloop 对应mode 一对多 mode 对应 source、timer、observer 一对多</p><h4 id="commmode的特殊性"><a href="#commmode的特殊性" class="headerlink" title="commmode的特殊性"></a>commmode的特殊性</h4><ul><li><p>commmode不是实际存在的一种mode</p></li><li><p>是同步 source/Timer/observe 到多个mode 中的一种技术方案</p></li></ul><h3 id="Runloop-机制"><a href="#Runloop-机制" class="headerlink" title="Runloop 机制"></a>Runloop 机制</h3><p><img src="/img/ios/runloop/runloopjizhi.png"></p><h3 id="怎样实现一个常驻线程"><a href="#怎样实现一个常驻线程" class="headerlink" title="怎样实现一个常驻线程"></a>怎样实现一个常驻线程</h3><ul><li><p>在当前线程中开启一个runloop </p></li><li><p>向该runloop中添加一个Port/Source 等维持Runloop 的事件循环</p></li><li><p>启动该runloop</p></li></ul><h3 id="怎样保证子线程数据回来更新UI的时候不打断用户滑动操作-？"><a href="#怎样保证子线程数据回来更新UI的时候不打断用户滑动操作-？" class="headerlink" title="怎样保证子线程数据回来更新UI的时候不打断用户滑动操作?？"></a>怎样保证子线程数据回来更新UI的时候不打断用户滑动操作?？</h3><ul><li><p>用户滑动当前runloop 运行在UItrackingrunloopmode下</p></li><li><p> 我们一般在子线程中进行网络请求，所以可以在子线程给主线程数据进行UI更新的逻辑封装起来提交到主线       线程NSDefaultRunloopmode下 具体方法 [self performSelectorOnmainThred@selector(reloadData)       withobjc:nil waitUniteDone:No modes:NSDefaultRunloopmode]</p></li><li><p>这样抛回来的任务，当用户滑动处于UITrackingRunLoopMode 下就不会执行，当滑动停止，当前mode切换NSDefaultRunloopmode再处理子线线程抛上来的任务</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程</title>
    <link href="/2020/12/16/iOS-Multithreading/"/>
    <url>/2020/12/16/iOS-Multithreading/</url>
    
    <content type="html"><![CDATA[<h3 id="iOS系统为我们提供那些多线程技术"><a href="#iOS系统为我们提供那些多线程技术" class="headerlink" title="iOS系统为我们提供那些多线程技术"></a>iOS系统为我们提供那些多线程技术</h3><p>主要是这三种</p><ul><li><p>GCD</p></li><li><p>NSOperation</p></li><li><p>NSTread</p></li></ul><h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><h4 id="分为-同步-异步和-串行-并发"><a href="#分为-同步-异步和-串行-并发" class="headerlink" title="分为 同步/异步和 串行/并发"></a>分为 同步/异步和 串行/并发</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">dispatch_sync</span><span class="hljs-params">(serial_queue,^(任务)</span></span>)<br><span class="hljs-function"><span class="hljs-title">dispatch_async</span><span class="hljs-params">(serial_queue,^(任务)</span></span>)<br><span class="hljs-function"><span class="hljs-title">dispatch_sync</span><span class="hljs-params">(concurrent_queue,^(任务)</span></span>)<br><span class="hljs-function"><span class="hljs-title">dispatch_async</span><span class="hljs-params">(concurrent_queue,^(任务)</span></span>)<br><br></code></pre></td></tr></table></figure><p>同步并发队列</p><p>下面代码输出啥</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- （viewDidLoad）&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1&quot;</span>);<br>    <span class="hljs-built_in">dispatch_sync</span>(global_queue,^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;2&quot;</span>);<br><br>        <span class="hljs-built_in">dispatch_sync</span>(global_queue,^&#123;<br><br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;3&quot;</span>);<br>         &#125;)；<br><br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;4&quot;</span>);<br>    &#125;)；<br>     <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;5&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>同步阻塞当前线程 所以打印1之后执行 block 打印2 由于是并发队列操作 所以执行打印3，如果是串行造成死锁</p><p> 异步并发队列<br>下面代码输出啥</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">- （viewDidLoad）&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1&quot;</span>);<br>    <span class="hljs-built_in">dispatch_async</span>(global_queue,^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;2&quot;</span>);<br>        [<span class="hljs-keyword">self</span> performSelector：<span class="hljs-keyword">@selector</span>(printlog) withObject:<span class="hljs-literal">nil</span> afterDelay:<span class="hljs-number">0</span>]<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;3&quot;</span>);<br>    &#125;)；<br>&#125;<br>- (<span class="hljs-keyword">void</span>)printlog&#123;<span class="hljs-built_in">NSlog</span>(<span class="hljs-string">@&quot;2&quot;</span>)&#125;<br><br></code></pre></td></tr></table></figure><p>输出13，block内线程没有 runloop,所以 performSelector不会执行</p><h4 id="怎样用GCd实现多读单写呢"><a href="#怎样用GCd实现多读单写呢" class="headerlink" title="怎样用GCd实现多读单写呢"></a>怎样用GCd实现多读单写呢</h4><p>dipatch_barrier_async()</p><p><img src="/img/ios/multith/barrier.png"></p><h3 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h3><p>NSOperation 需要和 NSOperationqueue配合来实现多线程方案</p><p>特点</p><ul><li><p>添加任务依赖</p></li><li><p>任务执行状态控制</p></li><li><p>最大并发量</p></li></ul><h4 id="任务执行状态"><a href="#任务执行状态" class="headerlink" title="任务执行状态"></a>任务执行状态</h4><ul><li><p>isReady</p></li><li><p>isExecuting</p></li><li><p>isFinished</p></li><li><p>isCancelled</p></li></ul><p>状态控制</p><ul><li><p>如果只是重写了main方法，底层控制变更执行完成状态，以及任务退出</p></li><li><p>如果重写start方法，自行控制任务状态</p></li></ul><p>系统是怎样移除一个isfinished=Yes的NSOperation？</p><p>通过kvo</p><h3 id="NSTread"><a href="#NSTread" class="headerlink" title="NSTread"></a>NSTread</h3><p>启动流程</p><p><img src="/img/ios/multith/barrier.png"></p><p>一般我们用NSTread和runloop 结合来是一个常驻线程</p><h3 id="dispatch-semaphore-t"><a href="#dispatch-semaphore-t" class="headerlink" title="dispatch_semaphore_t"></a>dispatch_semaphore_t</h3><p>信号量：就是一种可用来控制访问资源的数量的标识，设定了一个信号量，在线程访问之前，加上信号量的处理，则可告知系统按照我们指定的信号量数量来执行多个线程。<br>异步线程下同步问题</p><p>//创建信号量，参数：信号量的初值，如果小于0则会返回NULL<br>dispatch_semaphore_create（信号量值）</p><p>//等待降低信号量<br>dispatch_semaphore_wait（信号量，等待时间）</p><p>//提高信号量<br>dispatch_semaphore_signal(信号量)</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>一般我们用CGD来实现实现一些 简单线程同步 子线程放的分派，包括多读单写这些场景的一些问题的解决，</p></li><li><p>对于NSOpeation 由于它 任务依赖，任务状态控制，可以设置最大并发量的一些的特点，像afn sdwebimg 这些框架都会使用它</p></li><li><p>对于NSTread往往我们用它来实现一个常驻线程</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2020/12/16/Git/"/>
    <url>/2020/12/16/Git/</url>
    
    <content type="html"><![CDATA[<h3 id="Git介绍"><a href="#Git介绍" class="headerlink" title="Git介绍"></a>Git介绍</h3><p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。<br>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。<br>Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持</p><h3 id="git安装（mac）"><a href="#git安装（mac）" class="headerlink" title="git安装（mac）"></a>git安装（mac）</h3><p>Mac的终端上输入git检测是否安装git</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>t-scm.com/downloads<br><br></code></pre></td></tr></table></figure><p>安装完成之后查看git版本</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">git <span class="hljs-comment">--version</span><br><br></code></pre></td></tr></table></figure><p>创建一个全局用户名、全局邮箱作为配置信息</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog">git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> user<span class="hljs-variable">.name</span> <span class="hljs-string">&quot;your_name&quot;</span>  <br>git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> user<span class="hljs-variable">.email</span> <span class="hljs-string">&quot;your_email@youremail.com&quot;</span><br><br></code></pre></td></tr></table></figure><h3 id="git-本地仓库创建"><a href="#git-本地仓库创建" class="headerlink" title="git 本地仓库创建"></a>git 本地仓库创建</h3><p>打开终端</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-meta"><span class="hljs-meta-keyword">$cd</span> 某一个文件夹下</span><br><span class="hljs-symbol">$</span> git init<br><span class="hljs-symbol">$</span> git add .<br><span class="hljs-symbol">$</span> git commit -m <span class="hljs-string">&#x27;初始化项目版本&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="如果远端已有仓库"><a href="#如果远端已有仓库" class="headerlink" title="如果远端已有仓库"></a>如果远端已有仓库</h4><p>使用命令<br>$git remote add origin 添加远端仓库<br>$git push -u origin master 推送到远端仓库</p><h3 id="工作区域"><a href="#工作区域" class="headerlink" title="工作区域"></a>工作区域</h3><p>git本地有三个工作区域：工作目录 (working) 、暂存区(stage)、本地仓（local rep,如果添加远端git仓（Rmmote）</p><p><img src="/img/ittree/gitimg/gitwork.png"></p><h4 id="git-常用六个命令"><a href="#git-常用六个命令" class="headerlink" title="git 常用六个命令"></a>git 常用六个命令</h4><ul><li><p>git add file: 本地文件添加到暂存区</p></li><li><p>git commit: 提交到本地仓库</p></li><li><p>git push: 推送到远端仓库</p></li><li><p>git pull: 拉取远端分支内容</p></li><li><p>git reset: 撤销提交内容</p></li><li><p>git checkout: 撤销缓存内容</p></li></ul><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>切出分支命令</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> checkout -<span class="hljs-keyword">b</span> dev<br><br></code></pre></td></tr></table></figure><p>创建项目时，会针对不同环境创建三个常设分支</p><ul><li><p>master: 主分支发布版本不轻易修改</p></li><li><p>dev: 功能开发分支</p></li><li><p>test: 测试分支，提交给测试部门</p></li></ul><p><img src="/img/ittree/gitimg/gitliucheng.png"></p><h3 id="git-撤销回滚"><a href="#git-撤销回滚" class="headerlink" title="git 撤销回滚"></a>git 撤销回滚</h3><h4 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h4><p><strong>文件被修改了，但未执行git add操作</strong></p><ul><li><p> git checkout – fliename  某个文件名</p></li><li><p>  git checkout – .   将多个文件一次性撤销可以用</p></li></ul><p><strong>已经添加到暂存区域，从暂存区撤销</strong></p><ul><li><p>git reset HEAD filename 撤销某个</p></li><li><p>git reset HEAD 多个撤销</p></li></ul><p><strong>commit之后，想要撤销到某个版本</strong></p><ol><li><p>git log查看提交记录</p></li><li><p>git  reset –hard  commit_id</p></li></ol><h4 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h4><p><strong>回滚一次错误的合并</strong></p><ol><li><p>git branch backup 备份一个</p></li><li><p>git push origin backup: backup 推送到远端</p></li><li><p>git reset –hard xxxxx 本地仓库彻底回退到xxxxx版本，xxxxx版本之后的commit信息将丢失</p></li><li><p>git push origin :master 删除对应远端分支</p></li><li><p>git push origin master 重新创建远端分支</p></li></ol><p>git revert<br><strong>是回滚某个 commit ，不是回滚“到”某个</strong></p><p>如果错误的修改已经不是最新的commit，回退某次提交的上一步，用git revert。并且会生成一个新的提交来撤销某次提交，此次提交之前的commit都会被保留。</p><p>比如：a操作添加了“haha”，commit了a，b操作添加了“xixi”，commit b。现在想回滚到只添加了“haha”，需要的是删除“xixi”，也就是逆向操作b，所以应该<code>git revert b的commit_id</code>。 <code>git revert</code> 应该翻译成“反转、逆转”比较好理解，而不是回退</p><p>git reset<br>删除commit 之前提交的内容 </p>]]></content>
    
    
    <categories>
      
      <category>ItTree</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络相关</title>
    <link href="/2020/12/15/network/"/>
    <url>/2020/12/15/network/</url>
    
    <content type="html"><![CDATA[<h3 id="概括-http协议-、https网络安全、tcp-upd、DNS解析、Session-Cookie"><a href="#概括-http协议-、https网络安全、tcp-upd、DNS解析、Session-Cookie" class="headerlink" title="概括: http协议 、https网络安全、tcp/upd、DNS解析、Session/Cookie"></a>概括: http协议 、https网络安全、tcp/upd、DNS解析、Session/Cookie</h3><h3 id="网络七层协议"><a href="#网络七层协议" class="headerlink" title="网络七层协议"></a>网络七层协议</h3><p><img src="/img/ittree/network/networkqc.png"></p><h3 id="http协议介绍"><a href="#http协议介绍" class="headerlink" title="http协议介绍"></a>http协议介绍</h3><p>HTTP协议（HyperText Transfer Protocol，超文本传输协议）是因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。<br>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等</p><h4 id="http请求报文"><a href="#http请求报文" class="headerlink" title="http请求报文"></a>http请求报文</h4><p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式</p><p><img src="/img/ittree/network/httprequset.png"></p><h4 id="http-响应报文"><a href="#http-响应报文" class="headerlink" title="http 响应报文"></a>http 响应报文</h4><p>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文</p><p><img src="/img/ittree/network/httprsp.jpg"></p><h4 id="http-请求方法"><a href="#http-请求方法" class="headerlink" title="http 请求方法"></a>http 请求方法</h4><p>get、post、head、options、put、delete 等</p><h4 id="GET-和POST方式的区别"><a href="#GET-和POST方式的区别" class="headerlink" title="GET 和POST方式的区别"></a>GET 和POST方式的区别</h4><ul><li><p>get请求参数以？分割拼接到URL后面，POST请求参数在body里面</p></li><li><p>get参数长度限制2048个字符，post一般没有改限制</p></li><li><p>get请求不安全， post请求比较安全</p></li></ul><p>从语义角度来回答</p><p>get  是获取资源 安全的 幂等的 可缓存的</p><p>post 是处理资源 非安全 非幂等的 不可缓存</p><p>安全性: 不应该引起server端的任何状态变化</p><p>幂等性: 同一个请求方法执行多次和执行一次的效果完全相同</p><h3 id="tcp连接-三次握手-四次挥手"><a href="#tcp连接-三次握手-四次挥手" class="headerlink" title="tcp连接 三次握手 四次挥手"></a>tcp连接 三次握手 四次挥手</h3><p>如图</p><p><img src="/img/ittree/network/tcplink.png"></p><h4 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h4><p>为了防止服务器端开启一些无用的连接增加服务器开销以及防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p><p>由于网络传输是有延时的(要通过网络光纤和各种中间代理服务器)，在传输的过程中，比如客户端发起了SYN=1创建连接的请求(第一次握手)。</p><p>如果服务器端就直接创建了这个连接并返回包含SYN、ACK和Seq等内容的数据包给客户端，这个数据包因为网络传输的原因丢失了，丢失之后客户端就一直没有接收到服务器返回的数据包。</p><p>客户端可能设置了一个超时时间，时间到了就关闭了连接创建的请求。再重新发出创建连接的请求，而服务器端是不知道的，如果没有第三次握手告诉服务器端客户端收的到服务器端传输的数据的话，</p><p>服务器端是不知道客户端有没有接收到服务器端返回的信息的</p><h4 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h4><p>TCP释放连接时之所以需要“四次挥手”,是因为FIN释放连接报文与ACK确认接收报文是分别由第二次和第三次”握手”传输的。为何建立连接时一起传输，释放连接时却要分开传输？</p><p>建立连接时，被动方服务器端结束CLOSED阶段进入“握手”阶段并不需要任何准备，可以直接返回SYN和ACK报文，开始建立连接。<br>释放连接时，被动方服务器，突然收到主动方客户端释放连接的请求时并不能立即释放连接，因为还有必要的数据需要处理，所以服务器先返回ACK确认收到报文，经过CLOSE-WAIT阶段准备好释放连接之后，才能返回FIN释放连接报文</p><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><h4 id="https-介绍"><a href="#https-介绍" class="headerlink" title="https 介绍"></a>https 介绍</h4><p>基于HTTP协议，通过SSL或TLS提供加密处理数据、验证对方身份以及数据完整性保护</p><h4 id="https-连接过程"><a href="#https-连接过程" class="headerlink" title="https 连接过程"></a>https 连接过程</h4><p><img src="/img/ittree/network/ssl.png"></p><p>客户端会发送给服务端一个加密算法的列表，tsl版本号 随机数c ,然后服务端再回给客户端<br>一个ssl证书和商定的加密算法，首先通过非对称加密进行对称加密密钥的传输，之后https之间的<br>网络请求就通过被非对称加密所保护的对称密钥进后续网络访问</p><h4 id="https都使用了什么加密手段"><a href="#https都使用了什么加密手段" class="headerlink" title="https都使用了什么加密手段"></a>https都使用了什么加密手段</h4><ul><li><p>建立连接过程使用非对称加密，非对称加密很耗时</p></li><li><p>后续通信过程使用对称加密</p></li></ul><h3 id="tcp-upd"><a href="#tcp-upd" class="headerlink" title="tcp upd"></a>tcp upd</h3><p>TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP</p><ul><li><p>TCP面向连接; UDP是无连接 的，即发送数据之前不需要建立连接</p></li><li><p>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付</p></li><li><p>tcp 连接是 1对1,UDP支持一对一，一对多，多对一和多对多的交互通信</p></li></ul><h4 id="tcp-特点"><a href="#tcp-特点" class="headerlink" title="tcp 特点"></a>tcp 特点</h4><p>面向连接 可靠传输 面向字节流 流量控制 拥塞控制</p><p>可靠传输 停止等待协议</p><p> 无差错情况 超时重传 确认丢失 确认迟到</p><p>面向字节流</p><p><img src="/img/ittree/network/bit.png"></p><p>流量控制 滑动窗口协议</p><p><img src="/img/ittree/network/chuankou.png"></p><p>拥塞控制</p><p>慢开始、拥塞避免<br>快恢复、快重传</p><p><img src="/img/ittree/network/yongse.png"></p><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>域名到IP地址的映射，DNS解析请求采用UDP数据包且明文</p><p><img src="/img/ittree/network/dns.png"></p><h4 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h4><h4 id="DNS劫持与HTTP的关系是怎样的？"><a href="#DNS劫持与HTTP的关系是怎样的？" class="headerlink" title="DNS劫持与HTTP的关系是怎样的？"></a>DNS劫持与HTTP的关系是怎样的？</h4><p> 没有关系，DNS解析发生在http建立连接之前，DNS解析请求使用UDP数据包，端口是 53</p><h4 id="怎样解决DNS-劫持"><a href="#怎样解决DNS-劫持" class="headerlink" title="怎样解决DNS 劫持"></a>怎样解决DNS 劫持</h4><ul><li>httpNDS </li><li>长连接</li></ul><p>httpDNS: 使用http协议向DNS服务器的80端口进行请求</p><p>长连接：通过长连接通道向 apiserver请求</p><h3 id="session-cookie"><a href="#session-cookie" class="headerlink" title="session/cookie"></a>session/cookie</h3><p>http协议是无状态的，使用 session 和 cookie 作为补偿</p><h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><p>cookie 主要用来记录用户状态，区分用户，状态保存在客户端</p><p>怎样修改cookie?</p><ul><li><p>新cooki覆盖旧cookie</p></li><li><p>覆盖规则: name、path、domain等需要与原cookie一致</p></li></ul><p>怎样删除cookie?</p><p>设置 cookie的expires= 过去的一个时间点，或者maxage= 0</p><h4 id="session"><a href="#session" class="headerlink" title="session"></a>session</h4><p>sessoin 和 cookie的关系是怎样的？</p><ul><li>session需要依赖于cooKie机制</li></ul><p><img src="/img/ittree/network/session.png"></p>]]></content>
    
    
    <categories>
      
      <category>ItTree</category>
      
    </categories>
    
    
    <tags>
      
      <tag>basic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS_Autoreleasepool</title>
    <link href="/2020/12/14/iOS-Autoreleasepool/"/>
    <url>/2020/12/14/iOS-Autoreleasepool/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是自动释放池"><a href="#什么是自动释放池" class="headerlink" title="什么是自动释放池"></a>什么是自动释放池</h3><ul><li><p>是以栈为结点通过双向链表形式组合而成</p></li><li><p>是和线程一一对应</p></li></ul><p>ARC下，我们使用@autoreleasepool{}来使用一个AutoreleasePool，随后编译器将其改写成下面的样子:</p><p><img src="/img/ios/autoreleasePool/autoreleasby.png"></p><p><strong>push转化</strong><br><img src="/img/ios/autoreleasePool/push.png"></p><p><strong>pop转化</strong><br><img src="/img/ios/autoreleasePool/pop.png"></p><p>一次pop实际上是相当于一次批量的pop操作</p><h4 id="AutoreleasePoolPage"><a href="#AutoreleasePoolPage" class="headerlink" title="AutoreleasePoolPage"></a>AutoreleasePoolPage</h4><p>而这两个函数都是对AutoreleasePoolPage的简单封装，所以自动释放机制的核心就在于这个类</p><h5 id="AutoreleasePoolPage数据结构"><a href="#AutoreleasePoolPage数据结构" class="headerlink" title="AutoreleasePoolPage数据结构"></a>AutoreleasePoolPage数据结构</h5><p><img src="/img/ios/autoreleasePool/page.png"></p><ul><li><p>AutoreleasePool并没有单独的结构，惹事由若干个AutoreleasePoolPage以双向链表的形式组合而成</p></li><li><p>AutoreleasePool是按线程一一对应的（结构中的thread指针指向当前线程）</p></li><li><p>AutoreleasePoolPage每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存autorelease对象的地址</p></li><li><p>一个AutoreleasePoolPage的空间被占满时，会新建一个AutoreleasePoolPage对象，连接链表，后来的autorelease对象在新的page加入</p></li><li><p>上面的id *next指针作为游标指向栈顶最新add进来的autorelease对象的下一个位置</p></li></ul><h5 id="AutoreleasePoolPage-push"><a href="#AutoreleasePoolPage-push" class="headerlink" title="AutoreleasePoolPage::push"></a>AutoreleasePoolPage::push</h5><p><img src="/img/ios/autoreleasePool/pagepush.png"></p><p>每当进行一次objc_autoreleasePoolPush调用时，runtime向当前的AutoreleasePoolPage中add进一个哨兵对象，值为0（也就是个nil）</p><h5 id="objc-autorelease-流程"><a href="#objc-autorelease-流程" class="headerlink" title="[objc autorelease] 流程"></a>[objc autorelease] 流程</h5><p><img src="/img/ios/autoreleasePool/liuchen.png"></p><h5 id="AutoreleasePoolPage-pop"><a href="#AutoreleasePoolPage-pop" class="headerlink" title="AutoreleasePoolPage::pop"></a>AutoreleasePoolPage::pop</h5><ul><li><p>根据传入的哨兵对象地址找到哨兵对象所处的page</p></li><li><p>在当前page中，将晚于哨兵对象插入的所有autorelease对象都发送一次- release消息，并向回移动next指针到正确位置</p></li></ul><p><img src="/img/ios/autoreleasePool/pagepop1.png"></p><p><img src="/img/ios/autoreleasePool/pagepop2.png"></p><h4 id="多层嵌套的AutoreleasePool、"><a href="#多层嵌套的AutoreleasePool、" class="headerlink" title="多层嵌套的AutoreleasePool、"></a>多层嵌套的AutoreleasePool、</h4><p>知道了上面的原理，嵌套的AutoreleasePool就非常简单了，pop的时候总会释放到上次push的位置为止，多层的pool就是多个哨兵对象而已，就像剥洋葱一样，每次一层，互不影响</p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS 内存管理</title>
    <link href="/2020/12/14/iOS-Memory/"/>
    <url>/2020/12/14/iOS-Memory/</url>
    
    <content type="html"><![CDATA[<h3 id="汇总：内存分布、内存管理方法、数据结构、ARC-amp-MRC-、weak"><a href="#汇总：内存分布、内存管理方法、数据结构、ARC-amp-MRC-、weak" class="headerlink" title="汇总：内存分布、内存管理方法、数据结构、ARC&amp;MRC 、weak"></a>汇总：内存分布、内存管理方法、数据结构、ARC&amp;MRC 、weak</h3><h4 id="内存分布"><a href="#内存分布" class="headerlink" title="内存分布"></a>内存分布</h4><p>Objective-C是基于C的，不放看下C程序进程的内存分布</p><p><img src="/img/ios/arm/buju.png"></p><p>可以分为部分</p><ul><li><p>.text: 代码区存放函数，程序结束后由系统释放</p></li><li><p>.data: 已经初始化的全局变量和静态变量的一块内存区域。数据段属于静态内存分配,可以分为只读数据段和读写数据段。字符串常量等,是放在只读数据段中，结束程序时才会被收回。</p></li></ul><ul><li><p>.bss: 存放程序中未初始化的全局变量和静态变量的一块内存区域</p></li><li><p>heap:堆区存放进程运行中被动态分配的内存段,它的大小并不固定,可动态扩张或缩减。</p></li></ul><ul><li>stack: 由编译器自动分配并释放，存放函数的参数值，局部变量等</li></ul><h4 id="内存管理方案"><a href="#内存管理方案" class="headerlink" title="内存管理方案"></a>内存管理方案</h4><ul><li><p>TaggedPointer （小对象管理 短string 、NSNumber、NSdata等）</p></li><li><p>NONPOINTER_ISA （iOS arm64位架构下 非指针型isa）</p></li><li><p>散列表 （引用计数表、弱引用表）</p></li></ul><h5 id="散列表方式"><a href="#散列表方式" class="headerlink" title="散列表方式"></a>散列表方式</h5><h5 id="散列表结构"><a href="#散列表结构" class="headerlink" title="散列表结构"></a>散列表结构</h5><p><img src="/img/ios/arm/sideTables.png"></p><h5 id="SideTable结构"><a href="#SideTable结构" class="headerlink" title="SideTable结构"></a>SideTable结构</h5><p><img src="/img/ios/arm/sidetable.png"></p><p><strong>思考：为什么不用一张表管理？</strong></p><p>假如说只有一张sideTable,我们在内存中所有分配的对象，它们引用计数或者弱引用存储都在这张大表当中，我们要操作它们引用计数值，有可能它们是在不同的线程中进行操作吗，由于数据安全访问问题，所以我们要进行加锁，那么这样就会存在一个效率问题。</p><p><img src="/img/ios/arm/sidetablesuo.png"></p><h5 id="散列表数据结构"><a href="#散列表数据结构" class="headerlink" title="散列表数据结构"></a>散列表数据结构</h5><ul><li><p>Spinlock_t</p></li><li><p>RefcountMap </p></li><li><p>weak_table_t</p></li></ul><p>spinLock_t 特点</p><ul><li><p>是 “忙等”的锁</p></li><li><p>适用于轻量访问</p></li></ul><p>如果当前锁已被其他线程所获取，当前线程会不断的探测这锁有没有被释放，如果释放，自己第一时间去获取，所以说自旋锁是一种忙等的锁</p><p>再比如其他锁，如信号量，如果当前线程获取不到这个锁，它会把当前线程进行阻塞休眠，等到其他线程<br>释放这个锁的时候，再唤醒这个线程</p><h5 id="引用用计数"><a href="#引用用计数" class="headerlink" title="引用用计数"></a>引用用计数</h5><p>引用计数分为两种：</p><ul><li><p>手动引用计数（MRC）</p></li><li><p>自动引用计数（ARC）</p></li></ul><p>OC的内存机制可以简单概括为：谁持有(retain)谁释放(release)。retain引用计数+1，release反之</p><p><strong>ARC</strong></p><ul><li><p>ARC 是LLVM和Runtime协同的结果</p></li><li><p>ACR 中禁止手动调用 retain/release/retainCount/dealloc</p></li><li><p>ACR 新增weak、strong 属性关键字</p></li></ul><h5 id="引用计数管理"><a href="#引用计数管理" class="headerlink" title="引用计数管理"></a>引用计数管理</h5><p>实现原理分析</p><ul><li><p>alloc</p></li><li><p>retain</p></li><li><p>release</p></li><li><p>dealloc</p></li></ul><blockquote><ul><li>alloc实现<br> 经过一系列的调用，最终调用了C函数calloc<br> 此时并没有设置引用计数为1</li></ul></blockquote><blockquote><ul><li>retain 实现</li></ul></blockquote><p><img src="/img/ios/arm/retain.png"></p><p>我们在进行retain 操作的时候，系统是怎样查找它对应引用计数的？是经过两次hash查找，查找到它对应的引用计数，然后再响应进行 +1 操作</p><blockquote><ul><li>release实现</li></ul></blockquote><p><img src="/img/ios/arm/release.png"></p><blockquote><ul><li>dealloc 实现</li></ul></blockquote><p><img src="/img/ios/arm/dealloc.png"></p><h4 id="弱引用管理（weak）"><a href="#弱引用管理（weak）" class="headerlink" title="弱引用管理（weak）"></a>弱引用管理（weak）</h4><p>weak 关键字的作用弱引用，所引用对象的计数器不会加一，并在引用对象被释放的时候自动被设置为 nil</p><p><strong>weak编译</strong></p><p><img src="/img/ios/arm/weakgl.png"></p><p><strong>weak变量怎样添加到弱引用表？</strong></p><p><img src="/img/ios/arm/addweak.png"></p><p>一个被声明为 __weak的对象指针，经过编译器编译之后会调用 objc_initWeak 方法，经过一系列的函数调用栈，最终在weak_rgister_no_lock()这样一个函数中，进行弱引用变量添加，具体添加的位置是通过哈希算法进行位置，如果查找到对应位置已经有了所对应的弱引用数组，就把新的弱引用用变量添加到数组中，如果没有就创建一个新的弱引用数，第0位置添加新的弱引用指针，其他位置初始化为nil</p><p><strong>weak释放为nil过程</strong></p><p><img src="/img/ios/arm/deallocweak.png"><br>当一个对象被dealloc,在dealloc内部实现当中会调用弱引用相关清理函数，在这个函数内部实现当中会根据当前对象的指针，查找弱引用表，把当前对象相应的弱引用都拿出来，是一个数组，遍历数组当中所有弱引用指针，分别置为nil</p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS_Block</title>
    <link href="/2020/12/12/iOS-Block/"/>
    <url>/2020/12/12/iOS-Block/</url>
    
    <content type="html"><![CDATA[<h3 id="Block-介绍"><a href="#Block-介绍" class="headerlink" title="Block 介绍"></a>Block 介绍</h3><p>block 是将函数及其执行上下文分装起来的对象</p><p>例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&#123;<br>    <span class="hljs-keyword">int</span> mutltiplier = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">int</span>(^Block)(<span class="hljs-keyword">int</span>) = ^<span class="hljs-keyword">int</span>(<span class="hljs-keyword">int</span> num)&#123;<br>        <span class="hljs-keyword">return</span> num * mutltiplier<br>    &#125;<br>    Block(<span class="hljs-number">2</span>)<br><br>&#125;<br><br>``` <br>经由编译编译之后，使用 clange -rewrite-objc  file.m 查看编译器内容<br>``` <br>struct __block_impl &#123;<br>    <span class="hljs-keyword">void</span> *isa; isa指针，Block 是对象的标志<br>    <span class="hljs-keyword">int</span> Flags;<br>    <span class="hljs-keyword">int</span> Reserved;<br>    <span class="hljs-keyword">void</span> *FuncPtr;<span class="hljs-comment">// 无类型的函数指针</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_impl_0</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">block_impl</span> <span class="hljs-title">impl</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span>* <span class="hljs-title">Desc</span>;</span><br>  __main_block_impl_0(<span class="hljs-keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="hljs-keyword">int</span> flags=<span class="hljs-number">0</span>) &#123;<br>    impl.isa = &amp;_NSConcreteStackBlock;<br>    impl.Flags = flags;<br>    impl.FuncPtr = fp;<br>    Desc = desc;<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span> &#123;</span><br>  <span class="hljs-keyword">size_t</span> reserved;<br>  <span class="hljs-keyword">size_t</span> Block_size;<br>&#125; __main_block_desc_0_DATA = &#123; <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct __main_block_impl_0)&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])</span> </span>&#123;<br>    <span class="hljs-comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool;<br>        (<span class="hljs-keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="hljs-keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="block-截获变量特性"><a href="#block-截获变量特性" class="headerlink" title="block 截获变量特性"></a>block 截获变量特性</h3><p>如下代码，看一下最终输出结果</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">&#123;<br>    <span class="hljs-built_in">int</span> mutltiplier = <span class="hljs-number">3</span>;<br>    <span class="hljs-built_in">int</span>(^Block)(<span class="hljs-built_in">int</span>) = ^<span class="hljs-built_in">int</span>(<span class="hljs-built_in">int</span> num)&#123;<br>        return num<span class="hljs-operator"> * </span>mutltiplier<br>    &#125;<br>    <span class="hljs-constructor">Block(2)</span><br>   mutltiplier = <span class="hljs-number">4</span><br>   <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;result is %d&quot;</span>,Block(2)</span>)<br>&#125;<br>result is <span class="hljs-number">6</span><br><br>``` <br><br><br>**block 对以下类类型的变量都有哪些特点**<br><br><br>- 局部变量 （基本数据类型 、 对象类型）<br><br>- 静态局部变量<br><br>- 全局变量<br><br>- 静态全局变量<br><br>``` <br><span class="hljs-built_in">int</span> global_var = <span class="hljs-number">4</span>;<br><br>static <span class="hljs-built_in">int</span> static_global_var = <span class="hljs-number">5</span>;<br><br>- (void)<span class="hljs-keyword">method</span> &#123;<br>    <span class="hljs-comment">//基本数据类型</span><br>    <span class="hljs-built_in">int</span> var = <span class="hljs-number">3</span>;<br>     <span class="hljs-comment">//对象类型</span><br>    __unsafe_unretained id unsafe_obj = nil ;<br>    <br>    __strong id strong_obj = nil ;<br>    <br>    static <span class="hljs-built_in">int</span> static_var = <span class="hljs-number">7</span>;<br>    <br>    void (^Block)(void) = ^&#123;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;局部变量&lt;基本数据类型&gt; var %d&quot;</span>,<span class="hljs-params">var</span>)</span>;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;局部变量 &lt;对象类型&gt;var %@&quot;</span>,<span class="hljs-params">unsafe_obj</span>)</span>;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;局部变量 &lt;对象类型&gt;var %@&quot;</span>,<span class="hljs-params">strong_obj</span>)</span>;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;静态变量  %d&quot;</span>,<span class="hljs-params">static_var</span>)</span>;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;全局变量 global_var %d&quot;</span>,<span class="hljs-params">global_var</span>)</span>;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;静态全局变量 static_global_var %d&quot;</span>,<span class="hljs-params">static_global_var</span>)</span>;<br>    &#125;;<br>    <span class="hljs-constructor">Block()</span>;<br>    <br>    <br>&#125;<br>``` <br>使用 clange -rewrite-objc -fobjc-arc file.m<br><br>.cpp 编译文件中结果<br>``` <br><span class="hljs-built_in">int</span> global_var = <span class="hljs-number">4</span>;<br><br>static <span class="hljs-built_in">int</span> static_global_var = <span class="hljs-number">5</span>;<br><br><br><span class="hljs-keyword">struct</span> __McBlock__method_block_impl_0 &#123;<br>  <span class="hljs-keyword">struct</span> __block_impl impl;<br>  <span class="hljs-keyword">struct</span> __McBlock__method_block_desc_0* Desc;<br>  <span class="hljs-built_in">int</span> var;<br>  __unsafe_unretained id unsafe_obj;<br>  __strong id strong_obj;<br>  <span class="hljs-built_in">int</span> *static_var;<br>  <span class="hljs-constructor">__McBlock__method_block_impl_0(<span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">fp</span>, <span class="hljs-params">struct</span> <span class="hljs-params">__McBlock__method_block_desc_0</span> <span class="hljs-operator">*</span><span class="hljs-params">desc</span>, <span class="hljs-params">int</span> <span class="hljs-params">_var</span>, <span class="hljs-params">__unsafe_unretained</span> <span class="hljs-params">id</span> <span class="hljs-params">_unsafe_obj</span>, <span class="hljs-params">__strong</span> <span class="hljs-params">id</span> <span class="hljs-params">_strong_obj</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">_static_var</span>, <span class="hljs-params">int</span> <span class="hljs-params">flags</span>=0)</span> : var(_var), unsafe<span class="hljs-constructor">_obj(<span class="hljs-params">_unsafe_obj</span>)</span>, strong<span class="hljs-constructor">_obj(<span class="hljs-params">_strong_obj</span>)</span>, static<span class="hljs-constructor">_var(<span class="hljs-params">_static_var</span>)</span> &#123;<br>    impl.isa = &amp;_NSConcreteStackBlock;<br>    impl.Flags = flags;<br>    impl.FuncPtr = fp;<br>    Desc = desc;<br>  &#125;<br>&#125;;<br><br>``` <br><br>**总结**<br><br>- 对于基本数据类型的局部变量截获其值<br><br>- 对于对象类型的局部变量连同所有权修饰符一起截获<br><br>- 对于局部静态变量是以指针形式进行截获<br><br>- 对于全局变量、静态全局变量不截获<br><br><br>### __block 修饰符<br><br> 一般情况下，对截获变量值进行复制操作需要添加__blcok 修饰符<br><br>``` <br> &#123;<br>    NSMutableArray *<span class="hljs-built_in">array</span> = <span class="hljs-literal">[NSM<span class="hljs-identifier">utableArray</span> <span class="hljs-identifier">array</span>]</span>;<br>    void(^Block)(void) = ^&#123;<br>        <span class="hljs-literal">[<span class="hljs-identifier">array</span> <span class="hljs-identifier">addobjcet</span>: @<span class="hljs-number">1234</span>]</span><br>    &#125;<br>    <span class="hljs-constructor">Block()</span><br> &#125;<br></code></pre></td></tr></table></figure><p>是否使用__block 修饰符？</p><p><strong>__block 使用场景</strong></p><ul><li><p>对于局部变量赋值需要</p></li><li><p>对于静态局部变量、全局变量、静态全局变量 不需要</p></li></ul><p>静态局部变量是捕获指针、全局和静态全局不捕获值</p><p><strong>思考</strong></p><pre><code>&#123;    __block int mutltiplier = 3;    int(^Block)(int) = ^int(int num)&#123;        return num * mutltiplier    &#125;    Block(2)   mutltiplier = 4   NSLog(@&quot;result is %d&quot;,Block(2))&#125;result is 8</code></pre><p>因为__blcok修饰的变量变成了对象</p><pre><code>__block int multiplier  编译转化struct _Block_byref_multiplier_0 &#123;void *_isa;__Block_byref_multiplier_0 * _forwarding;int _flagsint _sizeint multiplier&#125;(multiplier._forwarding -&gt; multiplier )= 4</code></pre><p>栈上的 __block forwarding指针指向自身</p><h3 id="block-内存管理"><a href="#block-内存管理" class="headerlink" title="block 内存管理"></a>block 内存管理</h3><p><strong>block分为哪几类</strong></p><ul><li><p>NSConcreteGlobalBlock 全局block</p></li><li><p>NSConcreteGStackBlock 栈block</p></li><li><p>NSConcreteGMallocBlock 堆block</p></li></ul><h4 id="block-copy操作"><a href="#block-copy操作" class="headerlink" title="block copy操作"></a>block copy操作</h4><p><img src="/img/ios/block/blockcopy.png"></p><p><img src="/img/ios/block/duizhan.png"></p><p>一个对象的成员变量是一个block,在栈上面创建这个blcok,如果我们没有使用copy,当我们通过具体的成员变量访问对应blcok,可能由于栈对应的函数退出之后，在内存中就销毁掉了，再继续访问就会引起内存崩溃</p><p><strong>__forwarding存在的意义</strong></p><p><img src="/img/ios/block/copydui.png"></p><p>栈上的forwarding指针指向自身，block经过copy之后，栈上的forwarding指针指向堆上的__block变量，堆上的forwarding指针指向自身</p><p>不论在任何位置，都可以顺利的访问同一个__blcok 变量</p><h4 id="block-循环引用问题"><a href="#block-循环引用问题" class="headerlink" title="block 循环引用问题"></a>block 循环引用问题</h4><p><strong>思考下面代码有什么问题 如何解决</strong></p><pre><code>&#123;    _array = [NSMutableArray arrayWithObjcet:@&quot;123&quot;];    _strBlock = ^NSString*(NSString* str)&#123;        return [NSString stringWithFormat:@&quot;%@_%@&quot;,str,_array[0]];    &#125;    _strBlock(@&quot;hello&quot;);&#125;</code></pre><p>引起自循环引用，当前对象强引用block,block表达式中又使用了当前对象的成员变量array，在截获变量中连同修饰符权限共同截获<br>所以就有一个strong类型的指针指向当前对象，所以产生了，循环引用</p><p>使用__weak NMutableArray *weakarray = _array 解除循环引用</p><p><strong>思考下面代码有什么问题 如何解决</strong></p><pre><code>&#123;    __block TestBlock* blockSelf = self;    _blk = ^int(int num) &#123;        int result = num *blockSelf.var        return result;    &#125;    _blk(3)&#125;</code></pre><p>在MRC不会有任何问题</p><p>ARC情况下</p><p><img src="/img/ios/block/arcyy.png"></p><p>解决办法在block表达式中 blockSelf = nil</p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ios_Runtime</title>
    <link href="/2020/12/11/ios-runtime/"/>
    <url>/2020/12/11/ios-runtime/</url>
    
    <content type="html"><![CDATA[<h3 id="runtime-介绍"><a href="#runtime-介绍" class="headerlink" title="runtime 介绍"></a>runtime 介绍</h3><p>Objective-C 扩展了 C 语言，并加入了面向对象特性和 Smalltalk 式的消息传递机制。而这个扩展的核心是一个用 C 和 编译语言 写的 Runtime 库。它是 Objective-C 面向对象和动态机制的基石</p><h4 id="runtime-基础数据结构"><a href="#runtime-基础数据结构" class="headerlink" title="runtime 基础数据结构"></a>runtime 基础数据结构</h4><p><img src="/img/ios/runtime/runtimejc.png"></p><ul><li><p>objc_object</p></li><li><p>objc_class</p></li><li><p>isa 指针</p></li><li><p>method_t</p></li></ul><h4 id="objc-object-数据结构"><a href="#objc-object-数据结构" class="headerlink" title="objc_object 数据结构"></a>objc_object 数据结构</h4><p><img src="/img/ios/runtime/objcobject.png"></p><h4 id="objc-class-数据结构"><a href="#objc-class-数据结构" class="headerlink" title="objc_class 数据结构"></a>objc_class 数据结构</h4><p><img src="/img/ios/runtime/objcclass.png"></p><p>bits: 一个类的变量、属性、方法 在这个数据结构当中</p><h4 id="isa-指针"><a href="#isa-指针" class="headerlink" title="isa 指针"></a>isa 指针</h4><p> c语言中 共用体isa_t</p><ul><li><p>指针型isa 代表class的地址</p></li><li><p>非指针型isa 部分代表class的地址</p></li></ul><p><img src="/img/ios/runtime/isa.png"></p><p><strong>isa指向</strong></p><p><img src="/img/ios/runtime/isazx.png"></p><ul><li><p>如果我们调用实例方法 isa 去类对象中进行查找</p></li><li><p>如果我们调用的是类方法 isa 去元类对象中查找</p></li></ul><h4 id="cache-t-作用"><a href="#cache-t-作用" class="headerlink" title="cache_t 作用"></a>cache_t 作用</h4><ul><li><p>用于快速查找方法执行函数</p></li><li><p>是可增量扩展的哈希表结构</p></li><li><p>是局部原理的最佳应用</p></li></ul><h4 id="cache-t-大致结构"><a href="#cache-t-大致结构" class="headerlink" title="cache_t 大致结构"></a>cache_t 大致结构</h4><p><img src="/img/ios/runtime/cachet.png"></p><blockquote><p>-流程：根据key通过哈希查找算法，来定位这个key所对应的这个bucke_t 这个数据结构位于数组那个位置，当我们定位到这个位置之后，就可以通过提取bucket_t 里面具体函数实现来调用这个函数<br>key: 就是对应SEL<br>imp: 无类型的函数指针</p></blockquote><h4 id="class-data-bits-t-介绍"><a href="#class-data-bits-t-介绍" class="headerlink" title="class_data_bits_t 介绍"></a>class_data_bits_t 介绍</h4><ul><li><p>class_data_bits_t 主要是对class_rw_t的封装</p></li><li><p>class_rw_t 代表类的相关读写信息，对class_ro_t的封装</p></li><li><p>class_ro_t 代表了类相关的只读信息</p></li></ul><p><strong>class_rw_t</strong></p><p><img src="/img/ios/runtime/classrw.png"></p><ul><li>在我们为一个类添加的分类里的一些方法、协议、属性都在class_rw_t 数据结构当中</li></ul><p><strong>class_ro_t</strong></p><p><img src="/img/ios/runtime/classro.png"></p><p><strong>method_t</strong></p><p><img src="/img/ios/runtime/methodt.png"></p><p><strong>Type Encodings</strong></p><p><img src="/img/ios/runtime/typs.png"></p><h4 id="对象、类对象、元类对象"><a href="#对象、类对象、元类对象" class="headerlink" title="对象、类对象、元类对象"></a>对象、类对象、元类对象</h4><ul><li><p>类对象存储实例方法列表等信息</p></li><li><p>元类对象存储类方法列表等信息</p></li></ul><p><strong>消息传递指向isa superclass图</strong></p><p><img src="/img/ios/runtime/msgcd.png"></p><ul><li><p>元类对象的isa 都指向根元类对象</p></li><li><p>根元类对象 superclass 指向根类对象，当我们调用类方法时，如果在元类对象中逐级父类查找，如果找不到，它就会找根类对象中同名的实例方法</p></li></ul><h4 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h4><p><strong>两个方法</strong></p><blockquote><ul><li>void objc_msgSend(void/<em>id self, SEL op,…</em>/)</li></ul></blockquote><blockquote><ul><li>[self class] -&gt; objc_msgSend(self,@selectior(class))</li></ul></blockquote><blockquote><ul><li>void objc_msgSendSuper(void/* struct objc_super *super ,SEL op, … */)</li></ul></blockquote><blockquote><ul><li>[super class] -&gt; objc_msgSendSuper(super,@selector(class))</li></ul></blockquote><p>super 实际上是编译器关键字，recevier 接收者就是当前对象</p><p><strong>消息传递流程</strong></p><p><img src="/img/ios/runtime/msgz.png"></p><p><strong>缓存查找</strong></p><p><img src="/img/ios/runtime/cachecz.png"></p><ul><li>通过给定的key,根据哈希查找，找出bucket_t 在数组对应的位置，然后获取 imp</li></ul><p><strong>当前类中查找</strong></p><ul><li>对于已排序好的列表，采用二分查找算法查找方法对应的执行函数</li><li>对于没有排序的列表，采用一般遍历查找方法对应的执行函数</li></ul><p><strong>父级逐级查找</strong></p><p><img src="/img/ios/runtime/superclass.png"></p><h4 id="消息转发流程"><a href="#消息转发流程" class="headerlink" title="消息转发流程"></a>消息转发流程</h4><p><img src="/img/ios/runtime/msgzf.png"></p><h4 id="dynamic-关键字"><a href="#dynamic-关键字" class="headerlink" title="@dynamic 关键字"></a>@dynamic 关键字</h4><ul><li><p>动态运行时语言将函数决议推迟到运行时</p></li><li><p>编译时语言在编译器进行函数决议</p></li></ul><p><strong>能否向编译后的类添加增加实例变量？</strong></p><p>不能 编译之前定义创建类已经完成了实例变量的布局，在具体分析runtime 数据结构 class_ro_t 是没有办法修改</p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>oc语言特性</title>
    <link href="/2020/12/11/iOS-ocfeature/"/>
    <url>/2020/12/11/iOS-ocfeature/</url>
    
    <content type="html"><![CDATA[<h3 id="汇总：分类-、关联对象、扩展、通知、kvo、kvc、属性关键字"><a href="#汇总：分类-、关联对象、扩展、通知、kvo、kvc、属性关键字" class="headerlink" title="汇总：分类 、关联对象、扩展、通知、kvo、kvc、属性关键字"></a>汇总：分类 、关联对象、扩展、通知、kvo、kvc、属性关键字</h3><hr><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="分类都做了哪些事情"><a href="#分类都做了哪些事情" class="headerlink" title="分类都做了哪些事情"></a>分类都做了哪些事情</h4><ul><li>声明私有方法</li><li>分解体积庞大的类文件</li><li>把Framework的私有方法公开</li></ul><h4 id="分类的特点"><a href="#分类的特点" class="headerlink" title="分类的特点"></a>分类的特点</h4><ul><li>运行时决议</li><li>可以为系统类添加分类</li></ul><h4 id="分类都可以添加哪些内容"><a href="#分类都可以添加哪些内容" class="headerlink" title="分类都可以添加哪些内容"></a>分类都可以添加哪些内容</h4><ul><li>实例方法</li><li>类方法</li><li>协议</li><li>属性 （只是声明了get 和 set 方法 ，并没有添加实例变量）</li></ul><p><strong>分类的数据结构</strong></p><p><img src="/img/ios/octx/categor.png"></p><p><strong>分类调用栈</strong></p><p><img src="/img/ios/octx/categorystaic.png"></p><p>image: 表示的是镜像<br>read_image:读取镜像，加载一些可执行文件到内存中进行处理</p><p><strong>添加的两个分类a和b 有同名方法那个生效？</strong></p><p>源码分析</p><p><img src="/img/ios/octx/categorycode.png"></p><blockquote><ul><li>最先访问，最后编译的分类，添加的两个分类a和b 有同名方法那个生效，取决于分类的编译顺序，最后编译的那个分类才会生效，前面的会被覆盖掉</li></ul></blockquote><p><strong>分类覆盖宿主类</strong></p><p><img src="/img/ios/octx/categorycode1.png"></p><p><img src="/img/ios/octx/categorycode2.png"></p><ul><li>分类添加的方法“覆盖”原类方法</li><li>同名分类方法谁能生效取决于编译顺序</li><li>名字相同的分类会引起编译报错</li></ul><hr><h3 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h3><h4 id="关联对象方法"><a href="#关联对象方法" class="headerlink" title="关联对象方法"></a>关联对象方法</h4><p>//关联对象</p><ol><li>void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)</li></ol><p>//获取关联的对象</p><ol start="2"><li>id objc_getAssociatedObject(id object, const void *key)</li></ol><p>//移除关联的对象</p><ol start="3"><li>void objc_removeAssociatedObjects(id object)</li></ol><h4 id="关联对象本质"><a href="#关联对象本质" class="headerlink" title="关联对象本质"></a>关联对象本质</h4><ul><li><p>关联对象由AssoctionsManager管理并在AssoctionsHashMap存储</p></li><li><p>所有对象的关联内容都在同一个全局容器中</p></li></ul><p><img src="/img/ios/octx/association.png"></p><hr><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><h4 id="扩展做什么"><a href="#扩展做什么" class="headerlink" title="扩展做什么"></a>扩展做什么</h4><ul><li><p>声明私有属性</p></li><li><p>声明私有方法</p></li><li><p>声明私有成员变量</p></li></ul><h4 id="扩展特性"><a href="#扩展特性" class="headerlink" title="扩展特性"></a>扩展特性</h4><ul><li><p>编译时决议</p></li><li><p>只以声明的形式存在，多数情况下寄生于宿主类.m 中</p></li><li><p>不能为系统类添加扩展</p></li></ul><h3 id="通知（NSNOtification）"><a href="#通知（NSNOtification）" class="headerlink" title="通知（NSNOtification）"></a>通知（NSNOtification）</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li><p>是使用观察者模式来实现的用于跨层传递消息的机制</p></li><li><p>传递方式为 一对多</p></li></ul><h4 id="通知机制"><a href="#通知机制" class="headerlink" title="通知机制"></a>通知机制</h4><p><img src="/img/ios/octx/nsnotification.png"></p><h3 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul><li><p>kvo 是 key-value observing 的缩写</p></li><li><p>kvo 是 oc 对观察者模式的又一种实现</p></li><li><p>apple 使用了 isa 混写（isa-swizzing）来实现 kvo</p></li></ul><p><img src="/img/ios/octx/kvoyuanli.png"></p><p>isa_swizzing:<br>          当我们调用 addObserver:forKeyPath:options:context 之后 系统会在运行时创建NSKVONotifying_* 这样一个类 ，同时将原来的类的isa 指针指向新创建的类。<br>           新创的类实际上是原来类的子类，之所以这做，是重写原来类的setter方法，来达到通知所有观察者对象</p><p><strong>重写的Setter添加的方法</strong></p><ul><li><p>-（void）willChangeValueForKey:(NSString *) key</p></li><li><p>-（void）didChangeValueForKey:(NSString *) key</p></li></ul><p><strong>kvo改变值生效问题</strong></p><ul><li><p>使用setter方法改变值才会生效</p></li><li><p>使用setvalue:forkey 改变值会生效</p></li><li><p>成员变量直接修改需手动添加kvo才会生效</p></li></ul><h3 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h3><h4 id="键值编码技术，会破坏面向对象思想"><a href="#键值编码技术，会破坏面向对象思想" class="headerlink" title="键值编码技术，会破坏面向对象思想"></a>键值编码技术，会破坏面向对象思想</h4><p><strong>两个方法</strong></p><ul><li><p>-（id)valueForKey:(NSString *)key</p></li><li><ul><li>(void)setValue:(id)value forKey:(NNString *)key</li></ul></li></ul><p><strong>valueForKey 流程</strong></p><p><img src="/img/ios/octx/valuekey.png"></p><p><strong>setValue 流程</strong></p><p><img src="/img/ios/octx/setvaluekey.png"></p><hr><h3 id="属性关键字"><a href="#属性关键字" class="headerlink" title="属性关键字"></a>属性关键字</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><ul><li>atomic</li><li>noatomic</li></ul><p>atomic: 赋值获取保证线程安全，操作不保证</p><h4 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h4><ul><li><p>修饰基本数据类型，如 int bool 等</p></li><li><p>修饰对象类时，不改变其引用技数</p></li><li><p>会产生悬垂指针</p></li></ul><h4 id="weak"><a href="#weak" class="headerlink" title="weak"></a>weak</h4><ul><li>不改变被修饰对象的引用计数</li><li>所指的对象在被释放后悔自动置为nil</li></ul><h4 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h4><p>浅拷贝</p><p><img src="/img/ios/octx/qicopy.png"></p><p>深拷贝</p><p><img src="/img/ios/octx/mutablecopy.png"></p><p>cop总结</p><p><img src="/img/ios/octx/copyzj.png"></p><ul><li><p>可变对象的copy和mutableCopy都是深拷贝</p></li><li><p>不可变对象的copy是浅拷贝， mutableCopy是深拷贝</p></li><li><p>copy方法返回的都是不可变对象</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS_UI视图汇总</title>
    <link href="/2020/12/10/iOS-UI/"/>
    <url>/2020/12/10/iOS-UI/</url>
    
    <content type="html"><![CDATA[<h3 id="汇总：事件传递-amp-响应链、图像显示原理、卡顿-amp-掉帧、绘制原理-amp-异步绘制"><a href="#汇总：事件传递-amp-响应链、图像显示原理、卡顿-amp-掉帧、绘制原理-amp-异步绘制" class="headerlink" title="汇总：事件传递&amp;响应链、图像显示原理、卡顿&amp;掉帧、绘制原理&amp;异步绘制"></a>汇总：事件传递&amp;响应链、图像显示原理、卡顿&amp;掉帧、绘制原理&amp;异步绘制</h3><hr><h3 id="UIView-和-CALayer-关系是怎么样的？"><a href="#UIView-和-CALayer-关系是怎么样的？" class="headerlink" title="UIView 和 CALayer 关系是怎么样的？"></a>UIView 和 CALayer 关系是怎么样的？</h3><ul><li>UIView 为其提供内容，以及负责触摸等事件，参与响应链</li><li>CALayer 负责显示内容contens<br><img src="/img/ios/UI/uiview.png"></li></ul><p>UIView和CAlayer从系统设计上符合 单一事件原则</p><hr><h3 id="系统UI事件传递及视图响应"><a href="#系统UI事件传递及视图响应" class="headerlink" title="系统UI事件传递及视图响应"></a>系统UI事件传递及视图响应</h3><h4 id="事件传递"><a href="#事件传递" class="headerlink" title="事件传递"></a>事件传递</h4><p>当一个用户事件产生的时候，UIKit 会创建一个事件对象来描述这个用户事件。然后它会将该事件对象放进UIApplication对象所维护的事件队列中。对于触摸事件而言，产生的事件对象便是一个包含UIEvent的集合(NSSet)对象，一个事件会朝着特定的路径进行传递直到遇到一个可以处理它的对象为止</p><p><strong><em>事件传递的两个重要方法</em></strong></p><ul><li><p>-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event</p></li><li><p>-（BOOL）pointInside:(CGPoint)point withEvent:(UIEvent *)event</p></li></ul><p><strong><em>事件传递流程图</em></strong><br><img src="/img/ios/UI/hitTest.png"></p><p>倒序遍历：最后添加的UIView最优先被遍历<br>hitTest如果有值，返回当前视图，结束事件传递,如果没有UIWindow就作为一个响应的视图</p><p><strong><em>hitTest:WithEvent系统是实现如图</em></strong><br><img src="/img/ios/UI/hitTestEvent.png"></p><ol><li><p>优先判读当前视图的：hidden alpha  等属性，如果不满足返回nil,也就是说当前视图，不作为响应者，然后在由父视图遍历同级兄弟视图</p></li><li><p>判读点击的点是否在当前视图，如果不满足返回nil,也就是<br>说当前视图，不作为响应者，然后在由父视图遍历同级兄弟视图</p></li><li><p>以倒序方式遍历当前视图的所有子视图，遍历过程 调用 hittest 方法,如果有对应的响应视图就返回，如果遍历完成之后，没有对应视图，由于 pointinside 在当前视图范围内，返回当前图作为响应视图返回给调用方</p></li></ol><h4 id="响应链"><a href="#响应链" class="headerlink" title="响应链"></a>响应链</h4><p>响应者链条是由响应者对象构成的，它们有一个共同点就是都是继承自UIResponder，UIResponder的程序接口不仅定义了事件处理方式，还有响应者的一些共同行为。UIApplication，UIViewController和UIView都是响应者，这意味着UIView与其所有子类和大多数主要控制器对象都是响应者，符合设计模式中责任链</p><p><img src="/img/ios/UI/responder.png"></p><ul><li><p>响应链:由离 户最近的view向系统传递。initial view –&gt; super view –&gt; …..–&gt; view controller –&gt; window –&gt; Application –&gt; AppDelegate</p></li><li><p>Hit-Testing 链:由系统向离户最近的view传递。 UIKit –&gt; active app’s event queue –&gt; window –&gt; root view –&gt;……–&gt;lowest view </p></li></ul><hr><h3 id="图层显示原理"><a href="#图层显示原理" class="headerlink" title="图层显示原理"></a>图层显示原理</h3><p><strong><em>cpu和gpu都做了哪些事情</em></strong></p><p><img src="/img/ios/UI/imagePrinciple.png"></p><p>cpu 和 gpu 两个是通过总线连接起来，那么我们在cpu中所输出结果往往是一个位图，再经由总线在合适的时机上传给 gpu, gpu 在拿到位图之后，做相应位图图层的渲染包括纹理合成之后再把结果放到帧缓冲区域当中，由视频控制器根据vsync信号在指定时间之前，去提取对应帧缓冲区域当中屏幕显示内容，然后最终显示在手机屏幕上</p><p><strong><em>UI 视图显示在屏幕上的大致过程</em></strong></p><p><img src="/img/ios/UI/iamgePrinciple1.png"></p><p>首先当我们创建了一个UIview 显示控件后，它的显示部分是由CAlayer 来负责，CAlayer 当中有一个contents 属性，就是我们最终要绘制到屏幕上面的位图，比如说我们创建了一个UIlabel,那么contens里面最终放的结果就是关于hello world的一个文字的位图，然后系统会在合适的时机，回调给我们一个drawRect方法，然后我们可以在此基础之上绘制一些，我们想自定义绘制的内容，绘制好的这个位图，最终经由Core Animation这个框架提交给 gpu 部分的openGL 渲染管线，进行最终位图的渲染和纹理合成，然后会显示我们的屏幕上。</p><p><strong><em>cpu工作</em></strong><br><img src="/img/ios/UI/cpu.png"></p><ul><li>layout: UI布局 文本的计算  </li><li>display: 绘制  </li><li>prepare: 图片编解码 </li><li>commit: 提交位图</li></ul><p><strong><em>gpu工作</em></strong></p><p><img src="/img/ios/UI/gpu.png"></p><h3 id="UI卡顿、掉帧的原因"><a href="#UI卡顿、掉帧的原因" class="headerlink" title="UI卡顿、掉帧的原因"></a>UI卡顿、掉帧的原因</h3><p><strong><em>如图</em></strong></p><p><img src="/img/ios/UI/uikadun.png"></p><ul><li>一般说页面滑动的流畅性是60fps , 指的就是每一秒中会有60帧的画面更新，我们在人眼上面看到的就是流畅效果，基于此每隔16.7ms就要产生一帧画面，在这16.7ms内需要 cpu 和 gpu协同完成这一帧的数据.</li><li>比如 cpu 花费一定的时间做 UI布局 文本计算 视图绘制 图片编解码 然后把产生位图提交给 gpu 进行渲染和纹理合成。准好下一帧画面，然后在下一帧的vsync 信号到来时候就可以显示这么样的一个画面。假如说 cpu 占用时间过长，那么留给gpu的时间就非常少，gpu要想完成工作，那么总时间就会超过16.7ms,这样在下一帧的vsync 信号到来时候，我们没有准备好当下的这一帧画面，那就由此产生了掉帧，看到的效果就是滑动的卡顿。</li></ul><p><strong>总结一句话，在规定的16.7ms内在下一帧vsync信号到来之前，并没有gpu和cpu共同完成下一帧画面的合成于是就会导致卡顿、掉帧</strong></p><hr><h3 id="UIView-绘制原理"><a href="#UIView-绘制原理" class="headerlink" title="UIView 绘制原理"></a>UIView 绘制原理</h3><p>当UIview 调用 setNeedDisplay 系统会调用 calayer 的同名方法，之后相当与在当前 layer打上了一个脏标记，然后会在当前runloop将要结束的时候才会调用CALayer display方法，进入当前视图真正绘制流程。</p><p><img src="/img/ios/UI/uiviwedisplay1.png"></p><h4 id="系统绘制流程"><a href="#系统绘制流程" class="headerlink" title="系统绘制流程"></a>系统绘制流程</h4><p><img src="/img/ios/UI/calayerbacking.png"></p><h4 id="异步绘制流程"><a href="#异步绘制流程" class="headerlink" title="异步绘制流程"></a>异步绘制流程</h4><blockquote><ul><li>-[layer.delegate displayLayer]</li><li>代理负责生成对应的bitmap</li><li>设置该bitmap作为 layer.contents的属性的值<br>  、<br><img src="/img/ios/UI/displayLayer.png"></li></ul></blockquote><h3 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h3><p><strong>离屏渲染：当我们指定UI视图的某些属性标记为在未愈合成之前不能用于当前屏幕显示就会触发离屏渲染，离屏渲染的概念起源于CPU层面，指的是GPU在当前屏幕缓冲区以新开辟一个缓冲区进行渲染操作</strong></p><h4 id="何时会触发？"><a href="#何时会触发？" class="headerlink" title="何时会触发？"></a>何时会触发？</h4><ul><li>圆角（当和 maskToBounds 一起使用时）</li><li>图层蒙版</li><li>阴影</li><li>光栅化</li></ul><h4 id="为何要避免？"><a href="#为何要避免？" class="headerlink" title="为何要避免？"></a>为何要避免？</h4><p><strong>在触发离屏渲染的时候，会增加GPU的工作量，而增加GPU的工作量很有可能会导致GPU和CPU的总耗时超过16.7ms,那么可能会导致UI掉帧和卡顿</strong></p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS  非指针型ISA(NONPOINTER_ISA)</title>
    <link href="/2020/12/09/iOS-isa/"/>
    <url>/2020/12/09/iOS-isa/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是NONPonter-isa？"><a href="#什么是NONPonter-isa？" class="headerlink" title="什么是NONPonter_isa？"></a>什么是NONPonter_isa？</h3><p> <strong>在iOS arm64架构下，isa指针在内存中占64位/bit,但是实际上并不会使用所有的地址空间,为了提高内存的利用率，在剩余的bit</strong><br> <strong>存储了关于内存管理的一些相关内容，所以说这个叫非指针型的isa</strong></p><h3 id="逐一分析这64个bit都存储那些内容"><a href="#逐一分析这64个bit都存储那些内容" class="headerlink" title="逐一分析这64个bit都存储那些内容"></a>逐一分析这64个bit都存储那些内容</h3><ol><li><strong>0-15 位内存地址</strong></li></ol><p><img src="/img/ios/isa15.png"></p><ul><li>indexed:0 代表的是纯isa 指针代表类对象的内存地址 1代表这个isa存储的不仅是类对象的地址而且内存管理方面的数据</li><li>has_assoc: 代表是否有关联对象  0 代表没有 1代表有</li><li>hass_cxx_ditor: 当前对象是否有使用c++</li><li>shifitcls: 当前对象类类对象的指针地址</li></ul><ol start="2"><li><strong>16-31 位内存地址</strong></li></ol><p><img src="/img/ios/isa31.png"></p><ol start="3"><li><p><strong>32-47 位内存地址</strong></p><p><img src="/img/ios/isa47.png"></p></li></ol><ul><li>magic: 不影响内存管理方面解答</li><li>wekkly_referenced: 标识了是否有 弱引用指针</li><li>deallocating: 当前对象是否正在进行dealloc 操作</li><li>has_sidetable_rc: 当前isa指针当中存储的引用计数已经达到了上限，需要外挂一个sidetable这样一个数据结构存储相关的引用计数内容</li><li>extra_rc: 额外的引用计数 当引用计数很小的时候 存储在isa 指针当中</li></ul><ol start="4"><li><strong>48-63 位内存地址</strong></li></ol><p><img src="/img/ios/isa63.png"></p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
