<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2020/12/16/Git/"/>
    <url>/2020/12/16/Git/</url>
    
    <content type="html"><![CDATA[<h3 id="Git介绍"><a href="#Git介绍" class="headerlink" title="Git介绍"></a>Git介绍</h3><p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。<br>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。<br>Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持</p><h3 id="git安装（mac）"><a href="#git安装（mac）" class="headerlink" title="git安装（mac）"></a>git安装（mac）</h3><p>Mac的终端上输入git检测是否安装git</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>t-scm.com/downloads<br><br></code></pre></td></tr></table></figure><p>安装完成之后查看git版本</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">git <span class="hljs-comment">--version</span><br><br></code></pre></td></tr></table></figure><p>创建一个全局用户名、全局邮箱作为配置信息</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog">git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> user<span class="hljs-variable">.name</span> <span class="hljs-string">&quot;your_name&quot;</span>  <br>git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> user<span class="hljs-variable">.email</span> <span class="hljs-string">&quot;your_email@youremail.com&quot;</span><br><br></code></pre></td></tr></table></figure><h3 id="git-本地仓库创建"><a href="#git-本地仓库创建" class="headerlink" title="git 本地仓库创建"></a>git 本地仓库创建</h3><p>打开终端</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-meta"><span class="hljs-meta-keyword">$cd</span> 某一个文件夹下</span><br><span class="hljs-symbol">$</span> git init<br><span class="hljs-symbol">$</span> git add .<br><span class="hljs-symbol">$</span> git commit -m <span class="hljs-string">&#x27;初始化项目版本&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="如果远端已有仓库"><a href="#如果远端已有仓库" class="headerlink" title="如果远端已有仓库"></a>如果远端已有仓库</h4><p>使用命令<br>$git remote add origin 添加远端仓库<br>$git push -u origin master 推送到远端仓库</p><h3 id="工作区域"><a href="#工作区域" class="headerlink" title="工作区域"></a>工作区域</h3><p>git本地有三个工作区域：工作目录 (working) 、暂存区(stage)、本地仓（local rep,如果添加远端git仓（Rmmote）</p><p><img src="/img/ittree/gitimg/gitwork.png"></p><h4 id="git-常用六个命令"><a href="#git-常用六个命令" class="headerlink" title="git 常用六个命令"></a>git 常用六个命令</h4><ul><li><p>git add file: 本地文件添加到暂存区</p></li><li><p>git commit: 提交到本地仓库</p></li><li><p>git push: 推送到远端仓库</p></li><li><p>git pull: 拉取远端分支内容</p></li><li><p>git reset: 撤销提交内容</p></li><li><p>git checkout: 撤销缓存内容</p></li></ul><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>切出分支命令</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> checkout -<span class="hljs-keyword">b</span> dev<br><br></code></pre></td></tr></table></figure><p>创建项目时，会针对不同环境创建三个常设分支</p><ul><li><p>master: 主分支发布版本不轻易修改</p></li><li><p>dev: 功能开发分支</p></li><li><p>test: 测试分支，提交给测试部门</p></li></ul><p><img src="/img/ittree/gitimg/gitliucheng.png"></p><h3 id="git-撤销回滚"><a href="#git-撤销回滚" class="headerlink" title="git 撤销回滚"></a>git 撤销回滚</h3><h4 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h4><p><strong>文件被修改了，但未执行git add操作</strong></p><ul><li><p> git checkout – fliename  某个文件名</p></li><li><p>  git checkout – .   将多个文件一次性撤销可以用</p></li></ul><p><strong>已经添加到暂存区域，从暂存区撤销</strong></p><ul><li><p>git reset HEAD filename 撤销某个</p></li><li><p>git reset HEAD 多个撤销</p></li></ul><p><strong>commit之后，想要撤销到某个版本</strong></p><ol><li><p>git log查看提交记录</p></li><li><p>git  reset –hard  commit_id</p></li></ol><h4 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h4><p><strong>回滚一次错误的合并</strong></p><ol><li><p>git branch backup 备份一个</p></li><li><p>git push origin backup: backup 推送到远端</p></li><li><p>git reset –hard xxxxx 本地仓库彻底回退到xxxxx版本，xxxxx版本之后的commit信息将丢失</p></li><li><p>git push origin :master 删除对应远端分支</p></li><li><p>git push origin master 重新创建远端分支</p></li></ol><p>git revert<br><strong>是回滚某个 commit ，不是回滚“到”某个</strong></p><p>如果错误的修改已经不是最新的commit，回退某次提交的上一步，用git revert。并且会生成一个新的提交来撤销某次提交，此次提交之前的commit都会被保留。</p><p>比如：a操作添加了“haha”，commit了a，b操作添加了“xixi”，commit b。现在想回滚到只添加了“haha”，需要的是删除“xixi”，也就是逆向操作b，所以应该<code>git revert b的commit_id</code>。 <code>git revert</code> 应该翻译成“反转、逆转”比较好理解，而不是回退</p><p>git reset<br>删除commit 之前提交的内容 </p>]]></content>
    
    
    <categories>
      
      <category>ItTree</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络相关</title>
    <link href="/2020/12/15/network/"/>
    <url>/2020/12/15/network/</url>
    
    <content type="html"><![CDATA[<h3 id="概括-http协议-、https网络安全、tcp-upd、DNS解析、Session-Cookie"><a href="#概括-http协议-、https网络安全、tcp-upd、DNS解析、Session-Cookie" class="headerlink" title="概括: http协议 、https网络安全、tcp/upd、DNS解析、Session/Cookie"></a>概括: http协议 、https网络安全、tcp/upd、DNS解析、Session/Cookie</h3><h3 id="网络七层协议"><a href="#网络七层协议" class="headerlink" title="网络七层协议"></a>网络七层协议</h3><p><img src="/img/ittree/network/networkqc.png"></p><h3 id="http协议介绍"><a href="#http协议介绍" class="headerlink" title="http协议介绍"></a>http协议介绍</h3><p>HTTP协议（HyperText Transfer Protocol，超文本传输协议）是因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。<br>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等</p><h4 id="http请求报文"><a href="#http请求报文" class="headerlink" title="http请求报文"></a>http请求报文</h4><p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式</p><p><img src="/img/ittree/network/httprequset.png"></p><h4 id="http-响应报文"><a href="#http-响应报文" class="headerlink" title="http 响应报文"></a>http 响应报文</h4><p>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文</p><p><img src="/img/ittree/network/httprsp.jpg"></p><h4 id="http-请求方法"><a href="#http-请求方法" class="headerlink" title="http 请求方法"></a>http 请求方法</h4><p>get、post、head、options、put、delete 等</p><h4 id="GET-和POST方式的区别"><a href="#GET-和POST方式的区别" class="headerlink" title="GET 和POST方式的区别"></a>GET 和POST方式的区别</h4><ul><li><p>get请求参数以？分割拼接到URL后面，POST请求参数在body里面</p></li><li><p>get参数长度限制2048个字符，post一般没有改限制</p></li><li><p>get请求不安全， post请求比较安全</p></li></ul><p>从语义角度来回答</p><p>get  是获取资源 安全的 幂等的 可缓存的</p><p>post 是处理资源 非安全 非幂等的 不可缓存</p><p>安全性: 不应该引起server端的任何状态变化</p><p>幂等性: 同一个请求方法执行多次和执行一次的效果完全相同</p><h3 id="tcp连接-三次握手-四次挥手"><a href="#tcp连接-三次握手-四次挥手" class="headerlink" title="tcp连接 三次握手 四次挥手"></a>tcp连接 三次握手 四次挥手</h3><p>如图</p><p><img src="/img/ittree/network/tcplink.png"></p><h4 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h4><p>为了防止服务器端开启一些无用的连接增加服务器开销以及防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p><p>由于网络传输是有延时的(要通过网络光纤和各种中间代理服务器)，在传输的过程中，比如客户端发起了SYN=1创建连接的请求(第一次握手)。</p><p>如果服务器端就直接创建了这个连接并返回包含SYN、ACK和Seq等内容的数据包给客户端，这个数据包因为网络传输的原因丢失了，丢失之后客户端就一直没有接收到服务器返回的数据包。</p><p>客户端可能设置了一个超时时间，时间到了就关闭了连接创建的请求。再重新发出创建连接的请求，而服务器端是不知道的，如果没有第三次握手告诉服务器端客户端收的到服务器端传输的数据的话，</p><p>服务器端是不知道客户端有没有接收到服务器端返回的信息的</p><h4 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h4><p>TCP释放连接时之所以需要“四次挥手”,是因为FIN释放连接报文与ACK确认接收报文是分别由第二次和第三次”握手”传输的。为何建立连接时一起传输，释放连接时却要分开传输？</p><p>建立连接时，被动方服务器端结束CLOSED阶段进入“握手”阶段并不需要任何准备，可以直接返回SYN和ACK报文，开始建立连接。<br>释放连接时，被动方服务器，突然收到主动方客户端释放连接的请求时并不能立即释放连接，因为还有必要的数据需要处理，所以服务器先返回ACK确认收到报文，经过CLOSE-WAIT阶段准备好释放连接之后，才能返回FIN释放连接报文</p><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><h4 id="https-介绍"><a href="#https-介绍" class="headerlink" title="https 介绍"></a>https 介绍</h4><p>基于HTTP协议，通过SSL或TLS提供加密处理数据、验证对方身份以及数据完整性保护</p><h4 id="https-连接过程"><a href="#https-连接过程" class="headerlink" title="https 连接过程"></a>https 连接过程</h4><p><img src="/img/ittree/network/ssl.png"></p><p>客户端会发送给服务端一个加密算法的列表，tsl版本号 随机数c ,然后服务端再回给客户端<br>一个ssl证书和商定的加密算法，首先通过非对称加密进行对称加密密钥的传输，之后https之间的<br>网络请求就通过被非对称加密所保护的对称密钥进后续网络访问</p><h4 id="https都使用了什么加密手段"><a href="#https都使用了什么加密手段" class="headerlink" title="https都使用了什么加密手段"></a>https都使用了什么加密手段</h4><ul><li><p>建立连接过程使用非对称加密，非对称加密很耗时</p></li><li><p>后续通信过程使用对称加密</p></li></ul><h3 id="tcp-upd"><a href="#tcp-upd" class="headerlink" title="tcp upd"></a>tcp upd</h3><p>TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP</p><ul><li><p>TCP面向连接; UDP是无连接 的，即发送数据之前不需要建立连接</p></li><li><p>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付</p></li><li><p>tcp 连接是 1对1,UDP支持一对一，一对多，多对一和多对多的交互通信</p></li></ul><h4 id="tcp-特点"><a href="#tcp-特点" class="headerlink" title="tcp 特点"></a>tcp 特点</h4><p>面向连接 可靠传输 面向字节流 流量控制 拥塞控制</p><p>可靠传输 停止等待协议</p><p> 无差错情况 超时重传 确认丢失 确认迟到</p><p>面向字节流</p><p><img src="/img/ittree/network/bit.png"></p><p>流量控制 滑动窗口协议</p><p><img src="/img/ittree/network/chuankou.png"></p><p>拥塞控制</p><p>慢开始、拥塞避免<br>快恢复、快重传</p><p><img src="/img/ittree/network/yongse.png"></p><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>域名到IP地址的映射，DNS解析请求采用UDP数据包且明文</p><p><img src="/img/ittree/network/dns.png"></p><h4 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h4><h4 id="DNS劫持与HTTP的关系是怎样的？"><a href="#DNS劫持与HTTP的关系是怎样的？" class="headerlink" title="DNS劫持与HTTP的关系是怎样的？"></a>DNS劫持与HTTP的关系是怎样的？</h4><p> 没有关系，DNS解析发生在http建立连接之前，DNS解析请求使用UDP数据包，端口是 53</p><h4 id="怎样解决DNS-劫持"><a href="#怎样解决DNS-劫持" class="headerlink" title="怎样解决DNS 劫持"></a>怎样解决DNS 劫持</h4><ul><li>httpNDS </li><li>长连接</li></ul><p>httpDNS: 使用http协议向DNS服务器的80端口进行请求</p><p>长连接：通过长连接通道向 apiserver请求</p><h3 id="session-cookie"><a href="#session-cookie" class="headerlink" title="session/cookie"></a>session/cookie</h3><p>http协议是无状态的，使用 session 和 cookie 作为补偿</p><h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><p>cookie 主要用来记录用户状态，区分用户，状态保存在客户端</p><p>怎样修改cookie?</p><ul><li><p>新cooki覆盖旧cookie</p></li><li><p>覆盖规则: name、path、domain等需要与原cookie一致</p></li></ul><p>怎样删除cookie?</p><p>设置 cookie的expires= 过去的一个时间点，或者maxage= 0</p><h4 id="session"><a href="#session" class="headerlink" title="session"></a>session</h4><p>sessoin 和 cookie的关系是怎样的？</p><ul><li>session需要依赖于cooKie机制</li></ul><p><img src="/img/ittree/network/session.png"></p>]]></content>
    
    
    <categories>
      
      <category>ItTree</category>
      
    </categories>
    
    
    <tags>
      
      <tag>basic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS_Autoreleasepool</title>
    <link href="/2020/12/14/iOS-Autoreleasepool/"/>
    <url>/2020/12/14/iOS-Autoreleasepool/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是自动释放池"><a href="#什么是自动释放池" class="headerlink" title="什么是自动释放池"></a>什么是自动释放池</h3><ul><li><p>是以栈为结点通过双向链表形式组合而成</p></li><li><p>是和线程一一对应</p></li></ul><p>ARC下，我们使用@autoreleasepool{}来使用一个AutoreleasePool，随后编译器将其改写成下面的样子:</p><p><img src="/img/ios/autoreleasePool/autoreleasby.png"></p><p><strong>push转化</strong><br><img src="/img/ios/autoreleasePool/push.png"></p><p><strong>pop转化</strong><br><img src="/img/ios/autoreleasePool/pop.png"></p><p>一次pop实际上是相当于一次批量的pop操作</p><h4 id="AutoreleasePoolPage"><a href="#AutoreleasePoolPage" class="headerlink" title="AutoreleasePoolPage"></a>AutoreleasePoolPage</h4><p>而这两个函数都是对AutoreleasePoolPage的简单封装，所以自动释放机制的核心就在于这个类</p><h5 id="AutoreleasePoolPage数据结构"><a href="#AutoreleasePoolPage数据结构" class="headerlink" title="AutoreleasePoolPage数据结构"></a>AutoreleasePoolPage数据结构</h5><p><img src="/img/ios/autoreleasePool/page.png"></p><ul><li><p>AutoreleasePool并没有单独的结构，惹事由若干个AutoreleasePoolPage以双向链表的形式组合而成</p></li><li><p>AutoreleasePool是按线程一一对应的（结构中的thread指针指向当前线程）</p></li><li><p>AutoreleasePoolPage每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存autorelease对象的地址</p></li><li><p>一个AutoreleasePoolPage的空间被占满时，会新建一个AutoreleasePoolPage对象，连接链表，后来的autorelease对象在新的page加入</p></li><li><p>上面的id *next指针作为游标指向栈顶最新add进来的autorelease对象的下一个位置</p></li></ul><h5 id="AutoreleasePoolPage-push"><a href="#AutoreleasePoolPage-push" class="headerlink" title="AutoreleasePoolPage::push"></a>AutoreleasePoolPage::push</h5><p><img src="/img/ios/autoreleasePool/pagepush.png"></p><p>每当进行一次objc_autoreleasePoolPush调用时，runtime向当前的AutoreleasePoolPage中add进一个哨兵对象，值为0（也就是个nil）</p><h5 id="objc-autorelease-流程"><a href="#objc-autorelease-流程" class="headerlink" title="[objc autorelease] 流程"></a>[objc autorelease] 流程</h5><p><img src="/img/ios/autoreleasePool/liuchen.png"></p><h5 id="AutoreleasePoolPage-pop"><a href="#AutoreleasePoolPage-pop" class="headerlink" title="AutoreleasePoolPage::pop"></a>AutoreleasePoolPage::pop</h5><ul><li><p>根据传入的哨兵对象地址找到哨兵对象所处的page</p></li><li><p>在当前page中，将晚于哨兵对象插入的所有autorelease对象都发送一次- release消息，并向回移动next指针到正确位置</p></li></ul><p><img src="/img/ios/autoreleasePool/pagepop1.png"></p><p><img src="/img/ios/autoreleasePool/pagepop2.png"></p><h4 id="多层嵌套的AutoreleasePool、"><a href="#多层嵌套的AutoreleasePool、" class="headerlink" title="多层嵌套的AutoreleasePool、"></a>多层嵌套的AutoreleasePool、</h4><p>知道了上面的原理，嵌套的AutoreleasePool就非常简单了，pop的时候总会释放到上次push的位置为止，多层的pool就是多个哨兵对象而已，就像剥洋葱一样，每次一层，互不影响</p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS 内存管理</title>
    <link href="/2020/12/14/iOS-Memory/"/>
    <url>/2020/12/14/iOS-Memory/</url>
    
    <content type="html"><![CDATA[<h3 id="汇总：内存分布、内存管理方法、数据结构、ARC-amp-MRC-、weak"><a href="#汇总：内存分布、内存管理方法、数据结构、ARC-amp-MRC-、weak" class="headerlink" title="汇总：内存分布、内存管理方法、数据结构、ARC&amp;MRC 、weak"></a>汇总：内存分布、内存管理方法、数据结构、ARC&amp;MRC 、weak</h3><h4 id="内存分布"><a href="#内存分布" class="headerlink" title="内存分布"></a>内存分布</h4><p>Objective-C是基于C的，不放看下C程序进程的内存分布</p><p><img src="/img/ios/arm/buju.png"></p><p>可以分为部分</p><ul><li><p>.text: 代码区存放函数，程序结束后由系统释放</p></li><li><p>.data: 已经初始化的全局变量和静态变量的一块内存区域。数据段属于静态内存分配,可以分为只读数据段和读写数据段。字符串常量等,是放在只读数据段中，结束程序时才会被收回。</p></li></ul><ul><li><p>.bss: 存放程序中未初始化的全局变量和静态变量的一块内存区域</p></li><li><p>heap:堆区存放进程运行中被动态分配的内存段,它的大小并不固定,可动态扩张或缩减。</p></li></ul><ul><li>stack: 由编译器自动分配并释放，存放函数的参数值，局部变量等</li></ul><h4 id="内存管理方案"><a href="#内存管理方案" class="headerlink" title="内存管理方案"></a>内存管理方案</h4><ul><li><p>TaggedPointer （小对象管理 短string 、NSNumber、NSdata等）</p></li><li><p>NONPOINTER_ISA （iOS arm64位架构下 非指针型isa）</p></li><li><p>散列表 （引用计数表、弱引用表）</p></li></ul><h5 id="散列表方式"><a href="#散列表方式" class="headerlink" title="散列表方式"></a>散列表方式</h5><h5 id="散列表结构"><a href="#散列表结构" class="headerlink" title="散列表结构"></a>散列表结构</h5><p><img src="/img/ios/arm/sideTables.png"></p><h5 id="SideTable结构"><a href="#SideTable结构" class="headerlink" title="SideTable结构"></a>SideTable结构</h5><p><img src="/img/ios/arm/sidetable.png"></p><p><strong>思考：为什么不用一张表管理？</strong></p><p>假如说只有一张sideTable,我们在内存中所有分配的对象，它们引用计数或者弱引用存储都在这张大表当中，我们要操作它们引用计数值，有可能它们是在不同的线程中进行操作吗，由于数据安全访问问题，所以我们要进行加锁，那么这样就会存在一个效率问题。</p><p><img src="/img/ios/arm/sidetablesuo.png"></p><h5 id="散列表数据结构"><a href="#散列表数据结构" class="headerlink" title="散列表数据结构"></a>散列表数据结构</h5><ul><li><p>Spinlock_t</p></li><li><p>RefcountMap </p></li><li><p>weak_table_t</p></li></ul><p>spinLock_t 特点</p><ul><li><p>是 “忙等”的锁</p></li><li><p>适用于轻量访问</p></li></ul><p>如果当前锁已被其他线程所获取，当前线程会不断的探测这锁有没有被释放，如果释放，自己第一时间去获取，所以说自旋锁是一种忙等的锁</p><p>再比如其他锁，如信号量，如果当前线程获取不到这个锁，它会把当前线程进行阻塞休眠，等到其他线程<br>释放这个锁的时候，再唤醒这个线程</p><h5 id="引用用计数"><a href="#引用用计数" class="headerlink" title="引用用计数"></a>引用用计数</h5><p>引用计数分为两种：</p><ul><li><p>手动引用计数（MRC）</p></li><li><p>自动引用计数（ARC）</p></li></ul><p>OC的内存机制可以简单概括为：谁持有(retain)谁释放(release)。retain引用计数+1，release反之</p><p><strong>ARC</strong></p><ul><li><p>ARC 是LLVM和Runtime协同的结果</p></li><li><p>ACR 中禁止手动调用 retain/release/retainCount/dealloc</p></li><li><p>ACR 新增weak、strong 属性关键字</p></li></ul><h5 id="引用计数管理"><a href="#引用计数管理" class="headerlink" title="引用计数管理"></a>引用计数管理</h5><p>实现原理分析</p><ul><li><p>alloc</p></li><li><p>retain</p></li><li><p>release</p></li><li><p>dealloc</p></li></ul><blockquote><ul><li>alloc实现<br> 经过一系列的调用，最终调用了C函数calloc<br> 此时并没有设置引用计数为1</li></ul></blockquote><blockquote><ul><li>retain 实现</li></ul></blockquote><p><img src="/img/ios/arm/retain.png"></p><p>我们在进行retain 操作的时候，系统是怎样查找它对应引用计数的？是经过两次hash查找，查找到它对应的引用计数，然后再响应进行 +1 操作</p><blockquote><ul><li>release实现</li></ul></blockquote><p><img src="/img/ios/arm/release.png"></p><blockquote><ul><li>dealloc 实现</li></ul></blockquote><p><img src="/img/ios/arm/dealloc.png"></p><h4 id="弱引用管理（weak）"><a href="#弱引用管理（weak）" class="headerlink" title="弱引用管理（weak）"></a>弱引用管理（weak）</h4><p>weak 关键字的作用弱引用，所引用对象的计数器不会加一，并在引用对象被释放的时候自动被设置为 nil</p><p><strong>weak编译</strong></p><p><img src="/img/ios/arm/weakgl.png"></p><p><strong>weak变量怎样添加到弱引用表？</strong></p><p><img src="/img/ios/arm/addweak.png"></p><p>一个被声明为 __weak的对象指针，经过编译器编译之后会调用 objc_initWeak 方法，经过一系列的函数调用栈，最终在weak_rgister_no_lock()这样一个函数中，进行弱引用变量添加，具体添加的位置是通过哈希算法进行位置，如果查找到对应位置已经有了所对应的弱引用数组，就把新的弱引用用变量添加到数组中，如果没有就创建一个新的弱引用数，第0位置添加新的弱引用指针，其他位置初始化为nil</p><p><strong>weak释放为nil过程</strong></p><p><img src="/img/ios/arm/deallocweak.png"><br>当一个对象被dealloc,在dealloc内部实现当中会调用弱引用相关清理函数，在这个函数内部实现当中会根据当前对象的指针，查找弱引用表，把当前对象相应的弱引用都拿出来，是一个数组，遍历数组当中所有弱引用指针，分别置为nil</p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS_Block</title>
    <link href="/2020/12/12/iOS-Block/"/>
    <url>/2020/12/12/iOS-Block/</url>
    
    <content type="html"><![CDATA[<h3 id="Block-介绍"><a href="#Block-介绍" class="headerlink" title="Block 介绍"></a>Block 介绍</h3><p>block 是将函数及其执行上下文分装起来的对象</p><p>例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&#123;<br>    <span class="hljs-keyword">int</span> mutltiplier = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">int</span>(^Block)(<span class="hljs-keyword">int</span>) = ^<span class="hljs-keyword">int</span>(<span class="hljs-keyword">int</span> num)&#123;<br>        <span class="hljs-keyword">return</span> num * mutltiplier<br>    &#125;<br>    Block(<span class="hljs-number">2</span>)<br><br>&#125;<br><br>``` <br>经由编译编译之后，使用 clange -rewrite-objc  file.m 查看编译器内容<br>``` <br>struct __block_impl &#123;<br>    <span class="hljs-keyword">void</span> *isa; isa指针，Block 是对象的标志<br>    <span class="hljs-keyword">int</span> Flags;<br>    <span class="hljs-keyword">int</span> Reserved;<br>    <span class="hljs-keyword">void</span> *FuncPtr;<span class="hljs-comment">// 无类型的函数指针</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_impl_0</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">block_impl</span> <span class="hljs-title">impl</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span>* <span class="hljs-title">Desc</span>;</span><br>  __main_block_impl_0(<span class="hljs-keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="hljs-keyword">int</span> flags=<span class="hljs-number">0</span>) &#123;<br>    impl.isa = &amp;_NSConcreteStackBlock;<br>    impl.Flags = flags;<br>    impl.FuncPtr = fp;<br>    Desc = desc;<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">main_block_desc_0</span> &#123;</span><br>  <span class="hljs-keyword">size_t</span> reserved;<br>  <span class="hljs-keyword">size_t</span> Block_size;<br>&#125; __main_block_desc_0_DATA = &#123; <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct __main_block_impl_0)&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[])</span> </span>&#123;<br>    <span class="hljs-comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool;<br>        (<span class="hljs-keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="hljs-keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="block-截获变量特性"><a href="#block-截获变量特性" class="headerlink" title="block 截获变量特性"></a>block 截获变量特性</h3><p>如下代码，看一下最终输出结果</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">&#123;<br>    <span class="hljs-built_in">int</span> mutltiplier = <span class="hljs-number">3</span>;<br>    <span class="hljs-built_in">int</span>(^Block)(<span class="hljs-built_in">int</span>) = ^<span class="hljs-built_in">int</span>(<span class="hljs-built_in">int</span> num)&#123;<br>        return num<span class="hljs-operator"> * </span>mutltiplier<br>    &#125;<br>    <span class="hljs-constructor">Block(2)</span><br>   mutltiplier = <span class="hljs-number">4</span><br>   <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;result is %d&quot;</span>,Block(2)</span>)<br>&#125;<br>result is <span class="hljs-number">6</span><br><br>``` <br><br><br>**block 对以下类类型的变量都有哪些特点**<br><br><br>- 局部变量 （基本数据类型 、 对象类型）<br><br>- 静态局部变量<br><br>- 全局变量<br><br>- 静态全局变量<br><br>``` <br><span class="hljs-built_in">int</span> global_var = <span class="hljs-number">4</span>;<br><br>static <span class="hljs-built_in">int</span> static_global_var = <span class="hljs-number">5</span>;<br><br>- (void)<span class="hljs-keyword">method</span> &#123;<br>    <span class="hljs-comment">//基本数据类型</span><br>    <span class="hljs-built_in">int</span> var = <span class="hljs-number">3</span>;<br>     <span class="hljs-comment">//对象类型</span><br>    __unsafe_unretained id unsafe_obj = nil ;<br>    <br>    __strong id strong_obj = nil ;<br>    <br>    static <span class="hljs-built_in">int</span> static_var = <span class="hljs-number">7</span>;<br>    <br>    void (^Block)(void) = ^&#123;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;局部变量&lt;基本数据类型&gt; var %d&quot;</span>,<span class="hljs-params">var</span>)</span>;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;局部变量 &lt;对象类型&gt;var %@&quot;</span>,<span class="hljs-params">unsafe_obj</span>)</span>;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;局部变量 &lt;对象类型&gt;var %@&quot;</span>,<span class="hljs-params">strong_obj</span>)</span>;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;静态变量  %d&quot;</span>,<span class="hljs-params">static_var</span>)</span>;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;全局变量 global_var %d&quot;</span>,<span class="hljs-params">global_var</span>)</span>;<br>        <span class="hljs-constructor">NSLog(@<span class="hljs-string">&quot;静态全局变量 static_global_var %d&quot;</span>,<span class="hljs-params">static_global_var</span>)</span>;<br>    &#125;;<br>    <span class="hljs-constructor">Block()</span>;<br>    <br>    <br>&#125;<br>``` <br>使用 clange -rewrite-objc -fobjc-arc file.m<br><br>.cpp 编译文件中结果<br>``` <br><span class="hljs-built_in">int</span> global_var = <span class="hljs-number">4</span>;<br><br>static <span class="hljs-built_in">int</span> static_global_var = <span class="hljs-number">5</span>;<br><br><br><span class="hljs-keyword">struct</span> __McBlock__method_block_impl_0 &#123;<br>  <span class="hljs-keyword">struct</span> __block_impl impl;<br>  <span class="hljs-keyword">struct</span> __McBlock__method_block_desc_0* Desc;<br>  <span class="hljs-built_in">int</span> var;<br>  __unsafe_unretained id unsafe_obj;<br>  __strong id strong_obj;<br>  <span class="hljs-built_in">int</span> *static_var;<br>  <span class="hljs-constructor">__McBlock__method_block_impl_0(<span class="hljs-params">void</span> <span class="hljs-operator">*</span><span class="hljs-params">fp</span>, <span class="hljs-params">struct</span> <span class="hljs-params">__McBlock__method_block_desc_0</span> <span class="hljs-operator">*</span><span class="hljs-params">desc</span>, <span class="hljs-params">int</span> <span class="hljs-params">_var</span>, <span class="hljs-params">__unsafe_unretained</span> <span class="hljs-params">id</span> <span class="hljs-params">_unsafe_obj</span>, <span class="hljs-params">__strong</span> <span class="hljs-params">id</span> <span class="hljs-params">_strong_obj</span>, <span class="hljs-params">int</span> <span class="hljs-operator">*</span><span class="hljs-params">_static_var</span>, <span class="hljs-params">int</span> <span class="hljs-params">flags</span>=0)</span> : var(_var), unsafe<span class="hljs-constructor">_obj(<span class="hljs-params">_unsafe_obj</span>)</span>, strong<span class="hljs-constructor">_obj(<span class="hljs-params">_strong_obj</span>)</span>, static<span class="hljs-constructor">_var(<span class="hljs-params">_static_var</span>)</span> &#123;<br>    impl.isa = &amp;_NSConcreteStackBlock;<br>    impl.Flags = flags;<br>    impl.FuncPtr = fp;<br>    Desc = desc;<br>  &#125;<br>&#125;;<br><br>``` <br><br>**总结**<br><br>- 对于基本数据类型的局部变量截获其值<br><br>- 对于对象类型的局部变量连同所有权修饰符一起截获<br><br>- 对于局部静态变量是以指针形式进行截获<br><br>- 对于全局变量、静态全局变量不截获<br><br><br>### __block 修饰符<br><br> 一般情况下，对截获变量值进行复制操作需要添加__blcok 修饰符<br><br>``` <br> &#123;<br>    NSMutableArray *<span class="hljs-built_in">array</span> = <span class="hljs-literal">[NSM<span class="hljs-identifier">utableArray</span> <span class="hljs-identifier">array</span>]</span>;<br>    void(^Block)(void) = ^&#123;<br>        <span class="hljs-literal">[<span class="hljs-identifier">array</span> <span class="hljs-identifier">addobjcet</span>: @<span class="hljs-number">1234</span>]</span><br>    &#125;<br>    <span class="hljs-constructor">Block()</span><br> &#125;<br></code></pre></td></tr></table></figure><p>是否使用__block 修饰符？</p><p><strong>__block 使用场景</strong></p><ul><li><p>对于局部变量赋值需要</p></li><li><p>对于静态局部变量、全局变量、静态全局变量 不需要</p></li></ul><p>静态局部变量是捕获指针、全局和静态全局不捕获值</p><p><strong>思考</strong></p><pre><code>&#123;    __block int mutltiplier = 3;    int(^Block)(int) = ^int(int num)&#123;        return num * mutltiplier    &#125;    Block(2)   mutltiplier = 4   NSLog(@&quot;result is %d&quot;,Block(2))&#125;result is 8</code></pre><p>因为__blcok修饰的变量变成了对象</p><pre><code>__block int multiplier  编译转化struct _Block_byref_multiplier_0 &#123;void *_isa;__Block_byref_multiplier_0 * _forwarding;int _flagsint _sizeint multiplier&#125;(multiplier._forwarding -&gt; multiplier )= 4</code></pre><p>栈上的 __block forwarding指针指向自身</p><h3 id="block-内存管理"><a href="#block-内存管理" class="headerlink" title="block 内存管理"></a>block 内存管理</h3><p><strong>block分为哪几类</strong></p><ul><li><p>NSConcreteGlobalBlock 全局block</p></li><li><p>NSConcreteGStackBlock 栈block</p></li><li><p>NSConcreteGMallocBlock 堆block</p></li></ul><h4 id="block-copy操作"><a href="#block-copy操作" class="headerlink" title="block copy操作"></a>block copy操作</h4><p><img src="/img/ios/block/blockcopy.png"></p><p><img src="/img/ios/block/duizhan.png"></p><p>一个对象的成员变量是一个block,在栈上面创建这个blcok,如果我们没有使用copy,当我们通过具体的成员变量访问对应blcok,可能由于栈对应的函数退出之后，在内存中就销毁掉了，再继续访问就会引起内存崩溃</p><p><strong>__forwarding存在的意义</strong></p><p><img src="/img/ios/block/copydui.png"></p><p>栈上的forwarding指针指向自身，block经过copy之后，栈上的forwarding指针指向堆上的__block变量，堆上的forwarding指针指向自身</p><p>不论在任何位置，都可以顺利的访问同一个__blcok 变量</p><h4 id="block-循环引用问题"><a href="#block-循环引用问题" class="headerlink" title="block 循环引用问题"></a>block 循环引用问题</h4><p><strong>思考下面代码有什么问题 如何解决</strong></p><pre><code>&#123;    _array = [NSMutableArray arrayWithObjcet:@&quot;123&quot;];    _strBlock = ^NSString*(NSString* str)&#123;        return [NSString stringWithFormat:@&quot;%@_%@&quot;,str,_array[0]];    &#125;    _strBlock(@&quot;hello&quot;);&#125;</code></pre><p>引起自循环引用，当前对象强引用block,block表达式中又使用了当前对象的成员变量array，在截获变量中连同修饰符权限共同截获<br>所以就有一个strong类型的指针指向当前对象，所以产生了，循环引用</p><p>使用__weak NMutableArray *weakarray = _array 解除循环引用</p><p><strong>思考下面代码有什么问题 如何解决</strong></p><pre><code>&#123;    __block TestBlock* blockSelf = self;    _blk = ^int(int num) &#123;        int result = num *blockSelf.var        return result;    &#125;    _blk(3)&#125;</code></pre><p>在MRC不会有任何问题</p><p>ARC情况下</p><p><img src="/img/ios/block/arcyy.png"></p><p>解决办法在block表达式中 blockSelf = nil</p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ios_Runtime</title>
    <link href="/2020/12/11/ios-runtime/"/>
    <url>/2020/12/11/ios-runtime/</url>
    
    <content type="html"><![CDATA[<h3 id="runtime-介绍"><a href="#runtime-介绍" class="headerlink" title="runtime 介绍"></a>runtime 介绍</h3><p>Objective-C 扩展了 C 语言，并加入了面向对象特性和 Smalltalk 式的消息传递机制。而这个扩展的核心是一个用 C 和 编译语言 写的 Runtime 库。它是 Objective-C 面向对象和动态机制的基石</p><h4 id="runtime-基础数据结构"><a href="#runtime-基础数据结构" class="headerlink" title="runtime 基础数据结构"></a>runtime 基础数据结构</h4><p><img src="/img/ios/runtime/runtimejc.png"></p><ul><li><p>objc_object</p></li><li><p>objc_class</p></li><li><p>isa 指针</p></li><li><p>method_t</p></li></ul><h4 id="objc-object-数据结构"><a href="#objc-object-数据结构" class="headerlink" title="objc_object 数据结构"></a>objc_object 数据结构</h4><p><img src="/img/ios/runtime/objcobject.png"></p><h4 id="objc-class-数据结构"><a href="#objc-class-数据结构" class="headerlink" title="objc_class 数据结构"></a>objc_class 数据结构</h4><p><img src="/img/ios/runtime/objcclass.png"></p><p>bits: 一个类的变量、属性、方法 在这个数据结构当中</p><h4 id="isa-指针"><a href="#isa-指针" class="headerlink" title="isa 指针"></a>isa 指针</h4><p> c语言中 共用体isa_t</p><ul><li><p>指针型isa 代表class的地址</p></li><li><p>非指针型isa 部分代表class的地址</p></li></ul><p><img src="/img/ios/runtime/isa.png"></p><p><strong>isa指向</strong></p><p><img src="/img/ios/runtime/isazx.png"></p><ul><li><p>如果我们调用实例方法 isa 去类对象中进行查找</p></li><li><p>如果我们调用的是类方法 isa 去元类对象中查找</p></li></ul><h4 id="cache-t-作用"><a href="#cache-t-作用" class="headerlink" title="cache_t 作用"></a>cache_t 作用</h4><ul><li><p>用于快速查找方法执行函数</p></li><li><p>是可增量扩展的哈希表结构</p></li><li><p>是局部原理的最佳应用</p></li></ul><h4 id="cache-t-大致结构"><a href="#cache-t-大致结构" class="headerlink" title="cache_t 大致结构"></a>cache_t 大致结构</h4><p><img src="/img/ios/runtime/cachet.png"></p><blockquote><p>-流程：根据key通过哈希查找算法，来定位这个key所对应的这个bucke_t 这个数据结构位于数组那个位置，当我们定位到这个位置之后，就可以通过提取bucket_t 里面具体函数实现来调用这个函数<br>key: 就是对应SEL<br>imp: 无类型的函数指针</p></blockquote><h4 id="class-data-bits-t-介绍"><a href="#class-data-bits-t-介绍" class="headerlink" title="class_data_bits_t 介绍"></a>class_data_bits_t 介绍</h4><ul><li><p>class_data_bits_t 主要是对class_rw_t的封装</p></li><li><p>class_rw_t 代表类的相关读写信息，对class_ro_t的封装</p></li><li><p>class_ro_t 代表了类相关的只读信息</p></li></ul><p><strong>class_rw_t</strong></p><p><img src="/img/ios/runtime/classrw.png"></p><ul><li>在我们为一个类添加的分类里的一些方法、协议、属性都在class_rw_t 数据结构当中</li></ul><p><strong>class_ro_t</strong></p><p><img src="/img/ios/runtime/classro.png"></p><p><strong>method_t</strong></p><p><img src="/img/ios/runtime/methodt.png"></p><p><strong>Type Encodings</strong></p><p><img src="/img/ios/runtime/typs.png"></p><h4 id="对象、类对象、元类对象"><a href="#对象、类对象、元类对象" class="headerlink" title="对象、类对象、元类对象"></a>对象、类对象、元类对象</h4><ul><li><p>类对象存储实例方法列表等信息</p></li><li><p>元类对象存储类方法列表等信息</p></li></ul><p><strong>消息传递指向isa superclass图</strong></p><p><img src="/img/ios/runtime/msgcd.png"></p><ul><li><p>元类对象的isa 都指向根元类对象</p></li><li><p>根元类对象 superclass 指向根类对象，当我们调用类方法时，如果在元类对象中逐级父类查找，如果找不到，它就会找根类对象中同名的实例方法</p></li></ul><h4 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h4><p><strong>两个方法</strong></p><blockquote><ul><li>void objc_msgSend(void/<em>id self, SEL op,…</em>/)</li></ul></blockquote><blockquote><ul><li>[self class] -&gt; objc_msgSend(self,@selectior(class))</li></ul></blockquote><blockquote><ul><li>void objc_msgSendSuper(void/* struct objc_super *super ,SEL op, … */)</li></ul></blockquote><blockquote><ul><li>[super class] -&gt; objc_msgSendSuper(super,@selector(class))</li></ul></blockquote><p>super 实际上是编译器关键字，recevier 接收者就是当前对象</p><p><strong>消息传递流程</strong></p><p><img src="/img/ios/runtime/msgz.png"></p><p><strong>缓存查找</strong></p><p><img src="/img/ios/runtime/cachecz.png"></p><ul><li>通过给定的key,根据哈希查找，找出bucket_t 在数组对应的位置，然后获取 imp</li></ul><p><strong>当前类中查找</strong></p><ul><li>对于已排序好的列表，采用二分查找算法查找方法对应的执行函数</li><li>对于没有排序的列表，采用一般遍历查找方法对应的执行函数</li></ul><p><strong>父级逐级查找</strong></p><p><img src="/img/ios/runtime/superclass.png"></p><h4 id="消息转发流程"><a href="#消息转发流程" class="headerlink" title="消息转发流程"></a>消息转发流程</h4><p><img src="/img/ios/runtime/msgzf.png"></p><h4 id="dynamic-关键字"><a href="#dynamic-关键字" class="headerlink" title="@dynamic 关键字"></a>@dynamic 关键字</h4><ul><li><p>动态运行时语言将函数决议推迟到运行时</p></li><li><p>编译时语言在编译器进行函数决议</p></li></ul><p><strong>能否向编译后的类添加增加实例变量？</strong></p><p>不能 编译之前定义创建类已经完成了实例变量的布局，在具体分析runtime 数据结构 class_ro_t 是没有办法修改</p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>oc语言特性</title>
    <link href="/2020/12/11/iOS-ocfeature/"/>
    <url>/2020/12/11/iOS-ocfeature/</url>
    
    <content type="html"><![CDATA[<h3 id="汇总：分类-、关联对象、扩展、通知、kvo、kvc、属性关键字"><a href="#汇总：分类-、关联对象、扩展、通知、kvo、kvc、属性关键字" class="headerlink" title="汇总：分类 、关联对象、扩展、通知、kvo、kvc、属性关键字"></a>汇总：分类 、关联对象、扩展、通知、kvo、kvc、属性关键字</h3><hr><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="分类都做了哪些事情"><a href="#分类都做了哪些事情" class="headerlink" title="分类都做了哪些事情"></a>分类都做了哪些事情</h4><ul><li>声明私有方法</li><li>分解体积庞大的类文件</li><li>把Framework的私有方法公开</li></ul><h4 id="分类的特点"><a href="#分类的特点" class="headerlink" title="分类的特点"></a>分类的特点</h4><ul><li>运行时决议</li><li>可以为系统类添加分类</li></ul><h4 id="分类都可以添加哪些内容"><a href="#分类都可以添加哪些内容" class="headerlink" title="分类都可以添加哪些内容"></a>分类都可以添加哪些内容</h4><ul><li>实例方法</li><li>类方法</li><li>协议</li><li>属性 （只是声明了get 和 set 方法 ，并没有添加实例变量）</li></ul><p><strong>分类的数据结构</strong></p><p><img src="/img/ios/octx/categor.png"></p><p><strong>分类调用栈</strong></p><p><img src="/img/ios/octx/categorystaic.png"></p><p>image: 表示的是镜像<br>read_image:读取镜像，加载一些可执行文件到内存中进行处理</p><p><strong>添加的两个分类a和b 有同名方法那个生效？</strong></p><p>源码分析</p><p><img src="/img/ios/octx/categorycode.png"></p><blockquote><ul><li>最先访问，最后编译的分类，添加的两个分类a和b 有同名方法那个生效，取决于分类的编译顺序，最后编译的那个分类才会生效，前面的会被覆盖掉</li></ul></blockquote><p><strong>分类覆盖宿主类</strong></p><p><img src="/img/ios/octx/categorycode1.png"></p><p><img src="/img/ios/octx/categorycode2.png"></p><ul><li>分类添加的方法“覆盖”原类方法</li><li>同名分类方法谁能生效取决于编译顺序</li><li>名字相同的分类会引起编译报错</li></ul><hr><h3 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h3><h4 id="关联对象方法"><a href="#关联对象方法" class="headerlink" title="关联对象方法"></a>关联对象方法</h4><p>//关联对象</p><ol><li>void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)</li></ol><p>//获取关联的对象</p><ol start="2"><li>id objc_getAssociatedObject(id object, const void *key)</li></ol><p>//移除关联的对象</p><ol start="3"><li>void objc_removeAssociatedObjects(id object)</li></ol><h4 id="关联对象本质"><a href="#关联对象本质" class="headerlink" title="关联对象本质"></a>关联对象本质</h4><ul><li><p>关联对象由AssoctionsManager管理并在AssoctionsHashMap存储</p></li><li><p>所有对象的关联内容都在同一个全局容器中</p></li></ul><p><img src="/img/ios/octx/association.png"></p><hr><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><h4 id="扩展做什么"><a href="#扩展做什么" class="headerlink" title="扩展做什么"></a>扩展做什么</h4><ul><li><p>声明私有属性</p></li><li><p>声明私有方法</p></li><li><p>声明私有成员变量</p></li></ul><h4 id="扩展特性"><a href="#扩展特性" class="headerlink" title="扩展特性"></a>扩展特性</h4><ul><li><p>编译时决议</p></li><li><p>只以声明的形式存在，多数情况下寄生于宿主类.m 中</p></li><li><p>不能为系统类添加扩展</p></li></ul><h3 id="通知（NSNOtification）"><a href="#通知（NSNOtification）" class="headerlink" title="通知（NSNOtification）"></a>通知（NSNOtification）</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li><p>是使用观察者模式来实现的用于跨层传递消息的机制</p></li><li><p>传递方式为 一对多</p></li></ul><h4 id="通知机制"><a href="#通知机制" class="headerlink" title="通知机制"></a>通知机制</h4><p><img src="/img/ios/octx/nsnotification.png"></p><h3 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul><li><p>kvo 是 key-value observing 的缩写</p></li><li><p>kvo 是 oc 对观察者模式的又一种实现</p></li><li><p>apple 使用了 isa 混写（isa-swizzing）来实现 kvo</p></li></ul><p><img src="/img/ios/octx/kvoyuanli.png"></p><p>isa_swizzing:<br>          当我们调用 addObserver:forKeyPath:options:context 之后 系统会在运行时创建NSKVONotifying_* 这样一个类 ，同时将原来的类的isa 指针指向新创建的类。<br>           新创的类实际上是原来类的子类，之所以这做，是重写原来类的setter方法，来达到通知所有观察者对象</p><p><strong>重写的Setter添加的方法</strong></p><ul><li><p>-（void）willChangeValueForKey:(NSString *) key</p></li><li><p>-（void）didChangeValueForKey:(NSString *) key</p></li></ul><p><strong>kvo改变值生效问题</strong></p><ul><li><p>使用setter方法改变值才会生效</p></li><li><p>使用setvalue:forkey 改变值会生效</p></li><li><p>成员变量直接修改需手动添加kvo才会生效</p></li></ul><h3 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h3><h4 id="键值编码技术，会破坏面向对象思想"><a href="#键值编码技术，会破坏面向对象思想" class="headerlink" title="键值编码技术，会破坏面向对象思想"></a>键值编码技术，会破坏面向对象思想</h4><p><strong>两个方法</strong></p><ul><li><p>-（id)valueForKey:(NSString *)key</p></li><li><ul><li>(void)setValue:(id)value forKey:(NNString *)key</li></ul></li></ul><p><strong>valueForKey 流程</strong></p><p><img src="/img/ios/octx/valuekey.png"></p><p><strong>setValue 流程</strong></p><p><img src="/img/ios/octx/setvaluekey.png"></p><hr><h3 id="属性关键字"><a href="#属性关键字" class="headerlink" title="属性关键字"></a>属性关键字</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><ul><li>atomic</li><li>noatomic</li></ul><p>atomic: 赋值获取保证线程安全，操作不保证</p><h4 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h4><ul><li><p>修饰基本数据类型，如 int bool 等</p></li><li><p>修饰对象类时，不改变其引用技数</p></li><li><p>会产生悬垂指针</p></li></ul><h4 id="weak"><a href="#weak" class="headerlink" title="weak"></a>weak</h4><ul><li>不改变被修饰对象的引用计数</li><li>所指的对象在被释放后悔自动置为nil</li></ul><h4 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h4><p>浅拷贝</p><p><img src="/img/ios/octx/qicopy.png"></p><p>深拷贝</p><p><img src="/img/ios/octx/mutablecopy.png"></p><p>cop总结</p><p><img src="/img/ios/octx/copyzj.png"></p><ul><li><p>可变对象的copy和mutableCopy都是深拷贝</p></li><li><p>不可变对象的copy是浅拷贝， mutableCopy是深拷贝</p></li><li><p>copy方法返回的都是不可变对象</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS_UI视图汇总</title>
    <link href="/2020/12/10/iOS-UI/"/>
    <url>/2020/12/10/iOS-UI/</url>
    
    <content type="html"><![CDATA[<h3 id="汇总：事件传递-amp-响应链、图像显示原理、卡顿-amp-掉帧、绘制原理-amp-异步绘制"><a href="#汇总：事件传递-amp-响应链、图像显示原理、卡顿-amp-掉帧、绘制原理-amp-异步绘制" class="headerlink" title="汇总：事件传递&amp;响应链、图像显示原理、卡顿&amp;掉帧、绘制原理&amp;异步绘制"></a>汇总：事件传递&amp;响应链、图像显示原理、卡顿&amp;掉帧、绘制原理&amp;异步绘制</h3><hr><h3 id="UIView-和-CALayer-关系是怎么样的？"><a href="#UIView-和-CALayer-关系是怎么样的？" class="headerlink" title="UIView 和 CALayer 关系是怎么样的？"></a>UIView 和 CALayer 关系是怎么样的？</h3><ul><li>UIView 为其提供内容，以及负责触摸等事件，参与响应链</li><li>CALayer 负责显示内容contens<br><img src="/img/ios/UI/uiview.png"></li></ul><p>UIView和CAlayer从系统设计上符合 单一事件原则</p><hr><h3 id="系统UI事件传递及视图响应"><a href="#系统UI事件传递及视图响应" class="headerlink" title="系统UI事件传递及视图响应"></a>系统UI事件传递及视图响应</h3><h4 id="事件传递"><a href="#事件传递" class="headerlink" title="事件传递"></a>事件传递</h4><p>当一个用户事件产生的时候，UIKit 会创建一个事件对象来描述这个用户事件。然后它会将该事件对象放进UIApplication对象所维护的事件队列中。对于触摸事件而言，产生的事件对象便是一个包含UIEvent的集合(NSSet)对象，一个事件会朝着特定的路径进行传递直到遇到一个可以处理它的对象为止</p><p><strong><em>事件传递的两个重要方法</em></strong></p><ul><li><p>-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event</p></li><li><p>-（BOOL）pointInside:(CGPoint)point withEvent:(UIEvent *)event</p></li></ul><p><strong><em>事件传递流程图</em></strong><br><img src="/img/ios/UI/hitTest.png"></p><p>倒序遍历：最后添加的UIView最优先被遍历<br>hitTest如果有值，返回当前视图，结束事件传递,如果没有UIWindow就作为一个响应的视图</p><p><strong><em>hitTest:WithEvent系统是实现如图</em></strong><br><img src="/img/ios/UI/hitTestEvent.png"></p><ol><li><p>优先判读当前视图的：hidden alpha  等属性，如果不满足返回nil,也就是说当前视图，不作为响应者，然后在由父视图遍历同级兄弟视图</p></li><li><p>判读点击的点是否在当前视图，如果不满足返回nil,也就是<br>说当前视图，不作为响应者，然后在由父视图遍历同级兄弟视图</p></li><li><p>以倒序方式遍历当前视图的所有子视图，遍历过程 调用 hittest 方法,如果有对应的响应视图就返回，如果遍历完成之后，没有对应视图，由于 pointinside 在当前视图范围内，返回当前图作为响应视图返回给调用方</p></li></ol><h4 id="响应链"><a href="#响应链" class="headerlink" title="响应链"></a>响应链</h4><p>响应者链条是由响应者对象构成的，它们有一个共同点就是都是继承自UIResponder，UIResponder的程序接口不仅定义了事件处理方式，还有响应者的一些共同行为。UIApplication，UIViewController和UIView都是响应者，这意味着UIView与其所有子类和大多数主要控制器对象都是响应者，符合设计模式中责任链</p><p><img src="/img/ios/UI/responder.png"></p><ul><li><p>响应链:由离 户最近的view向系统传递。initial view –&gt; super view –&gt; …..–&gt; view controller –&gt; window –&gt; Application –&gt; AppDelegate</p></li><li><p>Hit-Testing 链:由系统向离户最近的view传递。 UIKit –&gt; active app’s event queue –&gt; window –&gt; root view –&gt;……–&gt;lowest view </p></li></ul><hr><h3 id="图层显示原理"><a href="#图层显示原理" class="headerlink" title="图层显示原理"></a>图层显示原理</h3><p><strong><em>cpu和gpu都做了哪些事情</em></strong></p><p><img src="/img/ios/UI/imagePrinciple.png"></p><p>cpu 和 gpu 两个是通过总线连接起来，那么我们在cpu中所输出结果往往是一个位图，再经由总线在合适的时机上传给 gpu, gpu 在拿到位图之后，做相应位图图层的渲染包括纹理合成之后再把结果放到帧缓冲区域当中，由视频控制器根据vsync信号在指定时间之前，去提取对应帧缓冲区域当中屏幕显示内容，然后最终显示在手机屏幕上</p><p><strong><em>UI 视图显示在屏幕上的大致过程</em></strong></p><p><img src="/img/ios/UI/iamgePrinciple1.png"></p><p>首先当我们创建了一个UIview 显示控件后，它的显示部分是由CAlayer 来负责，CAlayer 当中有一个contents 属性，就是我们最终要绘制到屏幕上面的位图，比如说我们创建了一个UIlabel,那么contens里面最终放的结果就是关于hello world的一个文字的位图，然后系统会在合适的时机，回调给我们一个drawRect方法，然后我们可以在此基础之上绘制一些，我们想自定义绘制的内容，绘制好的这个位图，最终经由Core Animation这个框架提交给 gpu 部分的openGL 渲染管线，进行最终位图的渲染和纹理合成，然后会显示我们的屏幕上。</p><p><strong><em>cpu工作</em></strong><br><img src="/img/ios/UI/cpu.png"></p><ul><li>layout: UI布局 文本的计算  </li><li>display: 绘制  </li><li>prepare: 图片编解码 </li><li>commit: 提交位图</li></ul><p><strong><em>gpu工作</em></strong></p><p><img src="/img/ios/UI/gpu.png"></p><h3 id="UI卡顿、掉帧的原因"><a href="#UI卡顿、掉帧的原因" class="headerlink" title="UI卡顿、掉帧的原因"></a>UI卡顿、掉帧的原因</h3><p><strong><em>如图</em></strong></p><p><img src="/img/ios/UI/uikadun.png"></p><ul><li>一般说页面滑动的流畅性是60fps , 指的就是每一秒中会有60帧的画面更新，我们在人眼上面看到的就是流畅效果，基于此每隔16.7ms就要产生一帧画面，在这16.7ms内需要 cpu 和 gpu协同完成这一帧的数据.</li><li>比如 cpu 花费一定的时间做 UI布局 文本计算 视图绘制 图片编解码 然后把产生位图提交给 gpu 进行渲染和纹理合成。准好下一帧画面，然后在下一帧的vsync 信号到来时候就可以显示这么样的一个画面。假如说 cpu 占用时间过长，那么留给gpu的时间就非常少，gpu要想完成工作，那么总时间就会超过16.7ms,这样在下一帧的vsync 信号到来时候，我们没有准备好当下的这一帧画面，那就由此产生了掉帧，看到的效果就是滑动的卡顿。</li></ul><p><strong>总结一句话，在规定的16.7ms内在下一帧vsync信号到来之前，并没有gpu和cpu共同完成下一帧画面的合成于是就会导致卡顿、掉帧</strong></p><hr><h3 id="UIView-绘制原理"><a href="#UIView-绘制原理" class="headerlink" title="UIView 绘制原理"></a>UIView 绘制原理</h3><p>当UIview 调用 setNeedDisplay 系统会调用 calayer 的同名方法，之后相当与在当前 layer打上了一个脏标记，然后会在当前runloop将要结束的时候才会调用CALayer display方法，进入当前视图真正绘制流程。</p><p><img src="/img/ios/UI/uiviwedisplay1.png"></p><h4 id="系统绘制流程"><a href="#系统绘制流程" class="headerlink" title="系统绘制流程"></a>系统绘制流程</h4><p><img src="/img/ios/UI/calayerbacking.png"></p><h4 id="异步绘制流程"><a href="#异步绘制流程" class="headerlink" title="异步绘制流程"></a>异步绘制流程</h4><blockquote><ul><li>-[layer.delegate displayLayer]</li><li>代理负责生成对应的bitmap</li><li>设置该bitmap作为 layer.contents的属性的值<br>  、<br><img src="/img/ios/UI/displayLayer.png"></li></ul></blockquote><h3 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h3><p><strong>离屏渲染：当我们指定UI视图的某些属性标记为在未愈合成之前不能用于当前屏幕显示就会触发离屏渲染，离屏渲染的概念起源于CPU层面，指的是GPU在当前屏幕缓冲区以新开辟一个缓冲区进行渲染操作</strong></p><h4 id="何时会触发？"><a href="#何时会触发？" class="headerlink" title="何时会触发？"></a>何时会触发？</h4><ul><li>圆角（当和 maskToBounds 一起使用时）</li><li>图层蒙版</li><li>阴影</li><li>光栅化</li></ul><h4 id="为何要避免？"><a href="#为何要避免？" class="headerlink" title="为何要避免？"></a>为何要避免？</h4><p><strong>在触发离屏渲染的时候，会增加GPU的工作量，而增加GPU的工作量很有可能会导致GPU和CPU的总耗时超过16.7ms,那么可能会导致UI掉帧和卡顿</strong></p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS  非指针型ISA(NONPOINTER_ISA)</title>
    <link href="/2020/12/09/iOS-isa/"/>
    <url>/2020/12/09/iOS-isa/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是NONPonter-isa？"><a href="#什么是NONPonter-isa？" class="headerlink" title="什么是NONPonter_isa？"></a>什么是NONPonter_isa？</h3><p> <strong>在iOS arm64架构下，isa指针在内存中占64位/bit,但是实际上并不会使用所有的地址空间,为了提高内存的利用率，在剩余的bit</strong><br> <strong>存储了关于内存管理的一些相关内容，所以说这个叫非指针型的isa</strong></p><h3 id="逐一分析这64个bit都存储那些内容"><a href="#逐一分析这64个bit都存储那些内容" class="headerlink" title="逐一分析这64个bit都存储那些内容"></a>逐一分析这64个bit都存储那些内容</h3><ol><li><strong>0-15 位内存地址</strong></li></ol><p><img src="/img/ios/isa15.png"></p><ul><li>indexed:0 代表的是纯isa 指针代表类对象的内存地址 1代表这个isa存储的不仅是类对象的地址而且内存管理方面的数据</li><li>has_assoc: 代表是否有关联对象  0 代表没有 1代表有</li><li>hass_cxx_ditor: 当前对象是否有使用c++</li><li>shifitcls: 当前对象类类对象的指针地址</li></ul><ol start="2"><li><strong>16-31 位内存地址</strong></li></ol><p><img src="/img/ios/isa31.png"></p><ol start="3"><li><p><strong>32-47 位内存地址</strong></p><p><img src="/img/ios/isa47.png"></p></li></ol><ul><li>magic: 不影响内存管理方面解答</li><li>wekkly_referenced: 标识了是否有 弱引用指针</li><li>deallocating: 当前对象是否正在进行dealloc 操作</li><li>has_sidetable_rc: 当前isa指针当中存储的引用计数已经达到了上限，需要外挂一个sidetable这样一个数据结构存储相关的引用计数内容</li><li>extra_rc: 额外的引用计数 当引用计数很小的时候 存储在isa 指针当中</li></ul><ol start="4"><li><strong>48-63 位内存地址</strong></li></ol><p><img src="/img/ios/isa63.png"></p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
